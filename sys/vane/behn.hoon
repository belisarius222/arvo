::  %BEHN, JUST A TIMER
!:
!?  164
::
=,  BEHN
|=  PIT=VASE
=>  |%
    +$  MOVE  [P=DUCT Q=(WIND NOTE:ABLE GIFT:ABLE)]
    +$  SIGN  ~
    ::
    +$  BEHN-STATE
      $:  TIMERS=(LIST TIMER)
          UNIX-DUCT=DUCT
          NEXT-WAKE=(UNIT @DA)
      ==
    ::
    +$  TIMER  [DATE=@DA =DUCT]
    --
::
=>  |%
++  PER-EVENT
  =|  MOVES=(LIST MOVE)
  |=  [[OUR=SHIP NOW=@DA =DUCT] STATE=BEHN-STATE]
  ::
  |%
  ::  %ENTRY-POINTS
  ::
  ::  +BORN: URBIT RESTARTED; REFRESH :NEXT-WAKE AND STORE WAKEUP TIMER DUCT
  ::
  ++  BORN  SET-UNIX-WAKE(NEXT-WAKE.STATE ~, UNIX-DUCT.STATE DUCT)
  ::  +CRUD: ERROR REPORT; HAND OFF TO %DILL TO BE PRINTED
  ::
  ++  CRUD
    |=  [P=@TAS Q=TANG]
    ^+  [MOVES STATE]
    [[DUCT %SLIP %D %FLOG %CRUD P Q]~ STATE]
  ::  +REST: CANCEL THE TIMER AT :DATE, THEN ADJUST UNIX WAKEUP
  ::  +WAIT: SET A NEW TIMER AT :DATE, THEN ADJUST UNIX WAKEUP
  ::
  ++  REST  |=(DATE=@DA SET-UNIX-WAKE(TIMERS.STATE (UNSET-TIMER [DATE DUCT])))
  ++  WAIT  |=(DATE=@DA SET-UNIX-WAKE(TIMERS.STATE (SET-TIMER [DATE DUCT])))
  ::  +VEGA: LEARN OF A KERNEL UPGRADE
  ::
  ++  VEGA  [MOVES STATE]
  ::  +WAKE: UNIX SAYS WAKE UP; PROCESS THE ELAPSED TIMER AND SET :NEXT-WAKE
  ::
  ++  WAKE
    ^+  [MOVES STATE]
    ::
    ?~  TIMERS.STATE  ~|(%BEHN-WAKE-NO-TIMER !!)
    ::  IF UNIX WOKE US TOO EARLY, RETRY BY RESETTING THE UNIX WAKEUP TIMER
    ::
    ?:  (GTH DATE.I.TIMERS.STATE NOW)
      ~?  DEBUG=%.N  [%BEHN-WAKE-TOO-SOON `@DR`(SUB DATE.I.TIMERS.STATE NOW)]
      SET-UNIX-WAKE(NEXT-WAKE.STATE ~)
    ::  POP FIRST TIMER, TELL VANE IT HAS ELAPSED, AND ADJUST NEXT UNIX WAKEUP
    ::
    =<  SET-UNIX-WAKE
    (EMIT-VANE-WAKE(TIMERS.STATE T.TIMERS.STATE) DUCT.I.TIMERS.STATE)
  ::  +WEGH: PRODUCE MEMORY USAGE REPORT FOR |MASS
  ::
  ++  WEGH
    ^+  [MOVES STATE]
    :_  STATE  :_  ~
    :^  DUCT  %GIVE  %MASS
    :+  %BEHN  %|
    :~  TIMERS+&+TIMERS.STATE
        DOT+&+STATE
    ==
  ::  %UTILITIES
  ::
  ::+|
  ::
  ++  EVENT-CORE  .
  ::  +EMIT-VANE-WAKE: PRODUCE A MOVE TO WAKE A VANE; ASSUMES NO PRIOR MOVES
  ::
  ++  EMIT-VANE-WAKE  |=(=^DUCT EVENT-CORE(MOVES [DUCT %GIVE %WAKE ~]~))
  ::  +EMIT-DOZE: SET NEW UNIX WAKEUP TIMER IN STATE AND EMIT MOVE TO UNIX
  ::
  ::    WE PREPEND THE UNIX %DOZE EVENT SO THAT IT IS HANDLED FIRST. ARVO MUST
  ::    HANDLE THIS FIRST BECAUSE THE MOVES %BEHN EMITS WILL GET HANDLED IN
  ::    DEPTH-FIRST ORDER. IF WE'RE HANDLING A %WAKE WHICH CAUSES A MOVE TO A
  ::    DIFFERENT VANE AND A %DOZE EVENT TO SEND TO UNIX, ARVO NEEDS TO PROCESS
  ::    THE %DOZE FIRST BECAUSE OTHERWISE IF THE MOVE TO THE OTHER VANE CALLS
  ::    BACK INTO %BEHN AND EMITS A SECOND %DOZE, THE SECOND %DOZE WOULD BE
  ::    HANDLED BY UNIX FIRST WHICH IS INCORRECT.
  ::
  ++  EMIT-DOZE
    |=  =DATE=(UNIT @DA)
    ^+  EVENT-CORE
    ::  MAKE SURE WE DON'T TRY TO WAKE UP IN THE PAST
    ::
    =?  DATE-UNIT  ?=(^ DATE-UNIT)  `(MAX NOW U.DATE-UNIT)
    ::
    %_  EVENT-CORE
      NEXT-WAKE.STATE  DATE-UNIT
      MOVES            [[UNIX-DUCT.STATE %GIVE %DOZE DATE-UNIT] MOVES]
    ==
  ::  +SET-UNIX-WAKE: SET OR UNSET NEXT UNIX WAKEUP TIMER BASED ON :I.TIMERS
  ::
  ++  SET-UNIX-WAKE
    =<  [MOVES STATE]
    ^+  EVENT-CORE
    ::
    =*  NEXT-WAKE  NEXT-WAKE.STATE
    =*  TIMERS     TIMERS.STATE
    ::  IF NO TIMERS, CANCEL EXISTING WAKEUP TIMER OR NO-OP
    ::
    ?~  TIMERS
      ?~  NEXT-WAKE
        EVENT-CORE
      (EMIT-DOZE ~)
    ::  IF :NEXT-WAKE IS IN THE PAST OR NOT SOON ENOUGH, RESET IT
    ::
    ?^  NEXT-WAKE
      ?:  &((GTE DATE.I.TIMERS U.NEXT-WAKE) (LTE NOW U.NEXT-WAKE))
        EVENT-CORE
      (EMIT-DOZE `DATE.I.TIMERS)
    ::  THERE WAS NO UNIX WAKEUP TIMER; SET ONE
    ::
    (EMIT-DOZE `DATE.I.TIMERS)
  ::  +SET-TIMER: SET A TIMER, MAINTAINING THE SORT ORDER OF THE :TIMERS LIST
  ::
  ++  SET-TIMER
    =*  TIMERS  TIMERS.STATE
    |=  T=TIMER
    ^+  TIMERS
    ::
    ?~  TIMERS
      ~[T]
    ::  IGNORE DUPLICATES
    ::
    ?:  =(T I.TIMERS)
      ~?  DEBUG=%.N  [%BEHN-SET-DUPLICATE T]
      TIMERS
    ::  TIMERS AT THE SAME DATE FORM A FIFO QUEUE
    ::
    ?:  (LTH DATE.T DATE.I.TIMERS)
      [T TIMERS]
    ::
    [I.TIMERS $(TIMERS T.TIMERS)]
  ::  +UNSET-TIMER: CANCEL A TIMER; IF IT ALREADY EXPIRED, NO-OP
  ::
  ++  UNSET-TIMER
    =*  TIMERS  TIMERS.STATE
    |=  T=TIMER
    ^+  TIMERS
    ::  IF WE DON'T HAVE THIS TIMER, NO-OP
    ::
    ?~  TIMERS
      ~?  DEBUG=%.N  [%BEHN-UNSET-MISSING T]
      ~
    ?:  =(I.TIMERS T)
      T.TIMERS
    ::
    [I.TIMERS $(TIMERS T.TIMERS)]
  --
--
::
=|  BEHN-STATE
=*  STATE  -
|=  [OUR=SHIP NOW=@DA ENY=@UVJ SKI=SLEY]
=*  BEHN-GATE  .
^?
|%
::  +CALL: HANDLE A +TASK:ABLE:BEHN REQUEST
::
++  CALL
  |=  $:  HEN=DUCT
          TYPE=*
          WRAPPED-TASK=(HOBO TASK:ABLE)
      ==
  ^-  [(LIST MOVE) _BEHN-GATE]
  ::
  =/  =TASK:ABLE
    ?.  ?=(%SOFT -.WRAPPED-TASK)
      WRAPPED-TASK
    ((HARD TASK:ABLE) P.WRAPPED-TASK)
  ::
  =/  EVENT-CORE  (PER-EVENT [OUR NOW HEN] STATE)
  ::
  =^  MOVES  STATE
    ?-  -.TASK
      %BORN  BORN:EVENT-CORE
      %CRUD  (CRUD:EVENT-CORE [P Q]:TASK)
      %REST  (REST:EVENT-CORE DATE=P.TASK)
      %VEGA  VEGA:EVENT-CORE
      %WAIT  (WAIT:EVENT-CORE DATE=P.TASK)
      %WAKE  WAKE:EVENT-CORE
      %WEGH  WEGH:EVENT-CORE
    ==
  [MOVES BEHN-GATE]
::  +LOAD: MIGRATE AN OLD STATE TO A NEW BEHN VERSION
::
++  LOAD
  |=  OLD=*
  ^+  BEHN-GATE
  ::
  ~|  %BEHN-LOAD-FAIL
  BEHN-GATE(STATE (BEHN-STATE OLD))
::  +SCRY: VIEW TIMER STATE
::
::    TODO: NOT REFERENTIALLY TRANSPARENT W.R.T. ELAPSED TIMERS,
::    WHICH MIGHT OR MIGHT NOT SHOW UP IN THE PRODUCT
::
++  SCRY
  |=  [FUR=(UNIT (SET MONK)) REN=@TAS WHY=SHOP SYD=DESK LOT=COIN TYL=PATH]
  ^-  (UNIT (UNIT CAGE))
  ::
  ?.  ?=(%& -.WHY)
    ~
  [~ ~ %TANK !>(>TIMERS<)]
::
++  STAY  STATE
++  TAKE
  |=  [TEA=WIRE HEN=DUCT HIN=(HYPO SIGN)]
  ^-  [(LIST MOVE) _BEHN-GATE]
  ~|  %BEHN-TAKE-NOT-IMPLEMENTED
  !!
--

