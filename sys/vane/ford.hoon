::  FORD: BUILD SYSTEM VANE
!:
::    FORD IS A FUNCTIONAL REACTIVE BUILD SYSTEM.
::
::    A FORD BUILD IS A FUNCTION OF THE URBIT NAMESPACE AND A DATE THAT
::    PRODUCES MARKED, TYPED DATA OR AN ERROR.
::
::    THE FUNCTION IN THE DEFINITION OF A BUILD IS CALLED A "SCHEMATIC,"
::    AND IT'S REPRESENTED BY A HOON DATA STRUCTURE WITH TWENTY-FIVE SUB-TYPES.
::    A SCHEMATIC IS A (POSSIBLY TRIVIAL) DAG OF SUB-BUILDS TO BE PERFORMED.
::    THE DIFFERENT SCHEMATIC SUB-TYPES TRANSFORM THE RESULTS OF THEIR
::    SUB-BUILDS IN DIFFERENT WAYS.
::
::    WE CALL THE DATE IN THE DEFINITION OF A BUILD THE "FORMAL DATE" TO
::    DISTINGUISH IT FROM THE TIME AT WHICH THE BUILD WAS PERFORMED.
::
::    EACH BUILD IS REFERENTIALLY TRANSPARENT WITH RESPECT TO ITS FORMAL DATE:
::    ASK TO RUN THAT FUNCTION ON THE NAMESPACE AND A PARTICULAR FORMAL DATE,
::    AND FORD WILL ALWAYS PRODUCE THE SAME RESULT.
::
::    WE CAN NOW SAY FORD IS A FUNCTIONAL BUILD SYSTEM, SINCE EACH BUILD IS A
::    FUNCTION. WE HAVE NOT YET EXPLAINED HOW IT'S A FUNCTIONAL REACTIVE BUILD
::    SYSTEM. WITH FORD, YOU CAN SUBSCRIBE TO RESULTS OF A BUILD. FORD TRACKS
::    THE RESULT OF A "LIVE" BUILD CONSISTING OF A STATIC SCHEMATIC AND THE
::    EVER-CHANGING CURRENT DATE. WHENEVER THIS LIVE BUILD'S RESULT CHANGES,
::    FORD SENDS YOU THE NEW RESULT AND THE FORMAL DATE OF THE BUILD (THE DATE
::    WHICH WOULD CAUSE THE SAME RESULT IF YOU ASKED FORD TO BUILD THAT
::    SCHEMATIC AGAIN). THIS IS A PUSH-BASED FRP PARADIGM.
::
::    THE IMPLEMENTATION IS EVENT-DRIVEN, LIKE THE REST OF URBIT. WHILE
::    PERFORMING A BUILD, FORD REGISTERS EACH NAMESPACE ACCESS AS A DEPENDENCY
::    AND ALSO NOTES WHETHER THE DEPENDENCY IS "LIVE," MEANING THE PATH WITHIN
::    THE NAMESPACE UPDATES WITH TIME. FOR EXAMPLE A LIVE CLAY DEPENDENCY WOULD
::    UPDATE THE +CASE WITHIN THE +BEAM OVER TIME.
::
::    A REQUEST TO PERFORM A BUILD WITHOUT SUBSCRIBING TO ITS FUTURE CHANGES IS
::    CALLED A "ONCE BUILD."
::
::    AFTER FINISHING A BUILD, FORD SUBSCRIBES TO UPDATES ON THE BUILD'S
::    DEPENDENCIES. FOR NOW, THIS JUST MEANS IT SUBSCRIBES TO CLAY FOR FILE
::    CHANGES. WHENEVER ANY OF THE FILES IN THE SUBSCRIPTION HAVE NEW CONTENTS,
::    CLAY WILL NOTIFY FORD, WHICH WILL THEN RERUN ANY LIVE BUILDS THAT DEPEND
::    ON ANY OF THE CHANGED FILES AND SEND ITS SUBSCRIBERS THE NEW RESULTS.
::
::    THIS MATCHES THE SEMANTICS OF LIVE BUILDS DEFINED ABOVE. IF SOMEONE HAD
::    ASKED FOR A BUILD OF THE SCHEMATIC WITH A FORMAL DATE D2 JUST BEFORE THE
::    CHANGED CLAY FILES, FORD WOULD RESPOND WITH THE RESULT OF THE PREVIOUS
::    BUILD WITH FORMAL DATE D1, WHICH WOULD STILL BE AN ACCURATE
::    REPRESENTATION OF THE SCHEMATIC'S RESULT AT D2, SINCE FORD KNOWS NONE OF
::    ITS DEPENDENCIES CHANGED BETWEEN D1 AND D2.
::
::    NOTE THAT FORD CAN ONLY CALCULATE DEPENDENCIES AFTER RUNNING A BUILD,
::    NOT BEFORE. THIS IS BECAUSE FORD CAN BE THOUGHT OF AS AN INTERPRETER FOR
::    SCHEMATICS, RATHER THAN A COMPILER, IN THE SENSE THAT IT CAN'T HAVE A
::    DEPENDENCY-GATHERING STEP FOLLOWED BY A BUILD STEP. THE DEPENDENCIES OF
::    SOME SCHEMATICS MUST BE CALCULATED BASED ON RESULTS, E.G. THE %ALTS
::    SCHEMATIC, WHICH TRIES A SEQUENCE OF SUB-BUILDS UNTIL ONE SUCCEEDS. IF
::    THE FIRST SUB-BUILD SUCCEEDS, THE BUILD DEPENDS ONLY ON THAT FIRST
::    SUB-BUILD, BUT IF THE FIRST FAILS AND THE SECOND SUCCEEDS, THE BUILD
::    DEPENDS ON BOTH.
::
::    THIS DYNAMICITY IMPLIES WE DON'T KNOW WHAT WE DEPEND ON UNTIL WE DEPEND
::    ON IT. MOST BUILD SYSTEMS HAVE THIS PROPERTY, BUT THIS PART OF FORD'S
::    JOB IS EASIER THAN FOR MOST UNIX-BASED BUILD SYSTEMS: FORD DRAWS ALL
::    RESOURCES FROM AN IMMUTABLE NAMESPACE, AND IT CAN TRACK EVERY ACCESS OF
::    THAT NAMESPACE.
::
::    FORD MIGHT PRODUCE A BUILD'S RESULT ASYNCHRONOUSLY, IN A SUBSEQUENT ARVO
::    EVENT. THIS HAPPENS WHEN ACCESSING THE NAMESPACE DOESN'T COMPLETE
::    SYNCHRONOUSLY, SUCH AS WHEN GRABBING A FILE FROM ANOTHER SHIP. FORD
::    GUARANTEES IT WILL RESPOND WITH BUILD RESULTS IN CHRONOLOGICAL ORDER
::    USING THE FORMAL DATE, NOT THE ORDER IN WHICH THE BUILDS COMPLETED.
::
::    FORD DOES NOT GUARANTEE IT WILL NOTIFY A SUBSCRIBER OF A CHANGED BUILD
::    ONLY ONCE PER CHANGE. IN COMMON USAGE IT WILL NOT SEND DUPLICATE
::    NOTIFICATIONS, BUT IT MIGHT IF ITS CACHE WAS RECENTLY WIPED.
::
::    FORD USES DEPENDENCY TRACKING, CACHING, AND RESULTS OF PREVIOUS BUILDS
::    TO ELIMINATE EXCESS WORK. WHEN RERUNNING A LIVE BUILD, FORD "PROMOTES"
::    PREVIOUS RESULTS TO THE NEW TIME IF THE BUILD'S DEPENDENCIES HVAEN'T
::    CHANGED SINCE THE PREVIOUS BUILD'S FORMAL DATE. FORD DOES THIS CHECK
::    FOR EACH BUILD IN A TREE OF SUB-BUILDS UNDER THE "ROOT BUILD," WHICH
::    IS THE BUILD THAT WAS REQUESTED DIRECTLY.
::
::    IN ADDITION TO THE MAIN %BUILD +TASK SUB-TYPE, FORD ALSO SUPPORTS
::    FOUR OTHER COMMANDS:
::
::    %KILL: CANCEL A BUILD
::
::      A ONCE BUILD IN PROGRESS WILL BE CANCELED, INCLUDING ALL OF ITS
::      SUB-BUILDS THAT AREN'T PART OF ANY OTHER BUILDS.
::
::      A LIVE BUILD'S SUBSCRIPTIONS WILL BE CANCELED, ITS COMPLETED RESULTS
::      WILL BE DELETED, AND ITS DEPENDENCY TRACKING INFORMATION WILL BE
::      DELETED. IF A REBUILD IS IN PROGRESS, IT WILL BE CANCELED.
::
::    %KEEP: RESIZE CACHES
::
::      FORD MAINTAINS TWO CACHES: A :COMPILER-CACHE THAT STORES
::      CONTENT-ADDRESSED COMPILER OPERATIONS, SUCH AS PARSING, COMPILING,
::      AND TYPE INFERENCE; AND A :BUILD-CACHE THAT STORES PREVIOUSLY
::      COMPLETED BUILD TREES ALONG WITH THEIR RESULTS AND DEPENDENCY TRACKING.
::
::      THE %KEEP COMMAND RESETS THE MAXIMUM SIZES OF THESE CACHES, DELETING
::      ENTRIES IF NECESSARY.
::
::    %WIPE: DECIMATE STORAGE
::
::      THE %WIPE COMMAND REMOVES BUILD RESULTS FROM STORAGE TO FREE MEMORY.
::      IT DELETES THE SPECIFIED PERCENTAGE OF BUILD RESULTS, IN LRU
::      (LEAST RECENTLY USED) ORDER. IT ALSO REMOVES ENTRIES FROM THE COMPILER
::      CACHE. IT DOES NOT REMOVE DEPENDENCY TRACKING INFORMATION.
::
::    %WEGH: REPORT MEMORY USAGE
::
::      LIKE ALL VANES, FORD CAN ALSO BE ASKED TO PRODUCE A HUMAN-READABLE
::      REPORT OF ITS MEMORY USAGE. NOCK CANNOT CALCULATE ITS OWN MEMORY USE
::      DIRECTLY, SO INSTEAD WE PRODUCE THE NOUNS THEMSELVES, WHICH THE RUNTIME
::      "WEIGHS" BASED ON ITS MEMORY MODEL.
::
::    FOR DETAILS ON FORD'S IMPLEMENTATION, CONSULT FORD'S VANE INTERFACE CORE
::    NEAR THE BOTTOM OF THE FILE.
::
::  PIT: A +VASE OF THE HOON+ZUSE KERNEL, WHICH IS A DEEPLY NESTED CORE
::
|=  PIT=VASE
::
=,  CONTAIN
=,  FORD
::  FORD INTERNAL DATA STRUCTURES
::
=>  =~
|%
::  +MOVE: ARVO MOVES THAT FORD CAN EMIT
::
+=  MOVE
  ::
  $:  ::  DUCT: REQUEST IDENTIFIER
      ::
      =DUCT
      ::  CARD: MOVE CONTENTS; EITHER A +NOTE OR A +GIFT:ABLE
      ::
      CARD=(WIND NOTE GIFT:ABLE)
  ==
::  +NOTE: PRIVATE REQUEST FROM FORD TO ANOTHER VANE
::
+=  NOTE
  $%  ::  %C: TO CLAY
      ::
      $:  %C
          ::  %WARP: INTERNAL (INTRA-SHIP) FILE REQUEST
          ::
          $%  $:  %WARP
                  ::  SHIP: TARGET FOR REQUEST
                  ::
                  =SHIP
                  ::  RIFF: CLAY REQUEST CONTENTS
                  ::
                  RIFF=RIFF:CLAY
  ==  ==  ==  ==
::  +SIGN: PRIVATE RESPONSE FROM ANOTHER VANE TO FORD
::
+=  SIGN
  $%  ::  %C: FROM CLAY
      ::
      $:  %C
          ::  %WRIT: INTERNAL (INTRA-SHIP) FILE RESPONSE
          ::
          $%  $:  %WRIT
                  ::  RIOT: RESPONSE CONTENTS
                  ::
                  RIOT=RIOT:CLAY
              ==
              ::  %WRIS: RESPONSE TO %MULT; MANY CHANGED FILES
              ::
              $:  %WRIS
                  ::  CASE: CASE OF THE NEW FILES
                  ::
                  ::    %WRIS CAN ONLY RETURN DATES TO US.
                  ::
                  CASE=[%DA P=@DA]
                  ::  CARE-PATHS: THE +CARE:CLAY AND +PATH OF EACH FILE
                  ::
                  CARE-PATHS=(SET [CARE=CARE:CLAY =PATH])
  ==  ==  ==  ==
--
|%
::  +AXLE: OVERALL FORD STATE
::
+=  AXLE
  $:  ::  DATE: DATE AT WHICH FORD'S STATE WAS UPDATED TO THIS DATA STRUCTURE
      ::
      DATE=%~2018.12.13
      ::  STATE: ALL PERSISTENT STATE
      ::
      STATE=FORD-STATE
  ==
::  +FORD-STATE: ALL STATE THAT FORD MAINTAINS
::
+=  FORD-STATE
  $:  ::  BUILDS: PER-BUILD STATE MACHINE FOR ALL BUILDS
      ::
      ::    FORD HOLDS ONTO ALL IN-PROGRESS BUILDS THAT WERE EITHER DIRECTLY
      ::    REQUESTED BY A DUCT (ROOT BUILDS) OR THAT ARE DEPENDENCIES
      ::    (SUB-BUILDS) OF A DIRECTLY REQUESTED BUILD.
      ::
      ::    IT ALSO STORES THE LAST COMPLETED VERSION OF EACH LIVE BUILD TREE
      ::    (ROOT BUILD AND SUB-BUILDS), AND ANY CACHED BUILDS.
      ::
      BUILDS=(MAP BUILD BUILD-STATUS)
      ::  DUCTS: PER-DUCT STATE MACHINE FOR ALL INCOMING DUCTS (BUILD REQUESTS)
      ::
      ::    FORD TRACKS EVERY DUCT THAT HAS REQUESTED A BUILD UNTIL IT HAS
      ::    FINISHED DEALING WITH THAT REQUEST.
      ::
      ::    FOR LIVE DUCTS, WE STORE THE DUCT WHILE WE REPEATEDLY RUN NEW
      ::    VERSIONS OF THE LIVE BUILD IT REQUESTED UNTIL IT IS EXPLICITLY
      ::    CANCELED BY THE REQUESTER.
      ::
      ::    A ONCE (NON-LIVE) DUCT, ON THE OTHER HAND, WILL BE REMOVED
      ::    AS SOON AS THE REQUESTED BUILD HAS BEEN COMPLETED.
      ::
      DUCTS=(MAP DUCT DUCT-STATUS)
      ::  BUILDS-BY-SCHEMATIC: ALL ATTEMPTED BUILDS, SORTED BY TIME
      ::
      ::    FOR EACH SCHEMATIC WE'VE ATTEMPTED TO BUILD AT ANY TIME,
      ::    LIST THE FORMAL DATES OF ALL BUILD ATTEMPTS, SORTED NEWEST FIRST.
      ::
      BUILDS-BY-SCHEMATIC=(MAP SCHEMATIC (LIST @DA))
      ::  PENDING-SCRYS: OUTGOING REQUESTS FOR STATIC RESOURCES
      ::
      PENDING-SCRYS=(REQUEST-TRACKER SCRY-REQUEST)
      ::  PENDING-SUBSCRIPTIONS: OUTGOING SUBSCRIPTIONS ON LIVE RESOURCES
      ::
      PENDING-SUBSCRIPTIONS=(REQUEST-TRACKER SUBSCRIPTION)
      ::  BUILD-CACHE: FIFO QUEUE OF COMPLETED ROOT BUILDS
      ::
      $=  BUILD-CACHE
      $:  ::  NEXT-ANCHOR-ID: INCREMENTING IDENTIFIER FOR CACHE ANCHORS
          ::
          NEXT-ANCHOR-ID=@UD
          ::  QUEUE: FIFO QUEUE OF ROOT BUILDS IDENTIFIED BY ANCHOR ID
          ::
          QUEUE=(CAPPED-QUEUE BUILD-CACHE-KEY)
      ==
      ::  COMPILER-CACHE: CLOCK BASED CACHE OF BUILD RESULTS
      ::
      COMPILER-CACHE=(CLOCK COMPILER-CACHE-KEY BUILD-RESULT)
  ==
::  +ANCHOR: SOMETHING WHICH HOLDS ON TO BUILDS
::
::    AN ANCHOR IS A REFERENCE WHICH KEEPS BUILDS. THIS IS EITHER A %DUCT, IN
::    WHICH CASE THE BUILD IS LIVE BECAUSE A DUCT IS WAITING FOR A RESPONSE, OR
::    A %CACHE, IN WHICH CASE THE ANCHOR IS A CACHED BUILD.
::
::    WHEN A DUCT WOULD BE REMOVED FROM A BUILD, THE %DUCT ANCHOR IS REPLACED
::    WITH A %CACHE ANCHOR. THIS %CACHE ANCHOR REFERS TO A FIFO QUEUE OF CACHED
::    BUILDS.
::
+=  ANCHOR
  $%  ::  %DUCT: THIS IS ANCHORED ON A DUCT
      ::
      [%DUCT =DUCT]
      ::  %CACHE: THIS IS ANCHORED TO A CACHE ENTRY
      ::
      [%CACHE ID=@UD]
  ==
::  +BUILD-STATUS: CURRENT DATA FOR A BUILD, INCLUDING CONSTRUCTION STATUS
::
::    +BUILD-STATUS STORES THE CONSTRUCTION STATUS OF A BUILD AS A FINITE STATE
::    MACHINE (:STATE). IT STORES LINKS TO DEPENDENT SUB-BUILDS IN :SUBS, AND
::    PER-DUCT CLIENT BUILDS IN :CLIENTS.
::
+=  BUILD-STATUS
  $:  ::  REQUESTERS: DUCTS FOR WHOM THIS BUILD IS THE ROOT BUILD
      ::
      REQUESTERS=(SET ANCHOR)
      ::  CLIENTS: PER DUCT INFORMATION FOR THIS BUILD
      ::
      CLIENTS=(JUG ANCHOR BUILD)
      ::  SUBS: SUB-BUILDS OF THIS BUILD, FOR WHOM THIS BUILD IS A CLIENT
      ::
      SUBS=(MAP BUILD BUILD-RELATION)
      ::  STATE: A STATE MACHINE FOR TRACKING THE BUILD'S PROGRESS
      ::
      $=  STATE
      $%  $:  ::  %UNTRIED: BUILD HAS NOT BEEN STARTED YET
              ::
              %UNTRIED  ~
          ==
          $:  ::  %BLOCKED: BUILD BLOCKED ON EITHER SUB-BUILDS OR RESOURCE
              ::
              ::    IF WE'RE IN THIS STATE AND THERE ARE NO BLOCKS IN :SUBS,
              ::    THEN WE'RE BLOCKED ON A RESOURCE.
              ::
              %BLOCKED  ~
          ==
          $:  ::  %UNBLOCKED: WE WERE BLOCKED BUT NOW WE AREN'T
              ::
              %UNBLOCKED  ~
          ==
          $:  ::  %COMPLETE: BUILD HAS FINISHED RUNNING AND HAS A RESULT
              ::
              %COMPLETE
              ::  BUILD-RECORD: THE PRODUCT OF THE BUILD, POSSIBLY TOMBSTONED
              ::
              =BUILD-RECORD
  ==  ==  ==
::  +DUCT-STATUS: INFORMATION RELATING A BUILD TO A DUCT
::
+=  DUCT-STATUS
  $:  ::  LIVE: WHETHER THIS DUCT IS BEING RUN LIVE
      ::
      $=  LIVE
      $%  [%ONCE IN-PROGRESS=@DA]
          $:  %LIVE
              ::
              ::
              IN-PROGRESS=(UNIT @DA)
              ::  THE LAST SUBSCRIPTION WE MADE
              ::
              ::    THIS CAN POSSIBLY HAVE AN EMPTY SET OF RESOURCES, IN WHICH
              ::    WE NEVER SENT A MOVE.
              ::
              ::    NOTE: THIS IMPLIES THAT A SINGLE LIVE BUILD CAN ONLY DEPEND
              ::    ON LIVE RESOURCES FROM A SINGLE DISC. WE DON'T HAVE A
              ::    WORKING PLAN FOR FIXING THIS AND WILL NEED TO THINK VERY
              ::    HARD ABOUT THE FUTURE.
              ::
              LAST-SENT=(UNIT [DATE=@DA SUBSCRIPTION=(UNIT SUBSCRIPTION)])
      ==  ==
      ::  ROOT-SCHEMATIC: THE REQUESTED BUILD FOR THIS DUCT
      ::
      ROOT-SCHEMATIC=SCHEMATIC
  ==
::  +BUILD-RELATION: HOW DO TWO BUILDS RELATE TO EACH OTHER?
::
::    A +BUILD-RELATION CAN BE EITHER :VERIFIED OR NOT, AND :BLOCKED OR NOT.
::    IT IS A SYMMETRIC RELATION BETWEEN TWO BUILDS, IN THE SENSE THAT BOTH
::    THE CLIENT AND THE SUB WILL STORE THE SAME RELATION, JUST POINTING TO
::    THE OTHER BUILD.
::
::    IF IT'S NOT :VERIFIED, THEN THE RELATION IS A GUESS BASED ON PREVIOUS
::    BUILDS. THESE GUESSES ARE USED TO ENSURE THAT WE HOLD ONTO BUILDS WE
::    EXPECT TO BE USED IN FUTURE BUILDS. EACH TIME WE RUN +MAKE ON A BUILD,
::    IT MIGHT PRODUCE NEW :VERIFIED SUB-BUILDS, WHICH MAY HAVE BEEN UNVERIFIED
::    UNTIL THEN. ONCE A BUILD COMPLETES, ANY UNVERIFIED SUB-BUILDS MUST BE
::    CLEANED UP, SINCE IT TURNED OUT THEY WEREN'T USED BY THE BUILD AFTER ALL.
::
::    :BLOCKED IS USED TO NOTE THAT A BUILD CAN'T BE COMPLETED UNTIL THAT
::    SUB-BUILD HAS BEEN COMPLETED. A RELATION CAN BE :BLOCKED BUT NOT :VERIFIED
::    IF WE'RE TRYING TO PROMOTE A BUILD, BUT WE HAVEN'T RUN ALL ITS SUB-BUILDS
::    YET. IN THAT CASE, WE'LL TRY TO PROMOTE OR RUN THE SUB-BUILD IN ORDER TO
::    DETERMINE WHETHER WE CAN PROMOTE THE CLIENT. UNTIL THE SUB-BUILD HAS BEEN
::    COMPLETED, THE CLIENT IS PROVISIONALLY BLOCKED ON THE SUB-BUILD.
::
+=  BUILD-RELATION
  $:  ::  VERIFIED: DO WE KNOW THIS RELATION IS REAL, OR IS IT ONLY A GUESS?
      ::
      VERIFIED=?
      ::  IS THIS BUILD BLOCKED ON THIS OTHER BUILD?
      ::
      BLOCKED=?
  ==
::  +BUILD-RECORD: INFORMATION ASSOCIATED WITH THE RESULT OF A COMPLETED +BUILD
::
+=  BUILD-RECORD
  $%  $:  ::  %TOMBSTONE: THE BUILD'S RESULT HAS BEEN WIPED
          ::
          %TOMBSTONE  ~
      ==
      $:  ::  %VALUE: WE HAVE THE +BUILD-RESULT
          ::
          %VALUE
          ::  LAST-ACCESSED: LAST TIME WE LOOKED AT THE RESULT
          ::
          ::    THIS IS USED FOR LRU CACHE RECLAMATION.
          ::
          LAST-ACCESSED=@DA
          ::  BUILD-RESULT: THE STORED VALUE OF THE BUILD'S PRODUCT
          ::
          =BUILD-RESULT
  ==  ==
::  +BUILD: A REFERENTIALLY TRANSPARENT REQUEST FOR A BUILD
::
::    EACH UNIQUE +BUILD WILL ALWAYS PRODUCE THE SAME +BUILD-RESULT
::    WHEN RUN (IF IT COMPLETES). A LIVE BUILD CONSISTS OF A SEQUENCE OF
::    INSTANCES OF +BUILD WITH THE SAME :SCHEMATIC AND INCREASING :DATE.
::
+=  BUILD
  $:  ::  DATE: THE FORMAL DATE OF THIS BUILD; UNRELATED TO TIME OF EXECUTION
      ::
      DATE=@DA
      ::  SCHEMATIC: THE SCHEMATIC THAT DETERMINES HOW TO RUN THIS BUILD
      ::
      =SCHEMATIC
  ==
::  +REQUEST-TRACKER: GENERIC TRACKER AND MULTIPLEXER FOR PENDING REQUESTS
::
++  REQUEST-TRACKER
  |*  REQUEST-TYPE=MOLD
  %+  MAP  REQUEST-TYPE
  $:  ::  WAITING: DUCTS BLOCKED ON THIS REQUEST
      ::
      WAITING=(SET DUCT)
      ::  ORIGINATOR: THE DUCT THAT KICKED OFF THE REQUEST
      ::
      ORIGINATOR=DUCT
  ==
::  +SUBSCRIPTION: A SINGLE SUBSCRIPTION TO CHANGES ON A SET OF RESOURCES
::
+=  SUBSCRIPTION
  $:  ::  DATE: DATE THIS WAS MADE
      ::
      DATE=@DA
      ::  DISC: SHIP AND DESK FOR ALL :RESOURCES
      ::
      =DISC
      ::  RESOURCES: WE WILL BE NOTIFIED IF ANY OF THESE RESOURCES CHANGE
      ::
      RESOURCES=(SET RESOURCE)
  ==
::  +SCRY-REQUEST: PARSED ARGUMENTS TO A SCRY OPERATION
::
+=  SCRY-REQUEST
  $:  ::  VANE: THE VANE FROM WHICH TO MAKE THE REQUEST
      ::
      ::    IF WE ADD OTHER VANES IN THE FUTURE, THIS WILL BECOME A FORK TYPE.
      ::    FOR NOW, THOUGH, FORD ONLY KNOWS HOW TO MAKE ASYNCHRONOUS SCRY
      ::    REQUESTS TO CLAY.
      ::
      VANE=%C
      ::  CARE: TYPE OF REQUEST
      ::
      CARE=CARE:CLAY
      ::  BEAM: REQUEST PATH
      ::
      =BEAM
  ==
::  +COMPILER-CACHE-KEY: CONTENT ADDRESSABLE BUILD DEFINITIONS
::
+=  COMPILER-CACHE-KEY
  $%  [%CALL GATE=VASE SAMPLE=VASE]
      [%HOOD =BEAM TXT=@T]
      [%RIDE FORMULA=HOON SUBJECT=VASE]
      [%SLIM SUBJECT-TYPE=TYPE FORMULA=HOON]
      [%SLIT GATE=TYPE SAMPLE=TYPE]
  ==
::  +BUILD-CACHE-KEY: KEY FOR THE FIFO CACHE OF COMPLETED BUILD TREES
::
+=  BUILD-CACHE-KEY
  $:  ::  ID: INCREMENTING IDENTIFIER FOR AN +ANCHOR
      ::
      ID=@UD
      ::  ROOT-BUILD: THE ROOT BUILD ASSOCIATED WITH THIS ANCHOR
      ::
      ROOT-BUILD=BUILD
  ==
::  +BUILD-RECEIPT: RESULT OF RUNNING +MAKE
::
::    A +BUILD-RECEIPT CONTAINS ALL INFORMATION NECESSARY TO PERFORM THE
::    EFFECTS AND STATE MUTATIONS INDICATED BY A CALL TO +MAKE. IF :BUILD
::    SUCCEEDED, :RESULT WILL BE %BUILD-RESULT; OTHERWISE, IT WILL BE %BLOCKS.
::
::    AFTER +MAKE RUNS ON A BATCH OF BUILDS, THE RESULTING +BUILD-RECEIPT'S ARE
::    APPLIED ONE AT A TIME.
::
+=  BUILD-RECEIPT
  $:  ::  BUILD: THE BUILD WE WORKED ON
      ::
      =BUILD
      ::  RESULT: THE OUTCOME OF THIS BUILD
      ::
      $=  RESULT
      $%  ::  %BUILD-RESULT: THE BUILD PRODUCED A RESULT
          ::
          $:  %BUILD-RESULT
              =BUILD-RESULT
          ==
          ::  %BLOCKS: THE BUILD BLOCKED ON THE FOLLOWING BUILDS OR RESOURCE
          ::
          $:  %BLOCKS
              ::  BUILDS: BUILDS THAT :BUILD BLOCKED ON
              ::
              BUILDS=(LIST BUILD)
          ==
      ==
      ::  SUB-BUILDS: SUBBUILDS OF :BUILD
      ::
      ::    WHILE RUNNING +MAKE ON :BUILD, WE NEED TO KEEP TRACK OF ANY
      ::    SUB-BUILDS THAT WE TRY TO ACCESS SO WE CAN KEEP TRACK OF
      ::    COMPONENT LINKAGES AND CACHE ACCESS TIMES.
      ::
      SUB-BUILDS=(LIST BUILD)
      ::  CACHE-ACCESS: IF NOT ~, CACHE THIS RESULT AS :COMPILER-CACHE-KEY.
      ::
      CACHE-ACCESS=(UNIT [=COMPILER-CACHE-KEY NEW=?])
  ==
--
=,  FORMAT
|%
::  +TEAR: SPLIT A +TERM INTO SEGMENTS DELIMITED BY `-`
::
::  EXAMPLE:
::  ```
::  DOJO> (TEAR 'FOO-BAR-BAZ')
::  ['FOO' 'BAR' 'BAZ']
::  ```
::
++  TEAR
  |=  A=TERM
  ^-  (LIST TERM)
  ::  SYM-NO-HEPS: A PARSER FOR TERMS WITH NO HEPS AND A LEADING LETTER
  ::
  =/  SYM-NO-HEPS  (COOK CRIP ;~(PLUG LOW (STAR ;~(POSE LOW NUD))))
  ::
  (FALL (RUSH A (MOST HEP SYM-NO-HEPS)) /[A])
::  +SEGMENTS: COMPUTE ALL PATHS FROM :PATH-PART, REPLACING SOME `/`S WITH `-`S
::
::    FOR EXAMPLE, WHEN PASSED A :PATH-PART OF 'FOO-BAR-BAZ',
::    THE PRODUCT WILL CONTAIN:
::    ```
::    DOJO> (SEGMENTS 'FOO-BAR-BAZ')
::    [/FOO/BAR/BAZ /FOO/BAR-BAZ /FOO-BAR/BAZ /FOO-BAR-BAZ]
::    ```
::
++  SEGMENTS
  |=  PATH-PART=@TAS
  ^-  (LIST PATH)
  ::
  =/  JOIN  |=([A=@TAS B=@TAS] (CRIP "{(TRIP A)}-{(TRIP B)}"))
  ::
  =/  TORN=(LIST @TAS)  (TEAR PATH-PART)
  ::
  |-  ^-  (LIST (LIST @TAS))
  ::
  ?<  ?=(~ TORN)
  ::
  ?:  ?=([@ ~] TORN)
    ~[TORN]
  ::
  %-  ZING
  %+  TURN  $(TORN T.TORN)
  |=  S=(LIST @TAS)
  ^-  (LIST (LIST @TAS))
  ::
  ?>  ?=(^ S)
  ~[[I.TORN S] [(JOIN I.TORN I.S) T.S]]
::  +BUILD-TO-TAPE: CONVERT :BUILD TO A PRINTABLE FORMAT
::
::    BUILDS OFTEN CONTAIN THE STANDARD LIBRARY AND LARGE TYPES, SO
::    THIS FUNCTION SHOULD ALWAYS BE CALLED WHEN TRYING TO PRINT A +BUILD.
::
++  BUILD-TO-TAPE
  |=  =BUILD
  ^-  TAPE
  ~+
  ::
  =/  ENCLOSE  |=(TAPE "[{+<}]")
  =/  DATE=@DA  DATE.BUILD
  =/  =SCHEMATIC  SCHEMATIC.BUILD
  ::
  %-  ENCLOSE
  %+  WELP  (TRIP (SCOT %DA DATE))
  %+  WELP  " "
  ::
  ?+      -.SCHEMATIC
        :(WELP "[" (TRIP -.SCHEMATIC) " {<`@UVI`(MUG SCHEMATIC)>}]")
      ::
      %$
    "LITERAL"
  ::
      ^
    %-  ENCLOSE
    ;:(WELP $(BUILD [DATE HEAD.SCHEMATIC]) " " $(BUILD [DATE TAIL.SCHEMATIC]))
  ::
      %ALTS
    ;:  WELP
      %+  ROLL  CHOICES.SCHEMATIC
      |=  [CHOICE=^SCHEMATIC TXT=_"[ALTS"]
      :(WELP TXT " " ^$(SCHEMATIC.BUILD CHOICE))
    ::
      "]"
    ==
  ::
      %CORE
    :(WELP "[CORE " (SPUD (EN-BEAM (RAIL-TO-BEAM SOURCE-PATH.SCHEMATIC))) "]")
  ::
      %HOOD
    :(WELP "[HOOD " (SPUD (EN-BEAM (RAIL-TO-BEAM SOURCE-PATH.SCHEMATIC))) "]")
  ::
      %PLAN
    ;:  WELP
      "[PLAN "
      (SPUD (EN-BEAM (RAIL-TO-BEAM PATH-TO-RENDER.SCHEMATIC)))
      "]"
    ==
  ::
      %SCRY
    (SPUD (EN-BEAM (EXTRACT-BEAM RESOURCE.SCHEMATIC ~)))
  ::
    ::    %SLIM
    ::  "SLIM {<SUBJECT-TYPE.SCHEMATIC>} {<FORMULA.SCHEMATIC>}"
  ::
      %VALE
    ;:  WELP
      "[VALE ["
      (TRIP (SCOT %P SHIP.DISC.SCHEMATIC))
      " "
      (TRIP DESK.DISC.SCHEMATIC)
      "] "
      (TRIP MARK.SCHEMATIC)
      "]"
    ==
  ==
::  +RAIL-TO-BEAM: CONVERT :RAIL TO A +BEAM, FILLING IN THE CASE WITH `[%UD 0]`
::
++  RAIL-TO-BEAM
  |=  =RAIL
  ^-  BEAM
  [[SHIP.DISC.RAIL DESK.DISC.RAIL [%UD 0]] SPUR.RAIL]
::  +RAIL-TO-PATH: PRETTY-PRINTABLE RAIL
::
++  RAIL-TO-PATH
  |=  =RAIL
  ^-  PATH
  (EN-BEAM (RAIL-TO-BEAM RAIL))
::  +UNIFY-JUGS: MAKE A NEW JUG, UNIFYING SETS FOR ALL KEYS
::
::    EXAMPLE:
::    ```
::    DOJO> %+  UNIFY-JUGS
::            (~(GAS BY *(JUG @TAS @UD)) ~[[%A (SY 1 2 ~)] [%B (SY 4 5 ~)]])
::          (~(GAS BY *(JUG @TAS @UD)) ~[[%B (SY 5 6 ~)] [%C (SY 7 8 ~)]])
::
::    {[P=%A Q={1 2 3}] [P=%B Q={4 5 6}] [P=%C Q={7 8}]}
::    ```
::
++  UNIFY-JUGS
  |*  [A=(JUG) B=(JUG)]
  ^+  A
  ::
  =/  TAPPED  ~(TAP BY B)
  ::
  |-  ^+  A
  ?~  TAPPED  A
  ::
  =/  KEY  P.I.TAPPED
  =/  VALS  ~(TAP IN Q.I.TAPPED)
  ::
  =.  A
    |-  ^+  A
    ?~  VALS  A
    ::
    $(VALS T.VALS, A (~(PUT JU A) KEY I.VALS))
  ::
  $(TAPPED T.TAPPED)
::  +PATH-TO-RESOURCE: DECODE A +RESOURCE FROM A +WIRE
::
++  PATH-TO-RESOURCE
  |=  =PATH
  ^-  (UNIT RESOURCE)
  ::
  =/  SCRY-REQUEST=(UNIT SCRY-REQUEST)  (PATH-TO-SCRY-REQUEST PATH)
  ?~  SCRY-REQUEST
    ~
  =+  [VANE CARE BEM]=U.SCRY-REQUEST
  =/  =BEAM  BEM
  =/  =RAIL  [DISC=[P.BEAM Q.BEAM] SPUR=S.BEAM]
  `[VANE CARE RAIL]
::  +SCRY-REQUEST-TO-PATH: ENCODE A +SCRY-REQUEST IN A +WIRE
::
::    EXAMPLE:
::    ```
::    DOJO> %-  SCRY-REQUEST-TO-PATH
::          [%C %X [[~ZOD %HOME [%DA ~2018.1.1]] /HOON/BAR]])
::
::    /CX/~ZOD/HOME/~2018.1.1/BAR/HOON
::    ```
::
++  SCRY-REQUEST-TO-PATH
  |=  =SCRY-REQUEST
  ^-  PATH
  =/  =TERM  (CAT 3 [VANE CARE]:SCRY-REQUEST)
  [TERM (EN-BEAM BEAM.SCRY-REQUEST)]
::  +PATH-TO-SCRY-REQUEST: PARSE :PATH'S COMPONENTS INTO :VANE, :CARE, AND :RAIL
::
++  PATH-TO-SCRY-REQUEST
  |=  =PATH
  ^-  (UNIT SCRY-REQUEST)
  ::
  ?~  PATH
    ~
  ?~  VANE=((SOFT ,%C) (END 3 1 I.PATH))
    ~
  ?~  CARE=((SOFT CARE:CLAY) (RSH 3 1 I.PATH))
    ~
  ?~  BEAM=(DE-BEAM T.PATH)
    ~
  ?.  ?=(%DA -.R.U.BEAM)
    ~
  `[U.VANE U.CARE U.BEAM]
::  +SCRY-REQUEST-TO-BUILD: CONVERT A +SCRY-REQUEST TO A %SCRY BUILD
::
++  SCRY-REQUEST-TO-BUILD
  |=  =SCRY-REQUEST
  ^-  BUILD
  ::  WE ONLY OPERATE ON DATES, NOT OTHER KINDS OF +CASE:CLAY
  ::
  ?>  ?=(%DA -.R.BEAM.SCRY-REQUEST)
  ::
  =,  SCRY-REQUEST
  [P.R.BEAM [%SCRY [VANE CARE `RAIL`[[P Q] S]:BEAM]]]
::  +EXTRACT-BEAM: OBTAIN A +BEAM FROM A +RESOURCE
::
::    FILLS CASE WITH [%UD 0] FOR LIVE RESOURCES IF :DATE IS `~`.
::    FOR ONCE RESOURCES, IGNORE :DATE.
::
++  EXTRACT-BEAM
  |=  [=RESOURCE DATE=(UNIT @DA)]  ^-  BEAM
  ::
  =/  =CASE  ?~(DATE [%UD 0] [%DA U.DATE])
  ::
  =,  RAIL.RESOURCE
  [[SHIP.DISC DESK.DISC CASE] SPUR]
::  +EXTRACT-DISC: OBTAIN A +DISC FROM A +RESOURCE
::
++  EXTRACT-DISC
  |=  =RESOURCE  ^-  DISC
  DISC.RAIL.RESOURCE
::  +GET-SUB-SCHEMATICS: FIND ANY SCHEMATICS CONTAINED WITHIN :SCHEMATIC
::
++  GET-SUB-SCHEMATICS
  |=  =SCHEMATIC
  ^-  (LIST ^SCHEMATIC)
  ?-    -.SCHEMATIC
      ^      ~[HEAD.SCHEMATIC TAIL.SCHEMATIC]
      %$     ~
      %PIN   ~[SCHEMATIC.SCHEMATIC]
      %ALTS  CHOICES.SCHEMATIC
      %BAKE  ~
      %BUNT  ~
      %CALL  ~[GATE.SCHEMATIC SAMPLE.SCHEMATIC]
      %CAST  ~[INPUT.SCHEMATIC]
      %CORE  ~
      %DIFF  ~[START.SCHEMATIC END.SCHEMATIC]
      %DUDE  ~[ATTEMPT.SCHEMATIC]
      %HOOD  ~
      %JOIN  ~[FIRST.SCHEMATIC SECOND.SCHEMATIC]
      %LIST  SCHEMATICS.SCHEMATIC
      %MASH  ~[SCHEMATIC.FIRST.SCHEMATIC SCHEMATIC.SECOND.SCHEMATIC]
      %MUTE  [SUBJECT.SCHEMATIC (TURN MUTATIONS.SCHEMATIC TAIL)]
      %PACT  ~[START.SCHEMATIC DIFF.SCHEMATIC]
      %PATH  ~
      %PLAN  ~
      %REEF  ~
      %RIDE  ~[SUBJECT.SCHEMATIC]
      %SAME  ~[SCHEMATIC.SCHEMATIC]
      %SCRY  ~
      %SLIM  ~
      %SLIT  ~
      %VALE  ~
      %VOLT  ~
      %WALK  ~
  ==
::  +BY-SCHEMATIC: DOOR FOR MANIPULATING :BY-SCHEMATIC.BUILDS.FORD-STATE
::
::    THE :DATES LIST FOR EACH KEY IN :BUILDS IS SORTED IN REVERSE
::    CHRONOLOGICAL ORDER. THESE OPERATIONS ACCESS AND MUTATE KEYS AND VALUES
::    OF :BUILDS AND MAINTAIN THAT SORT ORDER.
::
++  BY-SCHEMATIC
  |_  BUILDS=(MAP SCHEMATIC (LIST @DA))
  ::  +PUT: ADD A +BUILD TO :BUILDS
  ::
  ::    IF :BUILD ALREADY EXISTS IN :BUILDS, THIS IS A NO-OP.
  ::    OTHERWISE, REPLACE THE VALUE AT THE KEY :SCHEMATIC.BUILD
  ::    WITH A NEW :DATES LIST THAT CONTAINS :DATE.BUILD.
  ::
  ++  PUT
    |=  =BUILD
    ^+  BUILDS
    %+  ~(PUT BY BUILDS)  SCHEMATIC.BUILD
    ::
    =/  DATES  (FALL (~(GET BY BUILDS) SCHEMATIC.BUILD) ~)
    |-
    ^+  DATES
    ?~  DATES
      [DATE.BUILD ~]
    ?:  =(I.DATES DATE.BUILD)
      DATES
    ?:  (GTH DATE.BUILD I.DATES)
      [DATE.BUILD DATES]
    [I.DATES $(DATES T.DATES)]
  ::  +DEL: REMOVE A +BUILD FROM :BUILDS
  ::
  ::    REMOVES :BUILD FROM :BUILDS BY REPLACING THE VALUE AT
  ::    THE KEY :SCHEMATIC.BUILD WITH A NEW :DATES LIST WITH
  ::    :DATE.BUILD OMITTED. IF THE RESULTING :DATES LIST IS
  ::    EMPTY, THEN REMOVE THE KEY-VALUE PAIR FROM :BUILDS.
  ::
  ++  DEL
    |=  =BUILD
    ^+  BUILDS
    =.  BUILDS
      %+  ~(JAB BY BUILDS)  SCHEMATIC.BUILD
      |=  DATES=(LIST @DA)
      ~|  BUILD+BUILD
      =/  DATE-INDEX  (NEED (FIND [DATE.BUILD]~ DATES))
      (OUST [DATE-INDEX 1] DATES)
    ::  IF :BUILDS HAS AN EMPTY ENTRY FOR :BUILD, DELETE IT
    ::
    =?    BUILDS
        =(~ (~(GOT BY BUILDS) SCHEMATIC.BUILD))
      (~(DEL BY BUILDS) SCHEMATIC.BUILD)
    ::
    BUILDS
  ::  +FIND-PREVIOUS: FIND THE MOST RECENT OLDER BUILD WITH :SCHEMATIC.BUILD
  ::
  ++  FIND-PREVIOUS
    |=  =BUILD
    ^-  (UNIT ^BUILD)
    ::
    =/  DATES=(LIST @DA)  (FALL (~(GET BY BUILDS) SCHEMATIC.BUILD) ~)
    ::
    |-  ^-  (UNIT ^BUILD)
    ?~  DATES  ~
    ::
    ?:  (LTH I.DATES DATE.BUILD)
      `[I.DATES SCHEMATIC.BUILD]
    $(DATES T.DATES)
  ::  +FIND-NEXT: FIND THE EARLIEST BUILD OF :SCHEMATIC.BUILD LATER THAN :BUILD
  ::
  ++  FIND-NEXT
    |=  =BUILD
    ^-  (UNIT ^BUILD)
    ::
    =/  DATES=(LIST @DA)  (FLOP (FALL (~(GET BY BUILDS) SCHEMATIC.BUILD) ~))
    ::
    |-  ^-  (UNIT ^BUILD)
    ?~  DATES  ~
    ::
    ?:  (GTH I.DATES DATE.BUILD)
      `[I.DATES SCHEMATIC.BUILD]
    $(DATES T.DATES)
  --
::  +GET-REQUEST-DUCTS: ALL DUCTS WAITING ON THIS REQUEST
::
++  GET-REQUEST-DUCTS
  |*  [TRACKER=(REQUEST-TRACKER) REQUEST=*]
  ^-  (LIST DUCT)
  ::
  ~(TAP IN WAITING:(~(GOT BY TRACKER) REQUEST))
::  +PUT-REQUEST: ASSOCIATES A +DUCT WITH A REQUEST
::
++  PUT-REQUEST
  |*  [TRACKER=(REQUEST-TRACKER) REQUEST=* =DUCT]
  ::
  %+  ~(PUT BY TRACKER)  REQUEST
  ?~  EXISTING=(~(GET BY TRACKER) REQUEST)
    [(SY DUCT ~) DUCT]
  U.EXISTING(WAITING (~(PUT IN WAITING.U.EXISTING) DUCT))
::  +DEL-REQUEST: REMOVE A DUCT AND PRODUCE THE ORIGINATING DUCT IF EMPTY
::
++  DEL-REQUEST
  |*  [TRACKER=(REQUEST-TRACKER) REQUEST=* =DUCT]
  ^-  [(UNIT ^DUCT) _TRACKER]
  ::  REMOVE :DUCT FROM THE EXISTING :RECORD OF THIS :REQUEST
  ::
  =/  RECORD  (~(GOT BY TRACKER) REQUEST)
  =.  WAITING.RECORD  (~(DEL IN WAITING.RECORD) DUCT)
  ::  IF NO MORE DUCTS WAIT ON :REQUEST, DELETE IT
  ::
  ?^  WAITING.RECORD
    [~ (~(PUT BY TRACKER) REQUEST RECORD)]
  [`ORIGINATOR.RECORD (~(DEL BY TRACKER) REQUEST)]
::  +PARSE-SCAFFOLD: PRODUCES A PARSER FOR A HOON FILE WITH +CRANE INSTANCES
::
::    FORD PARSES A SUPERSET OF HOON WHICH CONTAINS ADDITIONAL RUNES TO
::    REPRESENT +CRANE S. THIS PARSES TO A +SCAFFOLD.
::
::    SRC-BEAM: +BEAM OF THE SOURCE FILE WE'RE PARSING
::
++  PARSE-SCAFFOLD
  |=  SRC-BEAM=BEAM
  ::
  =/  HOON-PARSER  (VANG & (EN-BEAM SRC-BEAM))
  |^  ::
      %+  COOK
        |=  A=[@UD (LIST ^CABLE) (LIST ^CABLE) (LIST ^CRANE) (LIST HOON)]
        ^-  SCAFFOLD
        [[[P Q] S]:SRC-BEAM A]
      ::
      %+  IFIX  [GAY GAY]
      ;~  PLUG
      ::  PARSES THE ZUSE VERSION, EG "/?  309"
      ::
        ;~  POSE
          (IFIX [;~(PLUG NET WUT GAP) GAP] DEM)
          (EASY ZUSE)
        ==
      ::  PARESES THE STRUCTURES, EG "/-  TYPES"
      ::
        ;~  POSE
          (IFIX [;~(PLUG NET HEP GAP) GAP] (MOST ;~(PLUG COM GAW) CABLE))
          (EASY ~)
        ==
      ::  PARSES THE LIBRARIES, EG "/+  LIB1, LIB2"
      ::
        ;~  POSE
          (IFIX [;~(PLUG NET LUS GAP) GAP] (MOST ;~(PLUG COM GAW) CABLE))
          (EASY ~)
        ==
      ::
        (STAR ;~(SFIX CRANE GAP))
      ::
        (MOST GAP TALL:HOON-PARSER)
      ==
  ::  +BEAM: PARSES A HOOD PATH AND CONVERTS IT TO A BEAM
  ::
  ++  BEAM
    %+  SEAR  DE-BEAM
    ;~  PFIX
      NET
      (SEAR PLEX (STAG %CLSG POOR)):HOON-PARSER
    ==
  ::  +CABLE: PARSES A +^CABLE, A REFERENCE TO SOMETHING ON THE FILESYSTEM
  ::
  ::    THIS PARSES:
  ::
  ::      `LIBRARY`       ->  WRAPS `LIBRARY` AROUND THE LIBRARY `LIBRARY`
  ::      `FACE=LIBRARY`  ->  WRAPS `FACE` AROUND THE LIBRARY `LIBRARY`
  ::      `*LIBRARY`      ->  EXPOSES `LIBRARY` DIRECTLY TO THE SUBJECT
  ::
  ++  CABLE
    %+  COOK  |=(A=^CABLE A)
    ;~  POSE
      (STAG ~ ;~(PFIX TAR SYM))
      (COOK |=([FACE=TERM TIS=@ FILE=TERM] [`FACE FILE]) ;~(PLUG SYM TIS SYM))
      (COOK |=(A=TERM [`A A]) SYM)
    ==
  ::  +CRANE: ALL RUNES THAT START WITH / WHICH AREN'T /?, /-, /+ OR //.
  ::
  ++  CRANE
    =<  APEX
    ::  WHETHER WE ALLOW TALL FORM
    =|  ALLOW-TALL-FORM=?
    ::
    |%
    ++  APEX
      %+  KNEE  *^CRANE  |.  ~+
      ;~  PFIX  NET
        ;~  POSE
          ::  `/~`  HOON LITERAL
          ::
          (STAG %FSSG ;~(PFIX SIG HOON))
          ::  `/$`  PROCESS QUERY STRING
          ::
          (STAG %FSBC ;~(PFIX BUS HOON))
          ::  `/|`  FIRST OF MANY OPTIONS THAT SUCCEEDS
          ::
          (STAG %FSBR ;~(PFIX BAR PARSE-ALTS))
          ::  `/=`  WRAP A FACE AROUND A CRANE
          ::
          (STAG %FSTS ;~(PFIX TIS PARSE-FACE))
          ::  `/.`  NULL TERMINATED LIST
          ::
          (STAG %FSDT ;~(PFIX DOT PARSE-LIST))
          ::  `/,`  SWITCH BY PATH
          ::
          (STAG %FSCM ;~(PFIX COM PARSE-SWITCH))
          ::  `/&`  PASS THROUGH A SERIES OF MARK
          ::
          (STAG %FSPM ;~(PFIX PAD PARSE-PIPE))
          ::  `/_`  RUN A CRANE ON EACH FILE IN THE CURRENT DIRECTORY
          ::
          (STAG %FSCB ;~(PFIX CAB SUBCRANE))
          ::  `/;`  PASSES DATE THROUGH A GATE
          ::
          (STAG %FSSM ;~(PFIX MIC PARSE-GATE))
          ::  `/:`  EVALUATE AT PATH
          ::
          (STAG %FSCL ;~(PFIX COL PARSE-AT-PATH))
          ::  `/^`  CAST
          ::
          (STAG %FSKT ;~(PFIX KET PARSE-CAST))
          ::  `/*`  RUN A CRANE ON EACH FILE WITH CURRENT PATH AS PREFIX
          ::
          (STAG %FSTR ;~(PFIX TAR SUBCRANE))
          ::  `/!MARK/ EVALUATE AS HOON, THEN PASS THROUGH MARK
          ::
          (STAG %FSZP ;~(PFIX ZAP ;~(SFIX SYM NET)))
          ::  `/MARK/` PASSES CURRENT PATH THROUGH :MARK
          ::
          (STAG %FSZY ;~(SFIX SYM NET))
        ==
      ==
    ::  +PARSE-ALTS: PARSE A SET OF ALTERNATIVES
    ::
    ++  PARSE-ALTS
      %+  WIDE-OR-TALL
        (IFIX [LIT RIT] (MOST ACE SUBCRANE))
      ;~(SFIX (STAR SUBCRANE) GAP DUZ)
    ::  +PARSE-FACE: PARSE A FACE AROUND A SUBCRANE
    ::
    ++  PARSE-FACE
      %+  WIDE-OR-TALL
        ;~(PLUG SYM ;~(PFIX TIS SUBCRANE))
      ;~(PFIX GAP ;~(PLUG SYM SUBCRANE))
    ::  +PARSE-LIST: PARSE A NULL TERMINATED LIST OF CRANES
    ::
    ++  PARSE-LIST
      %+  WIDE-OR-TALL
        FAIL
      ;~(SFIX (STAR SUBCRANE) GAP DUZ)
    ::  +PARSE-SWITCH: PARSES A LIST OF [PATH CRANE]
    ::
    ++  PARSE-SWITCH
      %+  WIDE-OR-TALL
        FAIL
      =-  ;~(SFIX (STAR -) GAP DUZ)
      ;~(PFIX GAP NET ;~(PLUG STATIC-PATH SUBCRANE))
    ::  +PARSE-PIPE: PARSES A PIPE OF MARK CONVERSIONS
    ::
    ++  PARSE-PIPE
      %+  WIDE-OR-TALL
        ;~(PLUG (PLUS ;~(SFIX SYM PAD)) SUBCRANE)
      =+  (COOK |=(A=TERM [A ~]) SYM)
      ;~(PFIX GAP ;~(PLUG - SUBCRANE))
    ::  +PARSE-GATE: PARSES A GATE APPLIED TO A CRANE
    ::
    ++  PARSE-GATE
      %+  WIDE-OR-TALL
        ;~(PLUG ;~(SFIX WIDE:HOON-PARSER MIC) SUBCRANE)
      ;~(PFIX GAP ;~(PLUG TALL:HOON-PARSER SUBCRANE))
    ::  +PARSE-AT-PATH: PARSES A LATE BOUND BATH
    ::
    ++  PARSE-AT-PATH
      %+  WIDE-OR-TALL
        ;~(PLUG ;~(SFIX LATE-BOUND-PATH COL) SUBCRANE)
      ;~(PFIX GAP ;~(PLUG LATE-BOUND-PATH SUBCRANE))
    ::  +PARSE-CAST: PARSES A MOLD AND THEN THE SUBCRANE TO APPLY THAT MOLD TO
    ::
    ++  PARSE-CAST
      %+  WIDE-OR-TALL
        ;~(PLUG ;~(SFIX WYDE:HOON-PARSER KET) SUBCRANE)
      ;~(PFIX GAP ;~(PLUG TILL:HOON-PARSER SUBCRANE))
    ::  +SUBCRANE: PARSES A SUBCRANE
    ::
    ++  SUBCRANE
      %+  WIDE-OR-TALL
        APEX(ALLOW-TALL-FORM |)
      ;~(PFIX GAP APEX)
    ::  +WIDE-OR-TALL: PARSES TALL FORM HOON IF :ALLOW-TALL-FORM IS %.Y
    ::
    ++  WIDE-OR-TALL
      |*  [WIDE=RULE TALL=RULE]
      ?.  ALLOW-TALL-FORM  WIDE
      ;~(POSE WIDE TALL)
    ::  +HOON: PARSES HOON AS AN ARGUMENT TO A CRANE
    ::
    ++  HOON
      %+  WIDE-OR-TALL
        (IFIX [LAC RAC] (STAG %CLTR (MOST ACE WIDE:HOON-PARSER)))
      ;~(PFIX GAP TALL:HOON-PARSER)
    --
  ::  +STATIC-PATH: PARSES A PATH
  ::
  ++  STATIC-PATH
    (SEAR PLEX (STAG %CLSG (MORE NET HASP))):HOON-PARSER
  ::  +LATE-BOUND-PATH: A PATH WHOSE TIME VARIES
  ::
  ++  LATE-BOUND-PATH
    ;~  PFIX  NET
      %+  COOK  |=(A=TRUSS A)
      =>  HOON-PARSER
      ;~  PLUG
        (STAG ~ GASH)
        ;~(POSE (STAG ~ ;~(PFIX CEN PORC)) (EASY ~))
      ==
    ==
  --
::  +PER-EVENT: PER-EVENT CORE; MAIN BUILD ENGINE
::
::    THIS ARM PRODUCES A GATE THAT WHEN CALLED WITH STATE AND EVENT
::    INFORMATION PRODUCES THE CORE OF FORD'S MAIN BUILD ENGINE.
::
::    THE MAIN BUILD ENGINE CORE HAS THE FOLLOWING ENTRY POINTS:
::
::      +START-BUILD  START PERFORMING A BUILD
::      +REBUILD      RERUN A LIVE BUILD AT A NEW DATE
::      +UNBLOCK      CONTINUE A BUILD THAT WAS WAITING ON A RESOURCE
::      +CANCEL       STOP TRYING TO RUN A BUILD AND DELETE ITS TRACKING INFO
::      +WIPE         WIPE THE BUILD STORAGE TO FREE MEMORY
::      +KEEP         RESIZE CACHES, DELETING ENTRIES IF NECESSARY
::
::    THE MAIN INTERNAL ARM IS +EXECUTE-LOOP, WHICH IS CALLED FROM +START-BUILD,
::    +REBUILD, AND +UNBLOCK. +EXECUTE DEFINES FORD'S BUILD LOOP.
::
++  PER-EVENT
  ::  MOVES: THE MOVES TO BE SENT OUT AT THE END OF THIS EVENT, REVERSED
  ::
  =|  MOVES=(LIST MOVE)
  ::  SCRY-RESULTS: RESPONSES TO SCRY'S TO HANDLE IN THIS EVENT
  ::
  ::    IF A VALUE IS `~`, THE REQUESTED RESOURCE IS NOT AVAILABLE.
  ::    OTHERWISE, THE VALUE WILL CONTAIN A +CAGE.
  ::
  =|  SCRY-RESULTS=(MAP SCRY-REQUEST (UNIT CAGE))
  ::  NEXT-BUILDS: BUILDS TO PERFORM IN THE NEXT ITERATION
  ::
  =|  NEXT-BUILDS=(SET BUILD)
  ::  CANDIDATE-BUILDS: BUILDS WHICH MIGHT GO INTO NEXT-BUILDS
  ::
  =|  CANDIDATE-BUILDS=(SET BUILD)
  ::  GATE THAT PRODUCES THE +PER-EVENT CORE FROM EVENT INFORMATION
  ::
  ::    PRODUCES A CORE CONTAINING FORD'S MAIN BUILD ENGINE.
  ::
  ~%  %F  ..IS  ~
  |=  [[OUR=@P =DUCT NOW=@DA SCRY=SLEY] STATE=FORD-STATE]
  ::
  ~%  %PER-EVENT  +  ~
  |%
  ::  +FINALIZE: EXTRACT MOVES AND STATE FROM THE +PER-EVENT CORE
  ::
  ::    RUN ONCE AT THE END OF PROCESSING AN EVENT.
  ::
  ++  FINALIZE
    ^-  [(LIST MOVE) FORD-STATE]
    [(FLOP MOVES) STATE]
  ::  |ENTRY-POINTS: EXTERNALLY FIRED ARMS
  ::
  ::+|  ENTRY-POINTS
  ::
  ::  +START-BUILD: PERFORM A FRESH +BUILD, EITHER LIVE OR ONCE
  ::
  ::    THIS MIGHT COMPLETE THE BUILD, OR THE BUILD MIGHT BLOCK ON ONE OR MORE
  ::    REQUESTS FOR RESOURCES. CALLS +EXECUTE-LOOP.
  ::
  ++  START-BUILD
    ~/  %START-BUILD
    |=  [=BUILD LIVE=?]
    ^-  [(LIST MOVE) FORD-STATE]
    ::
    =<  FINALIZE
    ::  ASSOCIATE :DUCT WITH :BUILD IN :DUCTS.STATE
    ::
    =.  DUCTS.STATE
      %+  ~(PUT BY DUCTS.STATE)  DUCT
      :_  SCHEMATIC.BUILD
      ?:  LIVE
        [%LIVE IN-PROGRESS=`DATE.BUILD LAST-SENT=~]
      [%ONCE IN-PROGRESS=DATE.BUILD]
    ::  REGISTER A STATE MACHINE FOR :BUILD IN :BUILDS.STATE
    ::
    =.  STATE  (ADD-BUILD BUILD)
    ::  :ANCHOR: THE REASON WE HOLD ONTO THE ROOT OF THIS BUILD TREE
    ::
    =/  =ANCHOR  [%DUCT DUCT]
    ::  REGISTER :DUCT AS AN ANCHOR IN :REQUESTERS.BUILD-STATUS
    ::
    ::    THIS ESTABLISHES :BUILD AS THE ROOT BUILD FOR :DUCT.
    ::
    =.  BUILDS.STATE
      %+  ~(JAB BY BUILDS.STATE)  BUILD
      |=  =BUILD-STATUS
      BUILD-STATUS(REQUESTERS (~(PUT IN REQUESTERS.BUILD-STATUS) ANCHOR))
    ::  COPY :ANCHOR INTO ANY PREEXISTING DESCENDANTS
    ::
    ::    SUB-BUILDS WILL REFERENCE :BUILD IN THEIR :CLIENTS.BUILD-STATUS,
    ::    USING `[%DUCT DUCT]` AS THE KEY. SOME SUB-BUILDS MIGHT ALREADY
    ::    EXIST IF WE'VE ALREADY STARTED RUNNING :BUILD, SO MAKE SURE THEY
    ::    KNOW WHO THEIR DADDY IS.
    ::
    =.  BUILDS.STATE  (ADD-ANCHOR-TO-SUBS ANCHOR BUILD)
    ::  RUN +EXECUTE ON :BUILD IN A LOOP UNTIL IT COMPLETES OR BLOCKS
    ::
    (EXECUTE-LOOP (SY [BUILD ~]))
  ::  +REBUILD: REBUILD A LIVE BUILD BASED ON +RESOURCE UPDATES
  ::
  ::    FOR EVERY CHANGED RESOURCE, RUN THE %SCRY BUILD FOR THAT
  ::    FOR THAT RESOURCE. THEN REBUILD UPWARD USING THE MAIN +EXECUTE-LOOP
  ::    UNTIL ALL RELEVANT BUILDS EITHER COMPLETE OR BLOCK ON EXTERNAL
  ::    RESOURCES. USE DEPENDENCY TRACKING INFORMATION FROM THE PREVIOUS
  ::    RUN OF THIS LIVE BUILD TO INFORM THE DEPENDENCY TRACKING FOR THIS
  ::    NEW REBUILD.
  ::
  ++  REBUILD
    ~/  %REBUILD
    |=  $:  =SUBSCRIPTION
            NEW-DATE=@DA
            =DISC
            CARE-PATHS=(SET [CARE=CARE:CLAY =PATH])
        ==
    ^-  [(LIST MOVE) FORD-STATE]
    ::
    ~|  [%REBUILDING NEW-DATE DISC]
    ::
    =<  FINALIZE
    ::  MARK THIS SUBSCRIPTION AS COMPLETE NOW THAT WE'VE HEARD A RESPONSE
    ::
    =.  PENDING-SUBSCRIPTIONS.STATE
      +:(DEL-REQUEST PENDING-SUBSCRIPTIONS.STATE SUBSCRIPTION DUCT)
    ::  FOR EVERY CHANGED RESOURCE, CREATE A %SCRY BUILD
    ::
    =/  BUILDS=(LIST BUILD)
      %+  TURN  ~(TAP IN CARE-PATHS)
      |=  [CARE=CARE:CLAY =PATH]
      ^-  BUILD
      ::
      [NEW-DATE [%SCRY [%C CARE RAIL=[DISC SPUR=(FLOP PATH)]]]]
    ::  SANITY CHECK; ONLY REBUILD LIVE BUILDS, NOT ONCE BUILDS
    ::
    =/  DUCT-STATUS  (~(GOT BY DUCTS.STATE) DUCT)
    ?>  ?=(%LIVE -.LIVE.DUCT-STATUS)
    ::  SANITY CHECK; ONLY REBUILD ONCE WE'VE COMPLETED THE PREVIOUS ONE
    ::
    ?>  ?=(~ IN-PROGRESS.LIVE.DUCT-STATUS)
    ?>  ?=(^ LAST-SENT.LIVE.DUCT-STATUS)
    ::  SET THE IN-PROGRESS DATE FOR THIS NEW BUILD
    ::
    =.  DUCTS.STATE
      %+  ~(PUT BY DUCTS.STATE)  DUCT
      DUCT-STATUS(IN-PROGRESS.LIVE `NEW-DATE)
    ::  COPY THE PREVIOUS BUILD'S TREE AS PROVISIONAL SUB-BUILDS
    ::
    ::    THIS PROVIDES AN UPWARD REBUILD PATH FROM LEAVES TO ROOT,
    ::    SO THAT ONCE THE %SCRY BUILDS COMPLETE, WE'LL KNOW TO REBUILD
    ::    THEIR CLIENTS. THIS PROCESS WILL CONTINUE UP THROUGH REBUILDING
    ::    THE ROOT BUILD.
    ::
    ::    IF THE BUILD AT THIS NEW DATE ENDS UP WITH A DIFFERENT SET OF
    ::    DEPENDENCIES FROM ITS PREVIOUS INCARNATION, PROVISIONAL SUB-BUILDS
    ::    THAT WEREN'T ACTUALLY USED WILL BE REMOVED IN
    ::    +CLEANUP-ORPHANED-PROVISIONAL-BUILDS.
    ::
    =/  OLD-ROOT=BUILD
      [DATE.U.LAST-SENT.LIVE.DUCT-STATUS ROOT-SCHEMATIC.DUCT-STATUS]
    ::
    =.  STATE
      ::
      ~|  [%DUCT-DOESNT-REFER-TO-REAL-BUILD LIVE.DUCT-STATUS]
      ~|  [%MISSING-BUILD (BUILD-TO-TAPE OLD-ROOT)]
      ~|  [%DATES (~(GET BY BUILDS-BY-SCHEMATIC.STATE) ROOT-SCHEMATIC.DUCT-STATUS)]
      ?>  (~(HAS BY BUILDS.STATE) OLD-ROOT)
      ::
      (COPY-BUILD-TREE-AS-PROVISIONAL OLD-ROOT NEW-DATE=NEW-DATE)
    ::  GATHER ALL THE :BUILDS, FORCING RERUNS
    ::
    ::    THE NORMAL +GATHER LOGIC WOULD PROMOTE THE PREVIOUS RESULTS
    ::    FOR THESE %SCRY BUILDS, SINCE WE HAVE SUBSCRIPTIONS ON THEM.
    ::    WE PASS `FORCE=%.Y` TO ENSURE THE BUILDS GET ENQUEUED INSTEAD
    ::    OF PROMOTED.
    ::
    =.  ..EXECUTE  (GATHER (SY BUILDS) FORCE=%.Y)
    ::  REBUILD RESOURCE BUILDS AT THE NEW DATE
    ::
    ::    THIS KICKS OFF THE MAIN BUILD LOOP, WHICH WILL FIRST BUILD
    ::    :BUILDS, THEN REBUILD UPWARD TOWARD THE ROOT. IF THE WHOLE
    ::    BUILD TREE COMPLETES SYNCHRONOUSLY, THEN THIS WILL PRODUCE
    ::    %MADE MOVES AT THE END OF THIS EVENT. OTHERWISE, IT WILL
    ::    BLOCK ON RESOURCES AND COMPLETE DURING A LATER EVENT.
    ::
    (EXECUTE-LOOP ~)
  ::  +UNBLOCK: CONTINUE BUILDS THAT HAD BLOCKED ON :RESOURCE
  ::
  ::    A BUILD CAN BE STYMIED TEMPORARILY IF IT DEPENDS ON A RESOURCE
  ::    THAT MUST BE FETCHED ASYNCHRONOUSLY. +UNBLOCK IS CALLED WHEN
  ::    WE RECEIVE A RESPONSE TO A RESOURCE REQUEST THAT BLOCKED A BUILD.
  ::
  ::    WE PICK UP THE BUILD FROM WHERE WE LEFT OFF, STARTING WITH THE
  ::    %SCRY BUILD THAT BLOCKED ON THIS RESOURCE LAST TIME WE TRIED IT.
  ::
  ++  UNBLOCK
    ~/  %UNBLOCK
    |=  [=SCRY-REQUEST SCRY-RESULT=(UNIT CAGE)]
    ^-  [(LIST MOVE) FORD-STATE]
    ::
    =<  FINALIZE
    ::  PLACE :SCRY-RESULT IN :SCRY-RESULTS.PER-EVENT
    ::
    ::    WE DON'T WANT TO CALL THE ACTUAL +SCRY FUNCTION AGAIN,
    ::    BECAUSE WE ALREADY TRIED THAT IN A PREVIOUS EVENT AND IT
    ::    HAD NO SYNCHRONOUS ANSWER. THIS +UNBLOCK CALL IS A RESULT
    ::    OF THE RESPONSE TO THE ASYNCHRONOUS REQUEST WE MADE TO
    ::    RETRIEVE THAT RESOURCE FROM ANOTHER VANE.
    ::
    ::    INSTEAD, WE'LL INTERCEPT ANY CALLS TO +SCRY BY LOOKING UP
    ::    THE ARGUMENTS IN :SCRY-RESULTS.PER-EVENT. THIS IS OK BECAUSE
    ::    IN THIS FUNCTION WE ATTEMPT TO RUN EVERY +BUILD THAT HAD
    ::    BLOCKED ON THE RESOURCE, SO THE INFORMATION IS GUARANTEED
    ::    TO BE USED DURING THIS EVENT BEFORE IT GOES OUT OF SCOPE.
    ::
    =.  SCRY-RESULTS  (~(PUT BY SCRY-RESULTS) SCRY-REQUEST SCRY-RESULT)
    ::  MARK THIS +SCRY-REQUEST AS COMPLETE NOW THAT WE HAVE A RESPONSE
    ::
    =.  PENDING-SCRYS.STATE
      +:(DEL-REQUEST PENDING-SCRYS.STATE SCRY-REQUEST DUCT)
    ::  UPDATE :UNBLOCKED-BUILD'S STATE MACHINE TO REFLECT ITS NEW STATUS
    ::
    =/  UNBLOCKED-BUILD=BUILD  (SCRY-REQUEST-TO-BUILD SCRY-REQUEST)
    =.  BUILDS.STATE
      %+  ~(JAB BY BUILDS.STATE)  UNBLOCKED-BUILD
      |=  =BUILD-STATUS
      BUILD-STATUS(STATE [%UNBLOCKED ~])
    ::  JUMP INTO THE MAIN BUILD LOOP, STARTING WITH :UNBLOCKED-BUILD
    ::
    (EXECUTE-LOOP (SY UNBLOCKED-BUILD ~))
  ::  +WIPE: FORCIBLY DECIMATE BUILD RESULTS FROM THE STATE
  ::
  ::    +WIPE DECIMATES BOTH THE :COMPILER-CACHE AND THE RESULTS IN
  ::    :BUILDS.STATE. IT REMOVES THE SPECIFIED PERCENTAGE OF BUILD RESULTS
  ::    FROM THE STATE. FOR SIMPLICITY, IT CONSIDERS THE WEIGHT OF EACH
  ::    COMPILER CACHE LINE TO BE EQUAL TO THE WEIGHT OF A BUILD RESULT.
  ::
  ::    IT DELETES CACHE ENTRIES BEFORE DIPPING INTO :BUILDS.STATE; IT ONLY
  ::    CONVERTS ENTRIES IN :BUILDS.STATE TO %TOMBSTONE'S IF THERE AREN'T
  ::    ENOUGH ENTRIES IN THE COMPILER CACHE TO SATE THE REQUEST'S BLOODLUST.
  ::
  ::    WHEN DELETING RESULTS FROM :BUILDS.STATE, IT FIRST SORTS THEM BY
  ::    THEIR :LAST-ACCESSED DATE SO THAT THE STALEST BUILDS ARE DELETED FIRST.
  ::    WE DO NOT TOUCH THE :BUILD-CACHE DIRECTLY, BUT BECAUSE THE RESULTS
  ::    OF THE BUILDS IN :BUILD-CACHE LIVE IN :BUILDS.STATE, THE RESULTS OF
  ::    BOTH FIFO-CACHED BUILDS AND ACTIVE BUILDS ARE ALL SORTED AND TRIMMED.
  ::
  ++  WIPE
    ~/  %WIPE
    |=  PERCENT-TO-REMOVE=@UD
    ^+  STATE
    ::  REMOVING 0% IS THE SAME AS DOING NOTHING, SO DO NOTHING
    ::
    ?:  =(0 PERCENT-TO-REMOVE)
      ~&  %WIPE-NO-OP
      STATE
    ::
    ~|  [%WIPE PERCENT-TO-REMOVE=PERCENT-TO-REMOVE]
    ?>  (LTE PERCENT-TO-REMOVE 100)
    ::  FIND ALL COMPLETED BUILDS, SORTED BY :LAST-ACCESSED DATE
    ::
    =/  COMPLETED-BUILDS=(LIST BUILD)
      =-  (TURN - HEAD)
      %+  SORT
        ::  FILTER FOR BUILDS WITH A STORED +BUILD-RESULT
        ::
        %+  SKIM  ~(TAP BY BUILDS.STATE)
        |=  [=BUILD =BUILD-STATUS]
        ^-  ?
        ::
        ?=([%COMPLETE %VALUE *] STATE.BUILD-STATUS)
      ::  SORT BY :LAST-ACCESSED DATE
      ::
      |=  [[* A=BUILD-STATUS] [* B=BUILD-STATUS]]
      ^-  ?
      ::
      ?>  ?=([%COMPLETE %VALUE *] STATE.A)
      ?>  ?=([%COMPLETE %VALUE *] STATE.B)
      ::
      %+  LTE
        LAST-ACCESSED.BUILD-RECORD.STATE.A
      LAST-ACCESSED.BUILD-RECORD.STATE.B
    ::  DETERMINE HOW MANY BUILDS SHOULD REMAIN AFTER DECIMATION
    ::
    ::    THIS FORMULA HAS THE PROPERTY THAT REPEATED APPLICATIONS
    ::    OF +WIPE WITH ANYTHING OTHER THAN 100% RETENTION RATE WILL
    ::    ALWAYS EVENTUALLY REMOVE EVERY BUILD.
    ::
    =/  NUM-COMPLETED-BUILDS=@UD
      (ADD (LENT COMPLETED-BUILDS) SIZE.COMPILER-CACHE.STATE)
    =/  PERCENT-TO-KEEP=@UD  (SUB 100 PERCENT-TO-REMOVE)
    =/  NUM-TO-KEEP=@UD  (DIV (MUL PERCENT-TO-KEEP NUM-COMPLETED-BUILDS) 100)
    =/  NUM-TO-REMOVE=@UD  (SUB NUM-COMPLETED-BUILDS NUM-TO-KEEP)
    ::
    |^  ^+  STATE
        ::
        =+  CACHE-SIZE=SIZE.COMPILER-CACHE.STATE
        ?:  (LTE NUM-TO-REMOVE CACHE-SIZE)
          (REMOVE-FROM-CACHE NUM-TO-REMOVE)
        =.  COMPILER-CACHE.STATE
          %~  PURGE
            (BY-CLOCK COMPILER-CACHE-KEY BUILD-RESULT)
          COMPILER-CACHE.STATE
        (TOMBSTONE-BUILDS (SUB NUM-TO-REMOVE CACHE-SIZE))
    ::
    ++  REMOVE-FROM-CACHE
      |=  COUNT=@UD
      %_    STATE
          COMPILER-CACHE
        %-  %~  TRIM
                (BY-CLOCK COMPILER-CACHE-KEY BUILD-RESULT)
                COMPILER-CACHE.STATE
        COUNT
      ==
    ::
    ++  TOMBSTONE-BUILDS
      |=  NUM-TO-REMOVE=@UD
      ::
      ~|  [%WIPE NUM-TO-REMOVE=NUM-TO-REMOVE]
      ::  THE OLDEST :NUM-TO-REMOVE BUILDS ARE CONSIDERED STALE
      ::
      =/  STALE-BUILDS  (SCAG NUM-TO-REMOVE COMPLETED-BUILDS)
      ::  ITERATE OVER :STALE-BUILDS, REPLACING WITH %TOMBSTONE'S
      ::
      |-  ^+  STATE
      ?~  STALE-BUILDS  STATE
      ::  REPLACE THE BUILD'S ENTRY IN :BUILDS.STATE WITH A %TOMBSTONE
      ::
      =.  BUILDS.STATE
        =<  BUILDS
        %+  UPDATE-BUILD-STATUS  I.STALE-BUILDS
        |=  =BUILD-STATUS
        BUILD-STATUS(STATE [%COMPLETE %TOMBSTONE ~])
      ::
      $(STALE-BUILDS T.STALE-BUILDS)
    --
  ::  +KEEP: RESIZE CACHES
  ::
  ::    FORD MAINTAINS TWO CACHES: A :BUILD-CACHE FOR CACHING PREVIOUSLY
  ::    COMPLETED BUILD TREES, AND A :COMPILER-CACHE FOR CACHING VARIOUS
  ::    COMPILER OPERATIONS THAT TEND TO BE SHARED AMONG MULTIPLE BUILDS.
  ::
  ::    TO HANDLE THIS COMMAND, WE RESET THE MAXIMUM SIZES OF BOTH OF
  ::    THESE CACHES, REMOVING ENTRIES FROM THE CACHES IF NECESSARY.
  ::
  ++  KEEP
    ~/  %KEEP
    |=  [COMPILER-CACHE-SIZE=@UD BUILD-CACHE-SIZE=@UD]
    ^+  STATE
    ::  POP OLD BUILDS OUT OF :BUILD-CACHE AND REMOVE THEIR CACHE ANCHORS
    ::
    =^  POPS  QUEUE.BUILD-CACHE.STATE
      %.  BUILD-CACHE-SIZE
      ~(RESIZE (TO-CAPPED-QUEUE BUILD-CACHE-KEY) QUEUE.BUILD-CACHE.STATE)
    ::
    =.  STATE
      |-  ^+  STATE
      ?~  POPS  STATE
      ::
      =.  STATE  (REMOVE-ANCHOR-FROM-ROOT ROOT-BUILD.I.POPS [%CACHE ID.I.POPS])
      ::
      $(POPS T.POPS)
    ::  RESIZE THE :COMPILER-CACHE
    ::
    %_    STATE
        COMPILER-CACHE
      %-  %~  RESIZE
              (BY-CLOCK COMPILER-CACHE-KEY BUILD-RESULT)
              COMPILER-CACHE.STATE
      COMPILER-CACHE-SIZE
    ==
  ::  +CANCEL: CANCEL A BUILD
  ::
  ::    WHEN CALLED ON A LIVE BUILD, REMOVES ALL TRACKING RELATED TO THE LIVE
  ::    BUILD, AND NO MORE %MADE MOVES WILL BE SENT FOR THAT BUILD.
  ::
  ::    WHEN CALLED ON A ONCE BUILD, REMOVES ALL TRACKING RELATED TO THE ONCE
  ::    BUILD, AND THAT BUILD WILL NEVER BE COMPLETED OR HAVE A %MADE SENT.
  ::
  ::    WHEN CALLED ON A BUILD THAT ISN'T REGISTERED IN :STATE, SUCH AS A
  ::    COMPLETED ONCE BUILD, OR A BUILD THAT HAS ALREADY BEEN CANCELED,
  ::    PRINTS AND NO-OPS.
  ::
  ++  CANCEL  ^+  [MOVES STATE]
    ::
    =<  FINALIZE
    ::
    ?~  DUCT-STATUS=(~(GET BY DUCTS.STATE) DUCT)
      ~&  [%NO-BUILD-FOR-DUCT DUCT]
      ..EXECUTE
    ::  :DUCT IS BEING CANCELED, SO REMOVE IT UNCONDITIONALLY
    ::
    =.  DUCTS.STATE  (~(DEL BY DUCTS.STATE) DUCT)
    ::  IF THE DUCT WAS NOT LIVE, CANCEL ANY IN-PROGRESS BUILDS
    ::
    ?:  ?=(%ONCE -.LIVE.U.DUCT-STATUS)
      ::
      =/  ROOT-BUILD=BUILD  [IN-PROGRESS.LIVE ROOT-SCHEMATIC]:U.DUCT-STATUS
      ::
      =.  ..EXECUTE  (CANCEL-SCRYS ROOT-BUILD)
      =.  STATE  (REMOVE-ANCHOR-FROM-ROOT ROOT-BUILD [%DUCT DUCT])
      ..EXECUTE
    ::  IF THE DUCT WAS LIVE AND HAS AN UNFINISHED BUILD, CANCEL IT
    ::
    =?  ..EXECUTE  ?=(^ IN-PROGRESS.LIVE.U.DUCT-STATUS)
      ::
      =/  ROOT-BUILD=BUILD  [U.IN-PROGRESS.LIVE ROOT-SCHEMATIC]:U.DUCT-STATUS
      ::
      =.  ..EXECUTE  (CANCEL-SCRYS ROOT-BUILD)
      =.  STATE  (REMOVE-ANCHOR-FROM-ROOT ROOT-BUILD [%DUCT DUCT])
      ..EXECUTE
    ::  IF THERE IS NO COMPLETED BUILD FOR THE LIVE DUCT, WE'RE DONE
    ::
    ?~  LAST-SENT=LAST-SENT.LIVE.U.DUCT-STATUS
      ..EXECUTE
    ::  THERE IS A COMPLETED BUILD FOR THE LIVE DUCT, SO DELETE IT
    ::
    =/  ROOT-BUILD=BUILD  [DATE.U.LAST-SENT ROOT-SCHEMATIC.U.DUCT-STATUS]
    ::
    =.  STATE  (REMOVE-ANCHOR-FROM-ROOT ROOT-BUILD [%DUCT DUCT])
    ::
    ?~  SUBSCRIPTION.U.LAST-SENT
      ..EXECUTE
    (CANCEL-CLAY-SUBSCRIPTION U.SUBSCRIPTION.U.LAST-SENT)
  ::  +CANCEL-SCRYS: CANCEL ALL BLOCKED %SCRY SUB-BUILDS OF :ROOT-BUILDS
  ::
  ++  CANCEL-SCRYS
    |=  ROOT-BUILD=BUILD
    ^+  ..EXECUTE
    ::
    =/  BLOCKED-SUB-SCRYS  ~(TAP IN (COLLECT-BLOCKED-SUB-SCRYS ROOT-BUILD))
    ::
    |-  ^+  ..EXECUTE
    ?~  BLOCKED-SUB-SCRYS  ..EXECUTE
    ::
    =.  ..EXECUTE  (CANCEL-SCRY-REQUEST I.BLOCKED-SUB-SCRYS)
    ::
    $(BLOCKED-SUB-SCRYS T.BLOCKED-SUB-SCRYS)
  ::  +MOVE-ROOT-TO-CACHE: REPLACE :DUCT WITH A %CACHE ANCHOR IN :BUILD'S TREE
  ::
  ++  MOVE-ROOT-TO-CACHE
    ~/  %MOVE-ROOT-TO-CACHE
    |=  =BUILD
    ^+  STATE
    ::  OBTAIN THE NEW CACHE ID AND INCREMENT THE :NEXT-ANCHOR-ID IN THE STATE
    ::
    =^  NEW-ID  NEXT-ANCHOR-ID.BUILD-CACHE.STATE
      =/  ID=@UD  NEXT-ANCHOR-ID.BUILD-CACHE.STATE
      [ID +(ID)]
    ::  REPLACE THE REQUESTER IN THE ROOT BUILD
    ::
    =.  BUILDS.STATE
      %+  ~(JAB BY BUILDS.STATE)  BUILD
      |=  =BUILD-STATUS
      %_    BUILD-STATUS
          REQUESTERS
        =-  (~(DEL IN -) [%DUCT DUCT])
        =-  (~(PUT IN -) [%CACHE NEW-ID])
        REQUESTERS.BUILD-STATUS
      ==
    ::  ENQUEUE :BUILD INTO CACHE, POSSIBLY POPPING AND DELETING A STALE BUILD
    ::
    =^  OLDEST  QUEUE.BUILD-CACHE.STATE
      %.  [NEW-ID BUILD]
      ~(PUT (TO-CAPPED-QUEUE BUILD-CACHE-KEY) QUEUE.BUILD-CACHE.STATE)
    ::
    =?    STATE
        ?=(^ OLDEST)
      (REMOVE-ANCHOR-FROM-ROOT ROOT-BUILD.U.OLDEST [%CACHE ID.U.OLDEST])
    ::  RECURSIVELY REPLACE :CLIENTS IN :BUILD AND DESCENDANTS
    ::
    |-  ^+  STATE
    ::
    =/  CLIENT-STATUS=BUILD-STATUS  (~(GOT BY BUILDS.STATE) BUILD)
    =/  SUBS=(LIST ^BUILD)  ~(TAP IN ~(KEY BY SUBS.CLIENT-STATUS))
    ::
    |-  ^+  STATE
    ?~  SUBS  STATE
    ::
    =.  BUILDS.STATE
      %+  ~(JAB BY BUILDS.STATE)  I.SUBS
      |=  =BUILD-STATUS
      %_    BUILD-STATUS
          CLIENTS
        ::  IF WE'VE ALREADY ENCOUNTERED :I.SUBS, DON'T OVERWRITE
        ::
        ?:  (~(HAS BY CLIENTS.BUILD-STATUS) [%CACHE NEW-ID])
          CLIENTS.BUILD-STATUS
        ::
        =/  OLD-CLIENTS-ON-DUCT  (~(GET JU CLIENTS.BUILD-STATUS) [%DUCT DUCT])
        ::
        =-  (~(DEL BY -) [%DUCT DUCT])
        =-  (~(PUT BY -) [%CACHE NEW-ID] OLD-CLIENTS-ON-DUCT)
        CLIENTS.BUILD-STATUS
      ==
    ::
    =.  STATE  ^$(BUILD I.SUBS)
    ::
    $(SUBS T.SUBS)
  ::  +REMOVE-ANCHOR-FROM-ROOT: REMOVE :ANCHOR FROM :BUILD'S TREE
  ::
  ++  REMOVE-ANCHOR-FROM-ROOT
    ~/  %REMOVE-ANCHOR-FROM-ROOT
    |=  [=BUILD =ANCHOR]
    ^+  STATE
    ::
    =.  BUILDS.STATE
      %+  ~(JAB BY BUILDS.STATE)  BUILD
      |=  =BUILD-STATUS
      BUILD-STATUS(REQUESTERS (~(DEL IN REQUESTERS.BUILD-STATUS) ANCHOR))
    ::
    =.  BUILDS.STATE  (REMOVE-ANCHOR-FROM-SUBS BUILD ANCHOR)
    ::
    (CLEANUP BUILD)
  ::  +REMOVE-ANCHOR-FROM-SUBS: RECURSIVELY REMOVE :ANCHOR FROM SUB-BUILDS
  ::
  ++  REMOVE-ANCHOR-FROM-SUBS
    ~/  %REMOVE-ANCHOR-FROM-SUBS
    |=  [=BUILD =ANCHOR]
    ^+  BUILDS.STATE
    ::
    =/  =BUILD-STATUS  (~(GOT BY BUILDS.STATE) BUILD)
    =/  SUBS=(LIST ^BUILD)  ~(TAP IN ~(KEY BY SUBS.BUILD-STATUS))
    =/  CLIENT=^BUILD  BUILD
    ::
    |-  ^+  BUILDS.STATE
    ?~  SUBS  BUILDS.STATE
    ::
    =/  SUB-STATUS=^BUILD-STATUS  (~(GOT BY BUILDS.STATE) I.SUBS)
    ::
    =.  CLIENTS.SUB-STATUS
      (~(DEL JU CLIENTS.SUB-STATUS) ANCHOR CLIENT)
    ::
    =.  BUILDS.STATE  (~(PUT BY BUILDS.STATE) I.SUBS SUB-STATUS)
    ::
    =?  BUILDS.STATE  !(~(HAS BY CLIENTS.SUB-STATUS) ANCHOR)
      ::
      ^$(BUILD I.SUBS)
    ::
    $(SUBS T.SUBS)
  ::  +ADD-ANCHORS-TO-BUILD-SUBS: FOR EACH SUB, ADD ALL OF :BUILD'S ANCHORS
  ::
  ++  ADD-ANCHORS-TO-BUILD-SUBS
    ~/  %ADD-ANCHORS-TO-BUILD-SUBS
    |=  =BUILD
    ^+  STATE
    ::
    =/  =BUILD-STATUS  (~(GOT BY BUILDS.STATE) BUILD)
    =/  NEW-ANCHORS
      ~(TAP IN (~(PUT IN ~(KEY BY CLIENTS.BUILD-STATUS)) [%DUCT DUCT]))
    =/  SUBS  ~(TAP IN ~(KEY BY SUBS.BUILD-STATUS))
    ::
    =.  STATE
      |-
      ^+  STATE
      ?~  SUBS  STATE
      ::
      =.  STATE  (ADD-BUILD I.SUBS)
      ::
      $(SUBS T.SUBS)
    ::
    =.  BUILDS.STATE
      |-  ^+  BUILDS.STATE
      ?~  NEW-ANCHORS  BUILDS.STATE
      ::
      =.  BUILDS.STATE  (ADD-ANCHOR-TO-SUBS I.NEW-ANCHORS BUILD)
      ::
      $(NEW-ANCHORS T.NEW-ANCHORS)
    ::
    STATE
  ::  +ADD-ANCHOR-TO-SUBS: ATTACH :DUCT TO :BUILD'S DESCENDANTS
  ::
  ++  ADD-ANCHOR-TO-SUBS
    ~/  %ADD-ANCHOR-TO-SUBS
    |=  [=ANCHOR =BUILD]
    ^+  BUILDS.STATE
    ::
    =/  =BUILD-STATUS  (~(GOT BY BUILDS.STATE) BUILD)
    =/  SUBS=(LIST ^BUILD)  ~(TAP IN ~(KEY BY SUBS.BUILD-STATUS))
    =/  CLIENT=^BUILD  BUILD
    ::
    |-  ^+  BUILDS.STATE
    ?~  SUBS  BUILDS.STATE
    ::
    =/  SUB-STATUS=^BUILD-STATUS  (~(GOT BY BUILDS.STATE) I.SUBS)
    ::
    =/  ALREADY-HAD-ANCHOR=?  (~(HAS BY CLIENTS.SUB-STATUS) ANCHOR)
    ::
    =.  CLIENTS.SUB-STATUS
      (~(PUT JU CLIENTS.SUB-STATUS) ANCHOR CLIENT)
    ::
    =.  BUILDS.STATE  (~(PUT BY BUILDS.STATE) I.SUBS SUB-STATUS)
    ::
    =?  BUILDS.STATE  !ALREADY-HAD-ANCHOR  ^$(BUILD I.SUBS)
    ::
    $(SUBS T.SUBS)
  ::  +COPY-BUILD-TREE-AS-PROVISIONAL: PREPOPULATE NEW LIVE BUILD
  ::
  ::    MAKE A PROVISIONAL COPY OF THE COMPLETED OLD ROOT BUILD TREE AT THE
  ::    :NEW TIME.
  ::
  ++  COPY-BUILD-TREE-AS-PROVISIONAL
    ~/  %COPY-BUILD-TREE-AS-PROVISIONAL
    |=  [OLD-ROOT=BUILD NEW-DATE=@DA]
    ^+  STATE
    ~|  [OLD-ROOT=(BUILD-TO-TAPE OLD-ROOT) NEW-DATE=NEW-DATE]
    ::
    =/  OLD-CLIENT=BUILD  OLD-ROOT
    =/  NEW-CLIENT=BUILD  OLD-CLIENT(DATE NEW-DATE)
    =.  STATE  (ADD-BUILD NEW-CLIENT)
    ::
    =.  BUILDS.STATE
      %+  ~(JAB BY BUILDS.STATE)  NEW-CLIENT
      |=  =BUILD-STATUS
      BUILD-STATUS(REQUESTERS (~(PUT IN REQUESTERS.BUILD-STATUS) [%DUCT DUCT]))
    ::
    =<  COPY-NODE
    ::
    |%
    ++  COPY-NODE
      ^+  STATE
      ::
      =/  OLD-BUILD-STATUS=BUILD-STATUS
        ~|  OLD-CLIENT=(BUILD-TO-TAPE OLD-CLIENT)
        (~(GOT BY BUILDS.STATE) OLD-CLIENT)
      ::
      =/  OLD-SUBS=(LIST BUILD)  ~(TAP IN ~(KEY BY SUBS.OLD-BUILD-STATUS))
      =/  NEW-SUBS=(LIST BUILD)  (TURN OLD-SUBS |=(A=BUILD A(DATE NEW-DATE)))
      ::
      =.  BUILDS.STATE
        (ADD-SUBS-TO-CLIENT NEW-CLIENT NEW-SUBS [VERIFIED=%.N BLOCKED=%.Y])
      ::
      |-
      ^+  STATE
      ?~  OLD-SUBS
        STATE
      ::
      =.  STATE  (ADD-CLIENT-TO-SUB I.OLD-SUBS)
      =.  STATE
        COPY-NODE(OLD-CLIENT I.OLD-SUBS, NEW-CLIENT I.OLD-SUBS(DATE NEW-DATE))
      ::
      $(OLD-SUBS T.OLD-SUBS)
    ::
    ++  ADD-CLIENT-TO-SUB
      |=  OLD-SUB=BUILD
      ^+  STATE
      ::
      =/  NEW-SUB  OLD-SUB(DATE NEW-DATE)
      =.  STATE  (ADD-BUILD NEW-SUB)
      ::
      =.  BUILDS.STATE
        %+  ~(JAB BY BUILDS.STATE)  NEW-SUB
        |=  =BUILD-STATUS
        %_  BUILD-STATUS
          CLIENTS  (~(PUT JU CLIENTS.BUILD-STATUS) [%DUCT DUCT] NEW-CLIENT)
        ==
      ::
      STATE
    --
  ::  +ADD-SUBS-TO-CLIENT: REGISTER :NEW-SUBS AS SUBS OF :NEW-CLIENT
  ::
  ++  ADD-SUBS-TO-CLIENT
    ~/  %ADD-SUBS-TO-CLIENT
    |=  [NEW-CLIENT=BUILD NEW-SUBS=(LIST BUILD) =BUILD-RELATION]
    ^+  BUILDS.STATE
    ::
    %+  ~(JAB BY BUILDS.STATE)  NEW-CLIENT
    |=  =BUILD-STATUS
    %_    BUILD-STATUS
        SUBS
      %-  ~(GAS BY SUBS.BUILD-STATUS)
      %+  MURN  NEW-SUBS
      |=  SUB=BUILD
      ^-  (UNIT (PAIR BUILD ^BUILD-RELATION))
      ::
      ?^  (~(GET BY SUBS.BUILD-STATUS) SUB)
        ~
      `[SUB BUILD-RELATION]
    ==
  ::  |CONSTRUCTION: ARMS FOR PERFORMING BUILDS
  ::
  ::+|  CONSTRUCTION
  ::
  ::  +EXECUTE-LOOP: +EXECUTE REPEATEDLY UNTIL THERE'S NO MORE WORK TO DO
  ::
  ::    KEEP RUNNING +EXECUTE UNTIL ALL RELEVANT BUILDS EITHER COMPLETE OR
  ::    BLOCK ON EXTERNAL RESOURCE REQUESTS. SEE +EXECUTE FOR DETAILS OF EACH
  ::    LOOP EXECUTION.
  ::
  ::    THIS IMPLEMENTATION IS FOR SIMPLICITY. IN THE LONGER TERM, WE'D
  ::    LIKE TO JUST PERFORM A SINGLE RUN THROUGH +EXECUTE AND SET A BEHN TIMER
  ::    TO WAKE US UP IMMEDIATELY. THIS HAS THE ADVANTAGE THAT FORD STOPS HARD
  ::    BLOCKING THE MAIN URBIT EVENT LOOP, LETTING OTHER WORK BE DONE.
  ::
  ++  EXECUTE-LOOP  !.
    ~/  %EXECUTE-LOOP
    |=  BUILDS=(SET BUILD)
    ^+  ..EXECUTE
    ::
    =.  ..EXECUTE  (EXECUTE BUILDS)
    ::
    ?:  ?&  ?=(~ NEXT-BUILDS)
            ?=(~ CANDIDATE-BUILDS)
        ==
      ..EXECUTE
    ::
    $(BUILDS ~)
  ::  +EXECUTE: MAIN RECURSIVE CONSTRUCTION ALGORITHM
  ::
  ::    PERFORMS THE THREE STEP BUILD PROCESS: FIRST, FIGURE OUT WHICH BUILDS
  ::    WE'RE GOING TO RUN THIS LOOP THROUGH THE FORD ALGORITHM. SECOND, RUN
  ::    THE GATHERED BUILDS, POSSIBLY IN PARALLEL. THIRD, APPLY THE
  ::    +BUILD-RECEIPT ALGORITHMS TO THE FORD STATE.
  ::
  ++  EXECUTE
    ~/  %EXECUTE
    |=  BUILDS=(SET BUILD)
    ^+  ..EXECUTE
    ::
    =.  ..EXECUTE  (GATHER BUILDS FORCE=%.N)
    ::
    =^  BUILD-RECEIPTS  ..EXECUTE  RUN-BUILDS
    ::
    (REDUCE BUILD-RECEIPTS)
  ::  +GATHER: COLLECT BUILDS TO BE RUN IN A BATCH
  ::
  ::    THE +GATHER PHASE IS THE FIRST OF THE THREE PARTS OF +EXECUTE. IN
  ::    +GATHER, WE LOOK THROUGH EACH ITEM IN :CANDIDATE-BUILDS.  IF WE
  ::    SHOULD RUN THE CANDIDATE BUILD THIS CYCLE THROUGH THE +EXECUTE LOOP, WE
  ::    PLACE IT IN :NEXT-BUILDS. +GATHER RUNS UNTIL IT HAS NO MORE CANDIDATES.
  ::
  ++  GATHER  !.
    ~/  %GATHER
    |=  [BUILDS=(SET BUILD) FORCE=?]
    ^+  ..EXECUTE
    ::  ADD BUILDS THAT WERE TRIGGERED BY INCOMING EVENT TO THE CANDIDATE LIST
    ::
    =.  CANDIDATE-BUILDS  (~(UNI IN CANDIDATE-BUILDS) BUILDS)
    ::
    |^  ^+  ..EXECUTE
        ::
        ?:  =(~ CANDIDATE-BUILDS)
          ..EXECUTE
        ::
        =/  NEXT=BUILD
          ?<  ?=(~ CANDIDATE-BUILDS)
          N.CANDIDATE-BUILDS
        =.  CANDIDATE-BUILDS  (~(DEL IN CANDIDATE-BUILDS) NEXT)
        ::
        $(..EXECUTE (GATHER-BUILD NEXT))
    ::  +GATHER-BUILD: LOOKS AT A SINGLE CANDIDATE BUILD
    ::
    ::    THIS GATE INSPECTS A SINGLE BUILD. IT MIGHT MOVE IT TO :NEXT-BUILDS,
    ::    OR PROMOTE IT USING AN OLD BUILD. IT ALSO MIGHT ADD THIS BUILD'S
    ::    SUB-BUILDS TO :CANDIDATE-BUILDS.
    ::
    ++  GATHER-BUILD
      |=  =BUILD
      ^+  ..EXECUTE
      ~|  [%DUCT DUCT]
      =/  DUCT-STATUS  (~(GOT BY DUCTS.STATE) DUCT)
      ::  IF WE ALREADY HAVE A RESULT FOR THIS BUILD, DON'T RERUN THE BUILD
      ::
      =^  CURRENT-RESULT  BUILDS.STATE  (ACCESS-BUILD-RECORD BUILD)
      ::
      ?:  ?=([~ %VALUE *] CURRENT-RESULT)
        (ON-BUILD-COMPLETE BUILD)
      ::  PLACE :BUILD IN :BUILDS.STATE IF IT ISN'T ALREADY THERE
      ::
      =.  STATE  (ADD-BUILD BUILD)
      ::  IGNORE BLOCKED BUILDS
      ::
      =/  =BUILD-STATUS  (~(GOT BY BUILDS.STATE) BUILD)
      ?:  ?=(%BLOCKED -.STATE.BUILD-STATUS)
        =.  STATE  (ADD-ANCHORS-TO-BUILD-SUBS BUILD)
        ::
        =/  SUB-SCRYS=(LIST SCRY-REQUEST)
          ~(TAP IN (COLLECT-BLOCKED-SUB-SCRYS BUILD))
        ::
        =.  PENDING-SCRYS.STATE
          |-  ^+  PENDING-SCRYS.STATE
          ?~  SUB-SCRYS  PENDING-SCRYS.STATE
          ::
          =.  PENDING-SCRYS.STATE
            (PUT-REQUEST PENDING-SCRYS.STATE I.SUB-SCRYS DUCT)
          ::
          $(SUB-SCRYS T.SUB-SCRYS)
        ::
        ..EXECUTE
      ::  OLD-BUILD: MOST RECENT PREVIOUS BUILD WITH :SCHEMATIC.BUILD
      ::
      =/  OLD-BUILD=(UNIT ^BUILD)
        ?:  ?&  ?=(%LIVE -.LIVE.DUCT-STATUS)
                ?=(^ LAST-SENT.LIVE.DUCT-STATUS)
            ==
          ::  CHECK WHETHER :BUILD WAS RUN AS PART OF THE LAST LIVE BUILD TREE
          ::
          ::    IF WE HAD BUILD THIS SCHEMATIC AS PART OF THE BUILD TREE
          ::    DURING THE LAST RUN OF THIS LIVE BUILD, THEN WE CAN COMPARE
          ::    OUR RESULT TO THAT BUILD. IT MIGHT NOT BE THE MOST RECENT,
          ::    BUT IF OUR SUB-BUILDS HAVE THE SAME RESULTS AS THEY DID THEN,
          ::    WE CAN PROMOTE THEM. THIS IS ESPECIALLY HELPFUL FOR A %SCRY
          ::    BUILD, BECAUSE WE DON'T HAVE TO MAKE A NEW REQUEST FOR THE
          ::    RESOURCE IF THE LAST LIVE BUILD SUBSCRIBED TO IT.
          ::
          ::    OTHERWISE, DEFAULT TO LOOKING UP THE MOST RECENT BUILD OF THIS
          ::    SCHEMATIC IN :BUILDS-BY-SCHEMATIC.STATE. WE'LL HAVE TO RERUN
          ::    ANY %SCRY SUB-BUILDS, BUT OTHER THAN THAT, WE SHOULD STILL BE
          ::    ABLE TO PROMOTE ITS RESULT IF ITS SUB-BUILDS HAVE THE SAME
          ::    RESULTS AS OURS.
          ::
          =/  POSSIBLE-BUILD=^BUILD
            [DATE.U.LAST-SENT.LIVE.DUCT-STATUS SCHEMATIC.BUILD]
          ?:  (~(HAS BY BUILDS.STATE) POSSIBLE-BUILD)
            `POSSIBLE-BUILD
          (~(FIND-PREVIOUS BY-SCHEMATIC BUILDS-BY-SCHEMATIC.STATE) BUILD)
        (~(FIND-PREVIOUS BY-SCHEMATIC BUILDS-BY-SCHEMATIC.STATE) BUILD)
      ::  IF NO PREVIOUS BUILDS EXIST, WE NEED TO RUN :BUILD
      ::
      ?~  OLD-BUILD
        (ADD-BUILD-TO-NEXT BUILD)
      ::
      =/  OLD-BUILD-STATUS=^BUILD-STATUS
        ~|  [%MISSING-OLD-BUILD (BUILD-TO-TAPE U.OLD-BUILD)]
        ~|  [%BUILD-STATE (TURN ~(TAP IN ~(KEY BY BUILDS.STATE)) BUILD-TO-TAPE)]
        (~(GOT BY BUILDS.STATE) U.OLD-BUILD)
      ::  SELECTIVELY PROMOTE SCRY BUILDS
      ::
      ::    WE CAN ONLY PROMOTE A SCRY IF IT'S NOT FORCED AND WE RAN THE SAME
      ::    SCRY SCHEMATIC AS A DESCENDANT OF THE ROOT BUILD SCHEMATIC AT THE
      ::    LAST SENT TIME FOR THIS DUCT.
      ::
      ?:  ?&  ?=(%SCRY -.SCHEMATIC.BUILD)
              ?|  FORCE
                  ?!
                  ?&  ?=(%LIVE -.LIVE.DUCT-STATUS)
                      ?=(^ LAST-SENT.LIVE.DUCT-STATUS)
                  ::
                      =/  SUBSCRIPTION=(UNIT SUBSCRIPTION)
                        SUBSCRIPTION.U.LAST-SENT.LIVE.DUCT-STATUS
                      ::
                      ?~  SUBSCRIPTION
                        %.N
                      %-  ~(HAS IN RESOURCES.U.SUBSCRIPTION)
                      RESOURCE.SCHEMATIC.BUILD
          ==  ==  ==
        (ADD-BUILD-TO-NEXT BUILD)
      ::  IF WE DON'T HAVE :U.OLD-BUILD'S RESULT CACHED, WE NEED TO RUN :BUILD
      ::
      =^  OLD-BUILD-RECORD  BUILDS.STATE  (ACCESS-BUILD-RECORD U.OLD-BUILD)
      ?.  ?=([~ %VALUE *] OLD-BUILD-RECORD)
        (ADD-BUILD-TO-NEXT BUILD)
      ::
      =.  OLD-BUILD-STATUS  (~(GOT BY BUILDS.STATE) U.OLD-BUILD)
      ::
      =/  OLD-SUBS=(LIST ^BUILD)  ~(TAP IN ~(KEY BY SUBS.OLD-BUILD-STATUS))
      =/  NEW-SUBS=(LIST ^BUILD)
        (TURN OLD-SUBS |=(^BUILD +<(DATE DATE.BUILD)))
      ::  LINK SUB-BUILDS PROVISIONALLY, BLOCKING ON INCOMPLETE
      ::
      ::    WE DON'T KNOW THAT :BUILD WILL END UP DEPENDING ON :NEW-SUBS,
      ::    SO THEY'RE NOT :VERIFIED.
      ::
      =/  SPLIT-NEW-SUBS
        %+  SKID  NEW-SUBS
        |=  SUB=^BUILD
        ^-  ?
        ::
        ?~  MAYBE-BUILD-STATUS=(~(GET BY BUILDS.STATE) SUB)
          %.N
        ::
        ?&  ?=(%COMPLETE -.STATE.U.MAYBE-BUILD-STATUS)
            ?=(%VALUE -.BUILD-RECORD.STATE.U.MAYBE-BUILD-STATUS)
        ==
      ::
      =/  STORED-NEW-SUBS=(LIST ^BUILD)     -.SPLIT-NEW-SUBS
      =/  UN-STORED-NEW-SUBS=(LIST ^BUILD)  +.SPLIT-NEW-SUBS
      ::
      =.  BUILDS.STATE
        (ADD-SUBS-TO-CLIENT BUILD STORED-NEW-SUBS [VERIFIED=%.N BLOCKED=%.N])
      =.  BUILDS.STATE
        (ADD-SUBS-TO-CLIENT BUILD UN-STORED-NEW-SUBS [VERIFIED=%.N BLOCKED=%.Y])
      ::
      =.  STATE  (ADD-ANCHORS-TO-BUILD-SUBS BUILD)
      ::
      ?^  UN-STORED-NEW-SUBS
        ::  ENQUEUE INCOMPLETE SUB-BUILDS TO BE PROMOTED OR RUN
        ::
        ::    WHEN NOT ALL OUR SUB BUILDS HAVE RESULTS, WE CAN'T ADD :BUILD TO
        ::    :NEXT-BUILDS.STATE. INSTEAD, PUT ALL THE REMAINING UNCACHED NEW
        ::    SUBS INTO :CANDIDATE-BUILDS.
        ::
        ::    IF ALL OF OUR SUB-BUILDS FINISH IMMEDIATELY (I.E. PROMOTED) WHEN
        ::    THEY PASS THROUGH +GATHER-INTERNAL, THEY WILL ADD :BUILD BACK TO
        ::    :CANDIDATE-BUILDS AND WE WILL RUN AGAIN BEFORE +EXECUTE RUNS
        ::    +MAKE.
        ::
        %_    ..EXECUTE
            CANDIDATE-BUILDS
          (~(GAS IN CANDIDATE-BUILDS) UN-STORED-NEW-SUBS)
        ==
      ::
      =^  PROMOTABLE  BUILDS.STATE  (ARE-SUBS-UNCHANGED OLD-SUBS NEW-SUBS)
      ?.  PROMOTABLE
        (ADD-BUILD-TO-NEXT BUILD)
      ::
      ?>  =(SCHEMATIC.BUILD SCHEMATIC.U.OLD-BUILD)
      ?>  (~(HAS BY BUILDS.STATE) BUILD)
      (PROMOTE-BUILD U.OLD-BUILD DATE.BUILD NEW-SUBS)
    ::  +ARE-SUBS-UNCHANGED: CHECKS SUB-BUILD EQUIVALENCE, UPDATING ACCESS TIME
    ::
    ++  ARE-SUBS-UNCHANGED
      |=  [OLD-SUBS=(LIST BUILD) NEW-SUBS=(LIST BUILD)]
      ^-  [? _BUILDS.STATE]
      ::
      ?~  OLD-SUBS
        [%.Y BUILDS.STATE]
      ?>  ?=(^ NEW-SUBS)
      ::
      =^  OLD-BUILD-RECORD  BUILDS.STATE  (ACCESS-BUILD-RECORD I.OLD-SUBS)
      ?.  ?=([~ %VALUE *] OLD-BUILD-RECORD)
        [%.N BUILDS.STATE]
      ::
      =^  NEW-BUILD-RECORD  BUILDS.STATE  (ACCESS-BUILD-RECORD I.NEW-SUBS)
      ?.  ?=([~ %VALUE *] NEW-BUILD-RECORD)
        [%.N BUILDS.STATE]
      ::
      ?.  =(BUILD-RESULT.U.OLD-BUILD-RECORD BUILD-RESULT.U.NEW-BUILD-RECORD)
        [%.N BUILDS.STATE]
      $(NEW-SUBS T.NEW-SUBS, OLD-SUBS T.OLD-SUBS)
    ::  +ADD-BUILD-TO-NEXT: RUN THIS BUILD DURING THE +MAKE PHASE
    ::
    ++  ADD-BUILD-TO-NEXT
      |=  =BUILD
      ..EXECUTE(NEXT-BUILDS (~(PUT IN NEXT-BUILDS) BUILD))
    ::  +PROMOTE-BUILD: PROMOTE RESULT OF :BUILD TO NEWER :DATE
    ::
    ::    ALSO PERFORMS RELEVANT ACCOUNTING, AND POSSIBLY SENDS %MADE MOVES.
    ::
    ++  PROMOTE-BUILD
      |=  [OLD-BUILD=BUILD NEW-DATE=@DA NEW-SUBS=(LIST BUILD)]
      ^+  ..EXECUTE
      ::  GRAB THE PREVIOUS RESULT, FRESHENING THE CACHE
      ::
      =^  OLD-BUILD-RECORD  BUILDS.STATE  (ACCESS-BUILD-RECORD OLD-BUILD)
      ::  WE CAN ONLY PROMOTE A CACHED RESULT, NOT MISSING OR A %TOMBSTONE
      ::
      ?>  ?=([~ %VALUE *] OLD-BUILD-RECORD)
      =/  =BUILD-RESULT  BUILD-RESULT.U.OLD-BUILD-RECORD
      ::  :NEW-BUILD IS :OLD-BUILD AT :DATE; PROMOTION DESTINATION
      ::
      =/  NEW-BUILD=BUILD  OLD-BUILD(DATE NEW-DATE)
      ::
      =.  BUILDS.STATE
        %+  ~(JAB BY BUILDS.STATE)  NEW-BUILD
        |=  =BUILD-STATUS
        ^+  BUILD-STATUS
        ::
        %_    BUILD-STATUS
        ::  VERIFY LINKAGES BETWEEN :NEW-BUILD AND SUBS
        ::
            SUBS
          ::
          ^-  (MAP BUILD BUILD-RELATION)
          %-  MY
          ^-  (LIST (PAIR BUILD BUILD-RELATION))
          %+  TURN  NEW-SUBS
          |=  SUB=BUILD
          ::
          [SUB [VERIFIED=& BLOCKED=|]]
        ::  COPY THE OLD RESULT TO :NEW-BUILD
        ::
            STATE
          [%COMPLETE [%VALUE LAST-ACCESSED=NOW BUILD-RESULT=BUILD-RESULT]]
        ==
      ::
      (ON-BUILD-COMPLETE NEW-BUILD)
    --
  ::  +RUN-BUILDS: RUN THE BUILDS AND PRODUCE +BUILD-RECEIPTS
  ::
  ::    RUNS THE BUILDS AND CLEANS UP THE BUILD LISTS AFTERWARDS.
  ::
  ::    WHEN THE VERE INTERPRETER HAS A PARALLEL VARIANT OF +TURN, USE
  ::    THAT AS EACH BUILD MIGHT TAKE A WHILE AND THERE ARE NO DATA
  ::    DEPENDENCIES BETWEEN BUILDS HERE. FOR NOW, THOUGH, RUN THEM SERIALLY.
  ::
  ++  RUN-BUILDS
    =<  $
    ~%  %RUN-BUILDS  +  ~
    |.
    ^-  [(LIST BUILD-RECEIPT) _..EXECUTE]
    ::
    =/  BUILD-RECEIPTS=(LIST BUILD-RECEIPT)
      (TURN ~(TAP IN NEXT-BUILDS) MAKE)
    ::
    =.  NEXT-BUILDS  ~
    [BUILD-RECEIPTS ..EXECUTE]
  ::  REDUCE: APPLY +BUILD-RECEIPTS PRODUCE FROM THE +MAKE PHASE.
  ::
  ::    +GATHER PRODUCES BUILDS TO RUN MAKE ON. +MAKE PRODUCES
  ::    +BUILD-RECEIPTS. IT IS IN +REDUCE WHERE WE TAKE THESE +BUILD-RECEIPTS
  ::    AND APPLY THEM TO ..EXECUTE.
  ::
  ++  REDUCE  !.
    ~/  %REDUCE
    |=  BUILD-RECEIPTS=(LIST BUILD-RECEIPT)
    ^+  ..EXECUTE
    ::  SORT :BUILD-RECEIPTS SO BLOCKS ARE PROCESSED BEFORE COMPLETIONS
    ::
    ::    IT'S POSSIBLE FOR A BUILD TO BLOCK ON A SUB-BUILD THAT WAS RUN
    ::    IN THE SAME BATCH. IF THAT'S THE CASE, MAKE SURE WE REGISTER
    ::    THAT THE BUILD BLOCKED ON THE SUB-BUILD BEFORE REGISTERING THE
    ::    COMPLETION OF THE SUB-BUILD. THIS WAY, WHEN WE DO REGISTER THE
    ::    COMPLETION OF THE SUB-BUILD, WE WILL KNOW WHICH BUILDS ARE BLOCKED
    ::    ON THE SUB-BUILD, SO WE CAN ENQUEUE THOSE BLOCKED CLIENTS TO BE
    ::    RERUN.
    ::
    =.  BUILD-RECEIPTS
      %+  SORT  BUILD-RECEIPTS
      |=  [A=BUILD-RECEIPT B=BUILD-RECEIPT]
      ^-  ?
      ?=(%BLOCKS -.RESULT.A)
    ::
    |^  ^+  ..EXECUTE
        ?~  BUILD-RECEIPTS  ..EXECUTE
        ::
        =.  ..EXECUTE  (APPLY-BUILD-RECEIPT I.BUILD-RECEIPTS)
        $(BUILD-RECEIPTS T.BUILD-RECEIPTS)
    ::  +APPLY-BUILD-RECEIPT: APPLIES A SINGLE STATE DIFF TO ..EXECUTE
    ::
    ++  APPLY-BUILD-RECEIPT
      |=  MADE=BUILD-RECEIPT
      ^+  ..EXECUTE
      ::  PROCESS :SUB-BUILDS.MADE
      ::
      =.  STATE  (TRACK-SUB-BUILDS BUILD.MADE SUB-BUILDS.MADE)
      ::
      ?-    -.RESULT.MADE
          %BUILD-RESULT
        (APPLY-BUILD-RESULT [BUILD BUILD-RESULT.RESULT CACHE-ACCESS]:MADE)
      ::
          %BLOCKS
        (APPLY-BLOCKS [BUILD BUILDS.RESULT]:MADE)
      ==
    ::  +TRACK-SUB-BUILDS:
    ::
    ::    FOR EVERY SUB-BUILD DISCOVERED WHILE RUNNING :BUILD, WE HAVE TO MAKE
    ::    SURE THAT WE TRACK THAT SUB-BUILD AND THAT IT IS ASSOCIATED WITH THE
    ::    RIGHT DUCTS.
    ::
    ++  TRACK-SUB-BUILDS
      |=  [CLIENT=BUILD SUB-BUILDS=(LIST BUILD)]
      ^+  STATE
      ::  MARK :SUB-BUILDS AS :SUBS IN :BUILD'S +BUILD-STATUS
      ::
      =^  BUILD-STATUS  BUILDS.STATE
        %+  UPDATE-BUILD-STATUS  CLIENT
        |=  =BUILD-STATUS
        %_    BUILD-STATUS
            SUBS
          %-  ~(GAS BY SUBS.BUILD-STATUS)
          %+  TURN  SUB-BUILDS
          |=  SUB=BUILD
          ::
          =/  BLOCKED=?
            ?~  SUB-STATUS=(~(GET BY BUILDS.STATE) SUB)
              %.Y
            !?=([%COMPLETE %VALUE *] STATE.U.SUB-STATUS)
          ::
          [SUB [VERIFIED=& BLOCKED]]
        ==
      ::
      =.  STATE  (ADD-ANCHORS-TO-BUILD-SUBS CLIENT)
      ::
      |-  ^+  STATE
      ?~  SUB-BUILDS  STATE
      ::
      =.  BUILDS.STATE
        %+  ~(JAB BY BUILDS.STATE)  I.SUB-BUILDS
        |=  BUILD-STATUS=^BUILD-STATUS
        %_    BUILD-STATUS
        ::  FRESHEN :LAST-ACCESSED DATE
        ::
            STATE
          ::
          ?.  ?=([%COMPLETE %VALUE *] STATE.BUILD-STATUS)
            STATE.BUILD-STATUS
          STATE.BUILD-STATUS(LAST-ACCESSED.BUILD-RECORD NOW)
        ==
      ::
      $(SUB-BUILDS T.SUB-BUILDS)
    ::  +APPLY-BUILD-RESULT: APPLY A %BUILD-RESULT +BUILD-RECEIPT TO ..EXECUTE
    ::
    ::    OUR BUILD PRODUCED AN ACTUAL RESULT.
    ::
    ++  APPLY-BUILD-RESULT
      |=  [=BUILD =BUILD-RESULT CACHE-ACCESS=(UNIT [=COMPILER-CACHE-KEY NEW=?])]
      ^+  ..EXECUTE
      ::
      =?  COMPILER-CACHE.STATE  ?=(^ CACHE-ACCESS)
        =+  BY-CLOCK=(BY-CLOCK COMPILER-CACHE-KEY ^BUILD-RESULT)
        ?.  NEW.U.CACHE-ACCESS
          =^  IGNORED  COMPILER-CACHE.STATE
            (~(GET BY-CLOCK COMPILER-CACHE.STATE) COMPILER-CACHE-KEY.U.CACHE-ACCESS)
          COMPILER-CACHE.STATE
        ::
        %+  ~(PUT BY-CLOCK COMPILER-CACHE.STATE)
          COMPILER-CACHE-KEY.U.CACHE-ACCESS
        BUILD-RESULT
      ::
      =.  BUILDS.STATE
        %+  ~(JAB BY BUILDS.STATE)  BUILD
        |=  =BUILD-STATUS
        BUILD-STATUS(STATE [%COMPLETE [%VALUE LAST-ACCESSED=NOW BUILD-RESULT]])
      ::
      (ON-BUILD-COMPLETE BUILD)
    ::  +APPLY-BLOCKS: APPLY A %BLOCKS +BUILD-RECEIPT TO ..EXECUTE
    ::
    ::    :BUILD BLOCKED. RECORD INFORMATION ABOUT WHAT BUILDS IT BLOCKED ON
    ::    AND TRY THOSE BLOCKED BUILDS AS CANDIDATES IN THE NEXT PASS.
    ::
    ++  APPLY-BLOCKS
      |=  [=BUILD BLOCKS=(LIST BUILD)]
      ^+  ..EXECUTE
      ::  IF A %SCRY BLOCKED, REGISTER IT AND MAYBE SEND AN ASYNC REQUEST
      ::
      =?    ..EXECUTE
          ?=(~ BLOCKS)
        ?>  ?=(%SCRY -.SCHEMATIC.BUILD)
        =,  RESOURCE.SCHEMATIC.BUILD
        %-  START-SCRY-REQUEST
        [VANE CARE [[SHIP.DISC.RAIL DESK.DISC.RAIL [%DA DATE.BUILD]] SPUR.RAIL]]
      ::  WE MUST RUN +APPLY-BUILD-RECEIPT ON :BUILD.MADE BEFORE :BLOCK
      ::
      ?<  %+  LIEN  BLOCKS
          |=  BLOCK=^BUILD
          ?~  MAYBE-BUILD-STATUS=(~(GET BY BUILDS.STATE) BLOCK)
            %.N
          ?=(%COMPLETE -.STATE.U.MAYBE-BUILD-STATUS)
      ::  TRANSITION :BUILD'S STATE MACHINE TO THE %BLOCKED STATE
      ::
      =.  BUILDS.STATE
        %+  ~(JAB BY BUILDS.STATE)  BUILD
        |=  =BUILD-STATUS
        BUILD-STATUS(STATE [%BLOCKED ~])
      ::  ENQUEUE :BLOCKS TO BE RUN NEXT
      ::
      =.  CANDIDATE-BUILDS  (~(GAS IN CANDIDATE-BUILDS) BLOCKS)
      ::
      ..EXECUTE
    --
  ::  +MAKE: ATTEMPT TO PERFORM :BUILD, NON-RECURSIVELY
  ::
  ::    REGISTERS COMPONENT LINKAGES BETWEEN :BUILD AND ITS SUB-BUILDS.
  ::    ATTEMPTS TO PERFORM +SCRY IF NECESSARY. DOES NOT DIRECTLY ENQUEUE
  ::    ANY MOVES.
  ::
  ++  MAKE
    ~/  %MAKE
    |=  =BUILD
    ^-  BUILD-RECEIPT
    ::  OUT: RECEIPT TO RETURN TO CALLER
    ::
    =|  OUT=BUILD-RECEIPT
    ::  ~&  [%TURBO-MAKE (BUILD-TO-TAPE BUILD)]
    ::  DISPATCH BASED ON THE KIND OF +SCHEMATIC IN :BUILD
    ::
    |^  =,  SCHEMATIC.BUILD
        ::
        =.  BUILD.OUT  BUILD
        ::
        ?-    -.SCHEMATIC.BUILD
        ::
            ^  (MAKE-AUTOCONS [HEAD TAIL])
        ::
            %$  (MAKE-LITERAL LITERAL)
        ::
            %PIN   (MAKE-PIN DATE SCHEMATIC)
            %ALTS  (MAKE-ALTS CHOICES ~)
            %BAKE  (MAKE-BAKE RENDERER QUERY-STRING PATH-TO-RENDER)
            %BUNT  (MAKE-BUNT DISC MARK)
            %CALL  (MAKE-CALL GATE SAMPLE)
            %CAST  (MAKE-CAST DISC MARK INPUT)
            %CORE  (MAKE-CORE SOURCE-PATH)
            %DIFF  (MAKE-DIFF DISC START END)
            %DUDE  (MAKE-DUDE ERROR ATTEMPT)
            %HOOD  (MAKE-HOOD SOURCE-PATH)
            %JOIN  (MAKE-JOIN DISC MARK FIRST SECOND)
            %LIST  (MAKE-LIST SCHEMATICS)
            %MASH  (MAKE-MASH DISC MARK FIRST SECOND)
            %MUTE  (MAKE-MUTE SUBJECT MUTATIONS)
            %PACT  (MAKE-PACT DISC START DIFF)
            %PATH  (MAKE-PATH DISC PREFIX RAW-PATH)
            %PLAN  (MAKE-PLAN PATH-TO-RENDER QUERY-STRING SCAFFOLD)
            %REEF  (MAKE-REEF DISC)
            %RIDE  (MAKE-RIDE FORMULA SUBJECT)
            %SAME  (MAKE-SAME SCHEMATIC)
            %SCRY  (MAKE-SCRY RESOURCE)
            %SLIM  (MAKE-SLIM SUBJECT-TYPE FORMULA)
            %SLIT  (MAKE-SLIT GATE SAMPLE)
            %VALE  (MAKE-VALE DISC MARK INPUT)
            %VOLT  (MAKE-VOLT DISC MARK INPUT)
            %WALK  (MAKE-WALK DISC SOURCE TARGET)
        ==
    ::  |SCHEMATIC-HANDLERS:MAKE: IMPLEMENTATION OF THE SCHEMATICS
    ::
    ::    ALL OF THESE PRODUCE A VALUE OF THE SAME TYPE AS +MAKE ITSELF.
    ::
    ::  +|  SCHEMATIC-HANDLERS
    ::
    ++  MAKE-AUTOCONS
      ~%  %MAKE-AUTOCONS  ..^^$  ~
      |=  [HEAD=SCHEMATIC TAIL=SCHEMATIC]
      ^-  BUILD-RECEIPT
      ::
      =/  HEAD-BUILD=^BUILD  [DATE.BUILD HEAD]
      =/  TAIL-BUILD=^BUILD  [DATE.BUILD TAIL]
      =^  HEAD-RESULT  OUT  (DEPEND-ON HEAD-BUILD)
      =^  TAIL-RESULT  OUT  (DEPEND-ON TAIL-BUILD)
      ::
      =|  BLOCKS=(LIST ^BUILD)
      =?  BLOCKS  ?=(~ HEAD-RESULT)  [HEAD-BUILD BLOCKS]
      =?  BLOCKS  ?=(~ TAIL-RESULT)  [TAIL-BUILD BLOCKS]
      ::  IF EITHER BUILD BLOCKED, WE'RE NOT DONE
      ::
      ?^  BLOCKS
        ::
        (RETURN-BLOCKS BLOCKS)
      ::
      ?<  ?=(~ HEAD-RESULT)
      ?<  ?=(~ TAIL-RESULT)
      ::
      (RETURN-RESULT %SUCCESS U.HEAD-RESULT U.TAIL-RESULT)
    ::
    ++  MAKE-LITERAL
      ~%  %MAKE-LITERAL  ..^^$  ~
      |=  =CAGE
      ^-  BUILD-RECEIPT
      (RETURN-RESULT %SUCCESS %$ CAGE)
    ::
    ++  MAKE-PIN
      ~%  %MAKE-PIN  ..^^$  ~
      |=  [DATE=@DA =SCHEMATIC]
      ^-  BUILD-RECEIPT
      ::  PINNED-SUB: SUB-BUILD WITH THE %PIN DATE AS FORMAL DATE
      ::
      =/  PINNED-SUB=^BUILD  [DATE SCHEMATIC]
      ::
      =^  RESULT  OUT  (DEPEND-ON PINNED-SUB)
      ::
      ?~  RESULT
        (RETURN-BLOCKS ~[PINNED-SUB])
      ::
      (RETURN-RESULT U.RESULT)
    ::
    ++  MAKE-ALTS
      ~%  %MAKE-ALTS  ..^^$  ~
      |=  [CHOICES=(LIST SCHEMATIC) ERRORS=(LIST TANK)]
      ^-  BUILD-RECEIPT
      ::
      ?~  CHOICES
        (RETURN-ERROR [[%LEAF "%ALTS: ALL OPTIONS FAILED"] ERRORS])
      ::
      =/  CHOICE=^BUILD  [DATE.BUILD I.CHOICES]
      ::
      =^  RESULT  OUT  (DEPEND-ON CHOICE)
      ?~  RESULT
        (RETURN-BLOCKS ~[CHOICE])
      ::
      ?:  ?=([%ERROR *] U.RESULT)
        ::
        =/  BRACES  [[' ' ' ' ~] ['{' ~] ['}' ~]]
        =/  WRAPPED-ERROR=TANK
          [%ROSE BRACES `(LIST TANK)`MESSAGE.U.RESULT]
        =.  ERRORS
          (WELD ERRORS `(LIST TANK)`[[%LEAF "OPTION"] WRAPPED-ERROR ~])
        $(CHOICES T.CHOICES)
      ::
      (RETURN-RESULT %SUCCESS %ALTS U.RESULT)
    ::
    ++  MAKE-BAKE
      ~%  %MAKE-BAKE  ..^^$  ~
      |=  [RENDERER=TERM QUERY-STRING=COIN PATH-TO-RENDER=RAIL]
      ^-  BUILD-RECEIPT
      ::  PATH-BUILD: FIND THE FILE PATH FOR THE RENDERER SOURCE
      ::
      =/  PATH-BUILD=^BUILD
        [DATE.BUILD [%PATH DISC.PATH-TO-RENDER %REN RENDERER]]
      ::
      =^  PATH-RESULT  OUT  (DEPEND-ON PATH-BUILD)
      ?~  PATH-RESULT
        (RETURN-BLOCKS [PATH-BUILD]~)
      ::
      |^  ^-  BUILD-RECEIPT
          ::  IF THERE'S A RENDERER CALLED :RENDERER, USE IT ON :PATH-TO-RENDER
          ::
          ::    OTHERWISE, FALL BACK TO RUNNING THE CONTENTS OF :PATH-TO-RENDER
          ::    THROUGH A MARK THAT HAS THE SAME NAME AS :RENDERER.
          ::
          ?:  ?=([~ %SUCCESS %PATH *] PATH-RESULT)
            (TRY-RENDERER-THEN-MARK RAIL.U.PATH-RESULT)
          (TRY-MARK ~)
      ::  +TRY-RENDERER-THEN-MARK: TRY TO RENDER A PATH, THEN FALL BACK TO MARK
      ::
      ++  TRY-RENDERER-THEN-MARK
        |=  =RAIL
        ^-  BUILD-RECEIPT
        ::  BUILD A +SCAFFOLD FROM THE RENDERER SOURCE
        ::
        =/  HOOD-BUILD=^BUILD  [DATE.BUILD [%HOOD RAIL]]
        ::
        =^  HOOD-RESULT  OUT  (DEPEND-ON HOOD-BUILD)
        ?~  HOOD-RESULT
          (RETURN-BLOCKS [HOOD-BUILD]~)
        ::  IF WE CAN'T FIND AND PARSE THE RENDERER, TRY THE MARK INSTEAD
        ::
        ?:  ?=([~ %ERROR *] HOOD-RESULT)
          (TRY-MARK MESSAGE.U.HOOD-RESULT)
        ?>  ?=([~ %SUCCESS %HOOD *] HOOD-RESULT)
        ::  LINK THE RENDERER, PASSING THROUGH :PATH-TO-RENDER AND :QUERY-STRING
        ::
        =/  PLAN-BUILD=^BUILD
          :-  DATE.BUILD
          [%PLAN PATH-TO-RENDER QUERY-STRING SCAFFOLD.U.HOOD-RESULT]
        ::
        =^  PLAN-RESULT  OUT  (DEPEND-ON PLAN-BUILD)
        ?~  PLAN-RESULT
          (RETURN-BLOCKS [PLAN-BUILD]~)
        ::  IF COMPILING THE RENDERER ERRORS OUT, TRY THE MARK INSTEAD
        ::
        ?:  ?=([~ %ERROR *] PLAN-RESULT)
          (TRY-MARK MESSAGE.U.PLAN-RESULT)
        ?>  ?=([~ %SUCCESS %PLAN *] PLAN-RESULT)
        ::  RENDERERS RETURN THEIR NAME AS THE MARK
        ::
        ::    WE SHOULD RETHINK WHETHER WE WANT THIS TO BE THE CASE GOING
        ::    FORWARD, BUT FOR NOW, EYRE DEPENDS ON THIS DETAIL TO WORK.
        ::
        (RETURN-RESULT [%SUCCESS %BAKE RENDERER VASE.U.PLAN-RESULT])
      ::   +TRY-MARK: TRY TO CAST A FILE'S CONTENTS THROUGH A MARK
      ::
      ::     :ERRORS CONTAINS ANY ERROR MESSAGES FROM OUR PREVIOUS ATTEMPT TO
      ::     RUN A RENDERER, IF WE MADE ONE. THIS WAY IF BOTH THE RENDERER AND
      ::     MARK FAIL, THE REQUESTER WILL SEE THE ERRORS OF BOTH ATTEMPTS.
      ::
      ++  TRY-MARK
        |=  ERRORS=(LIST TANK)
        ^-  BUILD-RECEIPT
        ::  NO RENDERER, TRY MARK; RETRIEVE DIRECTORY LISTING OF :PATH-TO-RENDER
        ::
        ::    THERE MIGHT BE MULTIPLE FILES OF DIFFERENT MARKS STORED AT
        ::    :PATH-TO-RENDER. RETRIEVE THE DIRECTORY LISTING FOR
        ::    :PATH-TO-RENDER, THEN CHECK WHICH OF THE PATH SEGMENTS IN
        ::    THAT DIRECTORY ARE FILES (NOT JUST FOLDERS), THEN FOR EACH
        ::    FILE TRY TO %CAST ITS MARK TO THE DESIRED MARK (:RENDERER).
        ::
        ::    START BY RETRIEVING THE DIRECTORY LISTING, USING :TOPLEVEL-BUILD.
        ::
        =/  TOPLEVEL-BUILD=^BUILD
          [DATE.BUILD [%SCRY %C %Y PATH-TO-RENDER]]
        ::
        =^  TOPLEVEL-RESULT  OUT  (DEPEND-ON TOPLEVEL-BUILD)
        ?~  TOPLEVEL-RESULT
          (RETURN-BLOCKS [TOPLEVEL-BUILD]~)
        ::
        ?:  ?=([~ %ERROR *] TOPLEVEL-RESULT)
          ::
          =/  =PATH  (RAIL-TO-PATH PATH-TO-RENDER)
          ?~  ERRORS
            %-  RETURN-ERROR
            :-  [%LEAF "FORD: %BAKE {<RENDERER>} ON {<PATH>} FAILED:"]
            MESSAGE.U.TOPLEVEL-RESULT
          ::
          =/  BRACES  [[' ' ' ' ~] ['{' ~] ['}' ~]]
          %-  RETURN-ERROR  :~
            [%LEAF "FORD: %BAKE {<RENDERER>} ON {<PATH>} FAILED:"]
            [%LEAF "AS-RENDERER"]
            [%ROSE BRACES ERRORS]
            [%LEAF "AS-MARK"]
            [%ROSE BRACES MESSAGE.U.TOPLEVEL-RESULT]
          ==
        ?>  ?=([~ %SUCCESS %SCRY *] TOPLEVEL-RESULT)
        ::
        =/  TOPLEVEL-ARCH=ARCH  ;;(ARCH Q.Q.CAGE.U.TOPLEVEL-RESULT)
        ::  FIND THE :SUB-PATH-SEGMENTS THAT COULD BE FILES
        ::
        ::    FILTER OUT PATH SEGMENTS THAT AREN'T A +TERM,
        ::    SINCE THOSE AREN'T VALID MARKS AND THEREFORE CAN'T
        ::    BE THE LAST SEGMENT OF A FILEPATH IN CLAY.
        ::
        =/  SUB-PATH-SEGMENTS=(LIST @TA)
          (SKIM (TURN ~(TAP BY DIR.TOPLEVEL-ARCH) HEAD) (SANE %TAS))
        ::
        =/  SUB-SCHEMATICS=(LIST [SUB-PATH=@TA =SCHEMATIC])
          %+  TURN  SUB-PATH-SEGMENTS
          |=  SUB=@TA
          :-  SUB
          [%SCRY %C %Y PATH-TO-RENDER(SPUR [SUB SPUR.PATH-TO-RENDER])]
        ::
        =^  MAYBE-SCHEMATIC-RESULTS  OUT
          %-  PERFORM-SCHEMATICS  :*
            ;:  WELD
              "FORD: %BAKE "  (TRIP RENDERER)  " ON "
              (SPUD (RAIL-TO-PATH PATH-TO-RENDER))  " CONTAINED FAILURES:"
            ==
            SUB-SCHEMATICS
            %FAIL-ON-ERRORS
            *@TA
          ==
        ?~  MAYBE-SCHEMATIC-RESULTS
          OUT
        ::  MARKS: LIST OF THE MARKS OF THE FILES AT :PATH-TO-RENDER
        ::
        =/  MARKS=(LIST @TAS)
          %+  MURN  U.MAYBE-SCHEMATIC-RESULTS
          |=  [SUB-PATH=@TA RESULT=BUILD-RESULT]
          ^-  (UNIT @TAS)
          ::
          ?>  ?=([%SUCCESS %SCRY *] RESULT)
          ::
          =/  =ARCH  ;;(ARCH Q.Q.CAGE.RESULT)
          ::  IF IT'S A DIRECTORY, NOT A FILE, WE CAN'T LOAD IT
          ::
          ?~  FIL.ARCH
            ~
          [~ `@TAS`SUB-PATH]
        ::  SORT MARKS IN ALPHABETICAL ORDER
        ::
        =.  MARKS  (SORT MARKS LTE)
        ::  TRY TO CONVERT FILES TO THE DESTINATION MARK, IN ORDER
        ::
        =/  ALTS-BUILD=^BUILD
          ::
          :+  DATE.BUILD  %ALTS
          ^=  CHOICES  ^-  (LIST SCHEMATIC)
          ::
          %+  TURN  MARKS
          |=  MARK=TERM
          ^-  SCHEMATIC
          ::
          =/  FILE=RAIL  PATH-TO-RENDER(SPUR [MARK SPUR.PATH-TO-RENDER])
          ::
          [%CAST DISC.FILE RENDERER [%SCRY %C %X FILE]]
        ::
        =^  ALTS-RESULT  OUT  (DEPEND-ON ALTS-BUILD)
        ?~  ALTS-RESULT
          (RETURN-BLOCKS [ALTS-BUILD]~)
        ::
        ?:  ?=([~ %ERROR *] ALTS-RESULT)
          =/  =PATH  (RAIL-TO-PATH PATH-TO-RENDER)
          ?~  ERRORS
            %-  RETURN-ERROR
            :-  [%LEAF "FORD: %BAKE {<RENDERER>} ON {<PATH>} FAILED:"]
            MESSAGE.U.ALTS-RESULT
          ::
          =/  BRACES  [[' ' ' ' ~] ['{' ~] ['}' ~]]
          %-  RETURN-ERROR  :~
            [%LEAF "FORD: %BAKE {<RENDERER>} ON {<PATH>} FAILED:"]
            [%LEAF "AS-RENDERER"]
            [%ROSE BRACES ERRORS]
            [%LEAF "AS-MARK"]
            [%ROSE BRACES MESSAGE.U.ALTS-RESULT]
          ==
        ::
        ?>  ?=([~ %SUCCESS %ALTS *] ALTS-RESULT)
        ::
        =/  =BUILD-RESULT
          [%SUCCESS %BAKE (RESULT-TO-CAGE U.ALTS-RESULT)]
        ::
        (RETURN-RESULT BUILD-RESULT)
      --
    ::
    ++  MAKE-BUNT
      ~%  %MAKE-BUNT  ..^^$  ~
      |=  [=DISC MARK=TERM]
      ^-  BUILD-RECEIPT
      ::  RESOLVE PATH OF THE MARK DEFINITION FILE
      ::
      =/  PATH-BUILD=^BUILD  [DATE.BUILD [%PATH DISC %MAR MARK]]
      ::
      =^  PATH-RESULT  OUT  (DEPEND-ON PATH-BUILD)
      ?~  PATH-RESULT
        (RETURN-BLOCKS [PATH-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] PATH-RESULT)
        %-  RETURN-ERROR
        :_  MESSAGE.U.PATH-RESULT
        :-  %LEAF
        "FORD: %BUNT RESOLVING PATH FOR {<MARK>} ON {<DISC>} FAILED:"
      ::
      ?>  ?=([~ %SUCCESS %PATH *] PATH-RESULT)
      ::  BUILD THE MARK CORE FROM SOURCE
      ::
      =/  CORE-BUILD=^BUILD  [DATE.BUILD [%CORE RAIL.U.PATH-RESULT]]
      ::
      =^  CORE-RESULT  OUT  (DEPEND-ON CORE-BUILD)
      ?~  CORE-RESULT
        (RETURN-BLOCKS [CORE-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] CORE-RESULT)
        %-  RETURN-ERROR
        :_  MESSAGE.U.CORE-RESULT
        :-  %LEAF
        "FORD: %BUNT COMPILING MARK {<MARK>} ON {<DISC>} FAILED:"
      ::
      ?>  ?=([~ %SUCCESS %CORE *] CORE-RESULT)
      ::  EXTRACT THE SAMPLE FROM THE MARK CORE
      ::
      =/  MARK-VASE=VASE    VASE.U.CORE-RESULT
      ~|  %MARK-VASE
      =+  [SAMPLE-TYPE=P SAMPLE-VALUE=Q]:(SLOT 6 MARK-VASE)
      ::  IF SAMPLE IS WRAPPED IN A FACE, UNWRAP IT
      ::
      =?  SAMPLE-TYPE  ?=(%FACE -.SAMPLE-TYPE)  Q.SAMPLE-TYPE
      ::
      =/  =CAGE  [MARK SAMPLE-TYPE SAMPLE-VALUE]
      (RETURN-RESULT %SUCCESS %BUNT CAGE)
    ::
    ++  MAKE-CALL
      ~%  %MAKE-CALL  ..^^$  ~
      |=  [GATE=SCHEMATIC SAMPLE=SCHEMATIC]
      ^-  BUILD-RECEIPT
      ::
      =/  GATE-BUILD=^BUILD  [DATE.BUILD GATE]
      =^  GATE-RESULT    OUT  (DEPEND-ON GATE-BUILD)
      ::
      =/  SAMPLE-BUILD=^BUILD  [DATE.BUILD SAMPLE]
      =^  SAMPLE-RESULT  OUT  (DEPEND-ON SAMPLE-BUILD)
      ::
      =|  BLOCKS=(LIST ^BUILD)
      =?  BLOCKS  ?=(~ GATE-RESULT)    [[DATE.BUILD GATE] BLOCKS]
      =?  BLOCKS  ?=(~ SAMPLE-RESULT)  [[DATE.BUILD SAMPLE] BLOCKS]
      ?^  BLOCKS
        (RETURN-BLOCKS BLOCKS)
      ::
      ?<  ?=(~ GATE-RESULT)
      ?:  ?=([~ %ERROR *] GATE-RESULT)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %CALL FAILED TO BUILD GATE:"]
        MESSAGE.U.GATE-RESULT
      ::
      ?<  ?=(~ SAMPLE-RESULT)
      ?:  ?=([~ %ERROR *] SAMPLE-RESULT)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %CALL FAILED TO BUILD SAMPLE:"]
        MESSAGE.U.SAMPLE-RESULT
      ::
      =/  GATE-VASE=VASE    Q:(RESULT-TO-CAGE U.GATE-RESULT)
      =/  SAMPLE-VASE=VASE  Q:(RESULT-TO-CAGE U.SAMPLE-RESULT)
      ::  RUN %SLIT TO GET THE RESULTING TYPE OF CALCULATING THE GATE
      ::
      =/  SLIT-SCHEMATIC=SCHEMATIC  [%SLIT GATE-VASE SAMPLE-VASE]
      =/  SLIT-BUILD=^BUILD  [DATE.BUILD SLIT-SCHEMATIC]
      =^  SLIT-RESULT  OUT  (DEPEND-ON SLIT-BUILD)
      ?~  SLIT-RESULT
        (RETURN-BLOCKS [DATE.BUILD SLIT-SCHEMATIC]~)
      ::
      ?:  ?=([~ %ERROR *] SLIT-RESULT)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %CALL FAILED TYPE CALCULATION"]
        MESSAGE.U.SLIT-RESULT
      ::
      ?>  ?=([~ %SUCCESS %SLIT *] SLIT-RESULT)
      ::
      =/  =COMPILER-CACHE-KEY  [%CALL GATE-VASE SAMPLE-VASE]
      =^  CACHED-RESULT  OUT  (ACCESS-CACHE COMPILER-CACHE-KEY)
      ?^  CACHED-RESULT
        (RETURN-RESULT U.CACHED-RESULT)
      ::
      ?>  &(?=(^ Q.GATE-VASE) ?=(^ +.Q.GATE-VASE))
      =/  VAL
        (MONG [Q.GATE-VASE Q.SAMPLE-VASE] INTERCEPTED-SCRY)
      ::
      ?-    -.VAL
          %0
        (RETURN-RESULT %SUCCESS %CALL [TYPE.U.SLIT-RESULT P.VAL])
      ::
          %1
        =/  BLOCKED-PATHS=(LIST PATH)  ((HARD (LIST PATH)) P.VAL)
        (BLOCKED-PATHS-TO-RECEIPT %CALL BLOCKED-PATHS)
      ::
          %2
        (RETURN-ERROR [[%LEAF "FORD: %CALL EXECUTION FAILED:"] P.VAL])
      ==
    ::
    ++  MAKE-CAST
      ~%  %MAKE-CAST  ..^^$  ~
      |=  [=DISC MARK=TERM INPUT=SCHEMATIC]
      ^-  BUILD-RECEIPT
      ::
      =/  INPUT-BUILD=^BUILD  [DATE.BUILD INPUT]
      ::
      =^  INPUT-RESULT  OUT  (DEPEND-ON INPUT-BUILD)
      ?~  INPUT-RESULT
        (RETURN-BLOCKS [INPUT-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] INPUT-RESULT)
        %-  RETURN-ERROR
        :_  MESSAGE.U.INPUT-RESULT
        :-  %LEAF
        ;:  WELD
          "FORD: %CAST "  (TRIP MARK)  "ON ["  (TRIP (SCOT %P SHIP.DISC))
          " "  (TRIP DESK.DISC)  "] FAILED ON INPUT:"
        ==
      ::
      ?>  ?=([~ %SUCCESS *] INPUT-RESULT)
      ::
      =/  RESULT-CAGE=CAGE  (RESULT-TO-CAGE U.INPUT-RESULT)
      ::
      =/  TRANSLATION-PATH-BUILD=^BUILD
        [DATE.BUILD [%WALK DISC P.RESULT-CAGE MARK]]
      =^  TRANSLATION-PATH-RESULT  OUT
        (DEPEND-ON TRANSLATION-PATH-BUILD)
      ::
      ?~  TRANSLATION-PATH-RESULT
        (RETURN-BLOCKS [TRANSLATION-PATH-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] TRANSLATION-PATH-RESULT)
        %-  RETURN-ERROR
        :_  MESSAGE.U.TRANSLATION-PATH-RESULT
        :-  %LEAF
        ;:  WELD
          "FORD: %CAST "  (TRIP MARK)  "ON ["  (TRIP (SCOT %P SHIP.DISC))
          " "  (TRIP DESK.DISC)  "] FAILED:"
        ==
      ::
      ?>  ?=([~ %SUCCESS %WALK *] TRANSLATION-PATH-RESULT)
      ::
      =/  TRANSLATION-PATH=(LIST MARK-ACTION)
        RESULTS.U.TRANSLATION-PATH-RESULT
      ::
      |^  ^-  BUILD-RECEIPT
          ?~  TRANSLATION-PATH
            (RETURN-RESULT %SUCCESS %CAST RESULT-CAGE)
          ::
          =^  ACTION-RESULT  OUT
            =,  I.TRANSLATION-PATH
            ?-  -.I.TRANSLATION-PATH
              %GROW  (RUN-GROW SOURCE TARGET RESULT-CAGE)
              %GRAB  (RUN-GRAB SOURCE TARGET RESULT-CAGE)
            ==
          ::
          ?-    -.ACTION-RESULT
              %SUCCESS
            %_  $
              TRANSLATION-PATH  T.TRANSLATION-PATH
              RESULT-CAGE  CAGE.ACTION-RESULT
            ==
          ::
              %BLOCKS
            (RETURN-BLOCKS BLOCKS.ACTION-RESULT)
          ::
              %ERROR
            (RETURN-ERROR [LEAF+"FORD: FAILED TO %CAST" TANG.ACTION-RESULT])
        ==
      ::
      +=  ACTION-RESULT
        $%  ::  TRANSLATION WAS SUCCESSFUL AND HERE'S A CAGE FOR YOU
            [%SUCCESS =CAGE]
            ::  IT WAS AN ERROR. SORRY.
            [%ERROR =TANG]
            ::  WE BLOCK ON A BUILD
            [%BLOCKS BLOCKS=(LIST ^BUILD)]
        ==
      ::
      ++  RUN-GRAB
        |=  [SOURCE-MARK=TERM TARGET-MARK=TERM INPUT-CAGE=CAGE]
        ^-  [ACTION-RESULT _OUT]
        ::
        =/  MARK-PATH-BUILD=^BUILD
          [DATE.BUILD [%PATH DISC %MAR TARGET-MARK]]
        ::
        =^  MARK-PATH-RESULT  OUT
          (DEPEND-ON MARK-PATH-BUILD)
        ?~  MARK-PATH-RESULT
          [[%BLOCKS [MARK-PATH-BUILD]~] OUT]
        ::
        ?.  ?=([~ %SUCCESS %PATH *] MARK-PATH-RESULT)
          %-  CAST-WRAP-ERROR  :*
            SOURCE-MARK
            TARGET-MARK
            ;:  WELD
              "FORD: %CAST FAILED TO FIND PATH FOR MARK "  (TRIP SOURCE-MARK)
              " DURING +GRAB:"
            ==
            MARK-PATH-RESULT
          ==
        ::
        =/  MARK-CORE-BUILD=^BUILD  [DATE.BUILD [%CORE RAIL.U.MARK-PATH-RESULT]]
        ::
        =^  MARK-CORE-RESULT  OUT  (DEPEND-ON MARK-CORE-BUILD)
        ?~  MARK-CORE-RESULT
          [[%BLOCKS ~[MARK-CORE-BUILD]] OUT]
        ::  FIND +GRAB WITHIN THE DESTINATION MARK CORE
        ::
        =/  GRAB-BUILD=^BUILD
          :-  DATE.BUILD
          [%RIDE [%LIMB %GRAB] [%$ (RESULT-TO-CAGE U.MARK-CORE-RESULT)]]
        ::
        =^  GRAB-RESULT  OUT  (DEPEND-ON GRAB-BUILD)
        ?~  GRAB-RESULT
          [[%BLOCKS [GRAB-BUILD]~] OUT]
        ::
        ?.  ?=([~ %SUCCESS %RIDE *] GRAB-RESULT)
          =/  =PATH  (RAIL-TO-PATH RAIL.U.MARK-PATH-RESULT)
          %-  CAST-WRAP-ERROR  :*
            SOURCE-MARK
            TARGET-MARK
            :(WELD "FORD: %CAST FAILED TO RIDE " (SPUD PATH) " DURING +GRAB:")
            GRAB-RESULT
          ==
        ::  FIND AN ARM FOR THE INPUT'S MARK WITHIN THE +GRAB CORE
        ::
        =/  GRAB-MARK-BUILD=^BUILD
          :-  DATE.BUILD
          [%RIDE [%LIMB SOURCE-MARK] [%$ %NOUN VASE.U.GRAB-RESULT]]
        ::
        =^  GRAB-MARK-RESULT  OUT  (DEPEND-ON GRAB-MARK-BUILD)
        ?~  GRAB-MARK-RESULT
          [[%BLOCKS [GRAB-MARK-BUILD]~] OUT]
        ::
        ?.  ?=([~ %SUCCESS %RIDE *] GRAB-MARK-RESULT)
          =/  =PATH  (RAIL-TO-PATH RAIL.U.MARK-PATH-RESULT)
          %-  CAST-WRAP-ERROR  :*
            SOURCE-MARK
            TARGET-MARK
            :(WELD "FORD: %CAST FAILED TO RIDE " (SPUD PATH) " DURING +GRAB:")
            GRAB-MARK-RESULT
          ==
        ::  SLAM THE +MARK-NAME:GRAB GATE ON THE RESULT OF RUNNING :INPUT
        ::
        =/  CALL-BUILD=^BUILD
          :-  DATE.BUILD
          [%CALL GATE=[%$ %NOUN VASE.U.GRAB-MARK-RESULT] SAMPLE=[%$ INPUT-CAGE]]
        ::
        =^  CALL-RESULT  OUT  (DEPEND-ON CALL-BUILD)
        ?~  CALL-RESULT
          [[%BLOCKS [CALL-BUILD]~] OUT]
        ::
        ?.  ?=([~ %SUCCESS %CALL *] CALL-RESULT)
          =/  =PATH  (RAIL-TO-PATH RAIL.U.MARK-PATH-RESULT)
          %-  CAST-WRAP-ERROR  :*
            SOURCE-MARK
            TARGET-MARK
            :(WELD "FORD: %CAST FAILED TO CALL +GRAB ARM IN " (SPUD PATH) ":")
            CALL-RESULT
          ==
        ::
        [[%SUCCESS [MARK VASE.U.CALL-RESULT]] OUT]
      ::  +GROW: GROW FROM THE INPUT MARK TO THE DESTINATION MARK
      ::
      ++  RUN-GROW
        |=  [SOURCE-MARK=TERM TARGET-MARK=TERM INPUT-CAGE=CAGE]
        ^-  [ACTION-RESULT _OUT]
        ::
        =/  STARTING-MARK-PATH-BUILD=^BUILD
          [DATE.BUILD [%PATH DISC %MAR SOURCE-MARK]]
        ::
        =^  STARTING-MARK-PATH-RESULT  OUT
          (DEPEND-ON STARTING-MARK-PATH-BUILD)
        ?~  STARTING-MARK-PATH-RESULT
          [[%BLOCKS [STARTING-MARK-PATH-BUILD]~] OUT]
        ::
        ?.  ?=([~ %SUCCESS %PATH *] STARTING-MARK-PATH-RESULT)
          %-  CAST-WRAP-ERROR  :*
            SOURCE-MARK
            TARGET-MARK
            ;:  WELD
              "FORD: %CAST FAILED TO FIND PATH FOR MARK "  (TRIP SOURCE-MARK)
              " DURING +GROW:"
            ==
            STARTING-MARK-PATH-RESULT
          ==
        ::  GROW THE VALUE FROM THE INITIAL MARK TO THE FINAL MARK
        ::
        ::  REPLACE THE INPUT MARK'S SAMPLE WITH THE INPUT'S RESULT,
        ::  THEN FIRE THE MARK-NAME:GROW ARM TO PRODUCE A RESULT.
        ::
        =/  GROW-BUILD=^BUILD
          :-  DATE.BUILD
          :+  %RIDE
            FORMULA=`HOON`[%TSLD [%WING ~[TARGET-MARK]] [%WING ~[%GROW]]]
          ^=  SUBJECT
          ^-  SCHEMATIC
          :*  %MUTE
              ^-  SCHEMATIC
              [%CORE RAIL.U.STARTING-MARK-PATH-RESULT]
              ^=  MUTATIONS
              ^-  (LIST [WING SCHEMATIC])
              [[%& 6]~ [%$ INPUT-CAGE]]~
          ==
        ::
        =^  GROW-RESULT  OUT  (DEPEND-ON GROW-BUILD)
        ?~  GROW-RESULT
          [[%BLOCKS [GROW-BUILD]~] OUT]
        ::
        ?.  ?=([~ %SUCCESS %RIDE *] GROW-RESULT)
          =/  =PATH  (RAIL-TO-PATH RAIL.U.STARTING-MARK-PATH-RESULT)
          %-  CAST-WRAP-ERROR  :*
            SOURCE-MARK
            TARGET-MARK
            :(WELD "FORD: %CAST FAILED TO RIDE " (SPUD PATH) " DURING +GROW:")
            GROW-RESULT
          ==
        ::  MAKE SURE THE PRODUCT NESTS IN THE SAMPLE OF THE DESTINATION MARK
        ::
        =/  BUNT-BUILD=^BUILD  [DATE.BUILD [%BUNT DISC TARGET-MARK]]
        ::
        =^  BUNT-RESULT  OUT  (DEPEND-ON BUNT-BUILD)
        ?~  BUNT-RESULT
          [[%BLOCKS [BUNT-BUILD]~] OUT]
        ::
        ?.  ?=([~ %SUCCESS %BUNT *] BUNT-RESULT)
          %-  CAST-WRAP-ERROR  :*
            SOURCE-MARK
            TARGET-MARK
            :(WELD "FORD: %CAST FAILED TO BUNT " (TRIP TARGET-MARK) ":")
            BUNT-RESULT
          ==
        ::
        ?.  (~(NEST UT P.Q.CAGE.U.BUNT-RESULT) | P.VASE.U.GROW-RESULT)
          =*  SRC  SOURCE-MARK
          =*  DST  TARGET-MARK
          :_  OUT
          :-  %ERROR
          :_  ~
          :-  %LEAF
          ;:  WELD
            "FORD: %CAST FROM "  (TRIP SRC)  " TO "  (TRIP DST)
            " FAILED: NEST FAIL"
          ==
        ::
        [[%SUCCESS MARK VASE.U.GROW-RESULT] OUT]
      ::
      ++  CAST-WRAP-ERROR
        |=  $:  SOURCE-MARK=TERM
                TARGET-MARK=TERM
                DESCRIPTION=TAPE
                RESULT=(UNIT BUILD-RESULT)
            ==
        ^-  [ACTION-RESULT _OUT]
        ::
        ?>  ?=([~ %ERROR *] RESULT)
        ::
        :_  OUT
        :-  %ERROR
        :*  :-  %LEAF
            ;:  WELD
              "FORD: %CAST FAILED WHILE TRYING TO CAST FROM "
              (TRIP SOURCE-MARK)  " TO "  (TRIP TARGET-MARK)  ":"
            ==
            [%LEAF DESCRIPTION]
            MESSAGE.U.RESULT
        ==
      --
    ::
    ++  MAKE-CORE
      ~%  %MAKE-CORE  ..^^$  ~
      |=  SOURCE-PATH=RAIL
      ^-  BUILD-RECEIPT
      ::  CONVERT FILE AT :SOURCE-PATH TO A +SCAFFOLD
      ::
      =/  HOOD-BUILD=^BUILD  [DATE.BUILD [%HOOD SOURCE-PATH]]
      ::
      =^  HOOD-RESULT  OUT  (DEPEND-ON HOOD-BUILD)
      ?~  HOOD-RESULT
        (RETURN-BLOCKS [HOOD-BUILD]~)
      ::
      ?:  ?=(%ERROR -.U.HOOD-RESULT)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %CORE ON {<(RAIL-TO-PATH SOURCE-PATH)>} FAILED:"]
        MESSAGE.U.HOOD-RESULT
      ::  BUILD THE +SCAFFOLD INTO A PROGRAM
      ::
      ?>  ?=([%SUCCESS %HOOD *] U.HOOD-RESULT)
      ::
      =/  PLAN-BUILD=^BUILD
        [DATE.BUILD [%PLAN SOURCE-PATH `COIN`[%MANY ~] SCAFFOLD.U.HOOD-RESULT]]
      ::
      =^  PLAN-RESULT  OUT  (DEPEND-ON PLAN-BUILD)
      ?~  PLAN-RESULT
        (RETURN-BLOCKS [PLAN-BUILD]~)
      ::
      ?:  ?=(%ERROR -.U.PLAN-RESULT)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %CORE ON {<(RAIL-TO-PATH SOURCE-PATH)>} FAILED:"]
        MESSAGE.U.PLAN-RESULT
      ::
      ?>  ?=([%SUCCESS %PLAN *] U.PLAN-RESULT)
      (RETURN-RESULT %SUCCESS %CORE VASE.U.PLAN-RESULT)
    ::
    ++  MAKE-DIFF
      ~%  %MAKE-DIFF  ..^^$  ~
      |=  [=DISC START=SCHEMATIC END=SCHEMATIC]
      ^-  BUILD-RECEIPT
      ::  RUN BOTH INPUT SCHEMATICS AS AN AUTOCONS BUILD
      ::
      =/  SUB-BUILD=^BUILD  [DATE.BUILD [START END]]
      ::
      =^  SUB-RESULT  OUT  (DEPEND-ON SUB-BUILD)
      ?~  SUB-RESULT
        (RETURN-BLOCKS [SUB-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS ^ ^] SUB-RESULT)
        (WRAP-ERROR SUB-RESULT)
      ?.  ?=([%SUCCESS *] HEAD.U.SUB-RESULT)
        (WRAP-ERROR `HEAD.U.SUB-RESULT)
      ?.  ?=([%SUCCESS *] TAIL.U.SUB-RESULT)
        (WRAP-ERROR `TAIL.U.SUB-RESULT)
      ::
      =/  START-CAGE=CAGE  (RESULT-TO-CAGE HEAD.U.SUB-RESULT)
      =/  END-CAGE=CAGE    (RESULT-TO-CAGE TAIL.U.SUB-RESULT)
      ::  IF THE MARKS AREN'T THE SAME, WE CAN'T DIFF THEM
      ::
      ?.  =(P.START-CAGE P.END-CAGE)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %DIFF FAILED: MARK MISMATCH: %{<P.START-CAGE>} / %{<P.END-CAGE>}"
      ::  IF THE VALUES ARE THE SAME, THE DIFF IS NULL
      ::
      ?:  =(Q.Q.START-CAGE Q.Q.END-CAGE)
        =/  =BUILD-RESULT
          [%SUCCESS %DIFF [%NULL [%ATOM %N ~] ~]]
        ::
        (RETURN-RESULT BUILD-RESULT)
      ::
      =/  MARK-PATH-BUILD=^BUILD  [DATE.BUILD [%PATH DISC %MAR P.START-CAGE]]
      ::
      =^  MARK-PATH-RESULT  OUT  (DEPEND-ON MARK-PATH-BUILD)
      ?~  MARK-PATH-RESULT
        (RETURN-BLOCKS [MARK-PATH-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] MARK-PATH-RESULT)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %DIFF FAILED ON {<DISC>}:"]
        MESSAGE.U.MARK-PATH-RESULT
      ::
      ?>  ?=([~ %SUCCESS %PATH *] MARK-PATH-RESULT)
      ::
      =/  MARK-BUILD=^BUILD  [DATE.BUILD [%CORE RAIL.U.MARK-PATH-RESULT]]
      ::
      =^  MARK-RESULT  OUT  (DEPEND-ON MARK-BUILD)
      ?~  MARK-RESULT
        (RETURN-BLOCKS [MARK-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] MARK-RESULT)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %DIFF FAILED ON {<DISC>}:"]
        MESSAGE.U.MARK-RESULT
      ::
      ?>  ?=([~ %SUCCESS %CORE *] MARK-RESULT)
      ::
      ?.  (SLAB %GRAD P.VASE.U.MARK-RESULT)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %DIFF FAILED: %{<P.START-CAGE>} MARK HAS NO +GRAD ARM"
      ::
      =/  GRAD-BUILD=^BUILD
        [DATE.BUILD [%RIDE [%LIMB %GRAD] [%$ %NOUN VASE.U.MARK-RESULT]]]
      ::
      =^  GRAD-RESULT  OUT  (DEPEND-ON GRAD-BUILD)
      ?~  GRAD-RESULT
        (RETURN-BLOCKS [GRAD-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] GRAD-RESULT)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %DIFF FAILED ON {<DISC>}:"]
        MESSAGE.U.GRAD-RESULT
      ::
      ?>  ?=([~ %SUCCESS %RIDE *] GRAD-RESULT)
      ::  IF +GRAD PRODUCED A @TAS, CONVERT TO THAT MARK AND DIFF THOSE
      ::
      ?@  Q.VASE.U.GRAD-RESULT
        =/  MARK=(UNIT @TAS)  ((SAND %TAS) Q.VASE.U.GRAD-RESULT)
        ?~  MARK
          %-  RETURN-ERROR  :_  ~  :-  %LEAF
          "FORD: %DIFF FAILED: %{<P.START-CAGE>} MARK HAS INVALID +GRAD ARM"
        ::
        =/  DIFF-BUILD=^BUILD
          :-  DATE.BUILD
          :^    %DIFF
              DISC
            [%CAST DISC U.MARK [%$ START-CAGE]]
          [%CAST DISC U.MARK [%$ END-CAGE]]
        ::
        =^  DIFF-RESULT  OUT  (DEPEND-ON DIFF-BUILD)
        ?~  DIFF-RESULT
          (RETURN-BLOCKS [DIFF-BUILD]~)
        ::
        ?.  ?=([~ %SUCCESS %DIFF *] DIFF-RESULT)
          (WRAP-ERROR DIFF-RESULT)
        ::
        =/  =BUILD-RESULT
          [%SUCCESS %DIFF CAGE.U.DIFF-RESULT]
        ::
        (RETURN-RESULT BUILD-RESULT)
      ::  +GRAD PRODUCED A CELL, WHICH SHOULD BE A CORE WITH A +FORM ARM
      ::
      ?.  (SLAB %FORM P.VASE.U.GRAD-RESULT)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %DIFF FAILED: %{<P.START-CAGE>} MARK HAS NO +FORM:GRAB ARM"
      ::  THE +GRAB CORE SHOULD ALSO CONTAIN A +DIFF ARM
      ::
      ?.  (SLAB %DIFF P.VASE.U.GRAD-RESULT)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %DIFF FAILED: %{<P.START-CAGE>} MARK HAS NO +DIFF:GRAB ARM"
      ::
      =/  DIFF-BUILD=^BUILD
        :-  DATE.BUILD
        :+  %CALL
          ::
          ^=  GATE
          :+  %RIDE
            ::
            FORMULA=`HOON`[%TSLD [%WING ~[%DIFF]] [%WING ~[%GRAD]]]
          ::
          ^=  SUBJECT
          :+  %MUTE
            ::
            SUBJECT=`SCHEMATIC`[%$ %NOUN VASE.U.MARK-RESULT]
          ::
          ^=  MUTATIONS
          ^-  (LIST [WING SCHEMATIC])
          [[%& 6]~ [%$ START-CAGE]]~
        ::
        SAMPLE=`SCHEMATIC`[%$ END-CAGE]
      ::
      =^  DIFF-RESULT  OUT  (DEPEND-ON DIFF-BUILD)
      ?~  DIFF-RESULT
        (RETURN-BLOCKS [DIFF-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %CALL *] DIFF-RESULT)
        (WRAP-ERROR DIFF-RESULT)
      ::
      =/  FORM-BUILD=^BUILD
        [DATE.BUILD [%RIDE [%LIMB %FORM] [%$ %NOUN VASE.U.GRAD-RESULT]]]
      ::
      =^  FORM-RESULT  OUT  (DEPEND-ON FORM-BUILD)
      ?~  FORM-RESULT
        (RETURN-BLOCKS [FORM-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %RIDE *] FORM-RESULT)
        (WRAP-ERROR FORM-RESULT)
      ::
      =/  MARK=(UNIT @TAS)  ((SOFT @TAS) Q.VASE.U.FORM-RESULT)
      ?~  MARK
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %DIFF FAILED: INVALID +FORM RESULT: {(TEXT VASE.U.FORM-RESULT)}"
      ::
      =/  =BUILD-RESULT
        [%SUCCESS %DIFF [U.MARK VASE.U.DIFF-RESULT]]
      ::
      (RETURN-RESULT BUILD-RESULT)
    ::
    ++  MAKE-DUDE
      ~%  %MAKE-DUDE  ..^^$  ~
      |=  [ERROR=TANK ATTEMPT=SCHEMATIC]
      ^-  BUILD-RECEIPT
      ::
      =/  ATTEMPT-BUILD=^BUILD  [DATE.BUILD ATTEMPT]
      =^  ATTEMPT-RESULT  OUT  (DEPEND-ON ATTEMPT-BUILD)
      ?~  ATTEMPT-RESULT
        ::
        (RETURN-BLOCKS ~[[DATE.BUILD ATTEMPT]])
      ::
      ?.  ?=([%ERROR *] U.ATTEMPT-RESULT)
        (RETURN-RESULT U.ATTEMPT-RESULT)
      ::
      (RETURN-ERROR [ERROR MESSAGE.U.ATTEMPT-RESULT])
    ::
    ++  MAKE-HOOD
      ~%  %MAKE-HOOD  ..^^$  ~
      |=  SOURCE-RAIL=RAIL
      ^-  BUILD-RECEIPT
      ::
      =/  SCRY-BUILD=^BUILD  [DATE.BUILD [%SCRY [%C %X SOURCE-RAIL]]]
      =^  SCRY-RESULT  OUT  (DEPEND-ON SCRY-BUILD)
      ?~  SCRY-RESULT
        ::
        (RETURN-BLOCKS ~[SCRY-BUILD])
      ::
      ?:  ?=([~ %ERROR *] SCRY-RESULT)
        =/  =PATH  (RAIL-TO-PATH SOURCE-RAIL)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %HOOD FAILED FOR {<PATH>}:"]
        MESSAGE.U.SCRY-RESULT
      =+  AS-CAGE=(RESULT-TO-CAGE U.SCRY-RESULT)
      ::  HOON FILES MUST BE ATOMS TO PARSE
      ::
      ?.  ?=(@ Q.Q.AS-CAGE)
        =/  =PATH  (RAIL-TO-PATH SOURCE-RAIL)
        %-  RETURN-ERROR
        :_  ~
        :-  %LEAF
        "FORD: %HOOD: PATH {<PATH>} NOT AN ATOM"
      ::
      =/  SRC-BEAM=BEAM  [[SHIP.DISC DESK.DISC [%UD 0]] SPUR]:SOURCE-RAIL
      ::
      =/  =COMPILER-CACHE-KEY  [%HOOD SRC-BEAM Q.Q.AS-CAGE]
      =^  CACHED-RESULT  OUT  (ACCESS-CACHE COMPILER-CACHE-KEY)
      ?^  CACHED-RESULT
        (RETURN-RESULT U.CACHED-RESULT)
      ::
      =/  PARSED
        ((FULL (PARSE-SCAFFOLD SRC-BEAM)) [1 1] (TRIP Q.Q.AS-CAGE))
      ::
      ?~  Q.PARSED
        =/  =PATH  (RAIL-TO-PATH SOURCE-RAIL)
        %-  RETURN-ERROR
        :-  :-  %LEAF
            %+  WELD  "FORD: %HOOD: SYNTAX ERROR AT "
            "[{<P.P.PARSED>} {<Q.P.PARSED>}] IN {<PATH>}"
        ~
      ::
      (RETURN-RESULT %SUCCESS %HOOD P.U.Q.PARSED)
    ::
    ++  MAKE-JOIN
      ~%  %MAKE-JOIN  ..^^$  ~
      |=  [DISC=DISC MARK=TERM FIRST=SCHEMATIC SECOND=SCHEMATIC]
      ^-  BUILD-RECEIPT
      ::
      =/  INITIAL-BUILD=^BUILD
        [DATE.BUILD [FIRST SECOND] [%PATH DISC %MAR MARK]]
      ::
      =^  INITIAL-RESULT  OUT  (DEPEND-ON INITIAL-BUILD)
      ?~  INITIAL-RESULT
        (RETURN-BLOCKS [INITIAL-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS [%SUCCESS ^ ^] %SUCCESS %PATH *] INITIAL-RESULT)
        (WRAP-ERROR INITIAL-RESULT)
      ?.  ?=([%SUCCESS *] HEAD.HEAD.U.INITIAL-RESULT)
        (WRAP-ERROR `HEAD.HEAD.U.INITIAL-RESULT)
      ?.  ?=([%SUCCESS *] TAIL.HEAD.U.INITIAL-RESULT)
        (WRAP-ERROR `TAIL.HEAD.U.INITIAL-RESULT)
      ::
      =/  FIRST-CAGE=CAGE   (RESULT-TO-CAGE HEAD.HEAD.U.INITIAL-RESULT)
      =/  SECOND-CAGE=CAGE  (RESULT-TO-CAGE TAIL.HEAD.U.INITIAL-RESULT)
      =/  MARK-PATH=RAIL    RAIL.TAIL.U.INITIAL-RESULT
      ::  TODO: DUPLICATE LOGIC WITH +MAKE-PACT AND OTHERS
      ::
      =/  MARK-BUILD=^BUILD  [DATE.BUILD [%CORE MARK-PATH]]
      ::
      =^  MARK-RESULT  OUT  (DEPEND-ON MARK-BUILD)
      ?~  MARK-RESULT
        (RETURN-BLOCKS [MARK-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] MARK-RESULT)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %JOIN TO {<MARK>} ON {<DISC>} FAILED:"]
        MESSAGE.U.MARK-RESULT
      ::
      ?>  ?=([~ %SUCCESS %CORE *] MARK-RESULT)
      ::
      =/  MARK-VASE=VASE  VASE.U.MARK-RESULT
      ::
      ?.  (SLAB %GRAD P.MARK-VASE)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %JOIN FAILED: %{<MARK>} MARK HAS NO +GRAD ARM"
      ::
      =/  GRAD-BUILD=^BUILD
        [DATE.BUILD [%RIDE [%LIMB %GRAD] [%$ %NOUN MARK-VASE]]]
      ::
      =^  GRAD-RESULT  OUT  (DEPEND-ON GRAD-BUILD)
      ?~  GRAD-RESULT
        (RETURN-BLOCKS [GRAD-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] GRAD-RESULT)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %JOIN TO {<MARK>} ON {<DISC>} FAILED:"]
        MESSAGE.U.GRAD-RESULT
      ::
      ?>  ?=([~ %SUCCESS %RIDE *] GRAD-RESULT)
      ::
      =/  GRAD-VASE=VASE  VASE.U.GRAD-RESULT
      ::  IF +GRAD PRODUCED A MARK, DELEGATE %JOIN BEHAVIOR TO THAT MARK
      ::
      ?@  Q.GRAD-VASE
        ::  IF +GRAD PRODUCED A TERM, MAKE SURE IT'S A VALID MARK
        ::
        =/  GRAD-MARK=(UNIT TERM)  ((SAND %TAS) Q.GRAD-VASE)
        ?~  GRAD-MARK
          %-  RETURN-ERROR  :_  ~  :-  %LEAF
          "FORD: %JOIN FAILED: %{<MARK>} MARK INVALID +GRAD"
        ::  TODO: DOESN'T CATCH FULL CYCLES OF +GRAD ARMS, ONLY SIMPLE CASES
        ::
        ?:  =(U.GRAD-MARK MARK)
          %-  RETURN-ERROR  :_  ~  :-  %LEAF
          "FORD: %JOIN FAILED: %{<MARK>} MARK +GRAD ARM REFERS TO SELF"
        ::
        =/  JOIN-BUILD=^BUILD
          [DATE.BUILD [%JOIN DISC U.GRAD-MARK [%$ FIRST-CAGE] [%$ SECOND-CAGE]]]
        ::
        =^  JOIN-RESULT  OUT  (DEPEND-ON JOIN-BUILD)
        ?~  JOIN-RESULT
          (RETURN-BLOCKS [JOIN-BUILD]~)
        ::
        ?:  ?=([~ %ERROR *] JOIN-RESULT)
          %-  RETURN-ERROR
          :-  [%LEAF "FORD: %JOIN TO {<MARK>} ON {<DISC>} FAILED:"]
          MESSAGE.U.JOIN-RESULT
        ::
        ?>  ?=([~ %SUCCESS %JOIN *] JOIN-RESULT)
        ::
        (RETURN-RESULT U.JOIN-RESULT)
      ::  MAKE SURE THE +GRAD CORE HAS A +FORM ARM
      ::
      ?.  (SLAB %FORM P.GRAD-VASE)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %JOIN FAILED: NO +FORM:GRAD IN %{<MARK>} MARK"
      ::  MAKE SURE THE +GRAD CORE HAS A +JOIN ARM
      ::
      ?.  (SLAB %JOIN P.GRAD-VASE)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %JOIN FAILED: NO +JOIN:GRAD IN %{<MARK>} MARK"
      ::  FIRE THE +FORM:GRAD ARM, WHICH SHOULD PRODUCE A MARK
      ::
      =/  FORM-BUILD=^BUILD
        [DATE.BUILD [%RIDE [%LIMB %FORM] [%$ %NOUN GRAD-VASE]]]
      ::
      =^  FORM-RESULT  OUT  (DEPEND-ON FORM-BUILD)
      ?~  FORM-RESULT
        (RETURN-BLOCKS [FORM-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %RIDE *] FORM-RESULT)
        (WRAP-ERROR FORM-RESULT)
      ::
      =/  FORM-MARK=(UNIT TERM)  ((SOFT @TAS) Q.VASE.U.FORM-RESULT)
      ?~  FORM-MARK
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %JOIN FAILED: %{<MARK>} MARK INVALID +FORM:GRAD"
      ::  THE MARK PRODUCED BY +FORM:GRAD SHOULD MATCH BOTH DIFFS
      ::
      ?.  &(=(U.FORM-MARK P.FIRST-CAGE) =(U.FORM-MARK P.SECOND-CAGE))
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %JOIN FAILED: MARK MISMATCH"
      ::  IF THE DIFFS ARE IDENTICAL, JUST PRODUCE THE FIRST
      ::
      ?:  =(Q.Q.FIRST-CAGE Q.Q.SECOND-CAGE)
        (RETURN-RESULT %SUCCESS %JOIN FIRST-CAGE)
      ::  CALL THE +JOIN:GRAD GATE ON THE TWO DIFFS
      ::
      =/  DIFF-BUILD=^BUILD
        :-  DATE.BUILD
        :+  %CALL
          :+  %RIDE
            [%LIMB %JOIN]
          [%$ %NOUN GRAD-VASE]
        [%$ %NOUN (SLOP Q.FIRST-CAGE Q.SECOND-CAGE)]
      ::
      =^  DIFF-RESULT  OUT  (DEPEND-ON DIFF-BUILD)
      ?~  DIFF-RESULT
        (RETURN-BLOCKS [DIFF-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] DIFF-RESULT)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %JOIN TO {<MARK>} ON {<DISC>} FAILED:"]
        MESSAGE.U.DIFF-RESULT
      ::
      ?>  ?=([~ %SUCCESS %CALL *] DIFF-RESULT)
      ::  THE RESULT WAS A UNIT; IF `~`, USE %NULL MARK; OTHERWISE GRAB TAIL
      ::
      =/  =BUILD-RESULT
        :+  %SUCCESS  %JOIN
        ?@  Q.VASE.U.DIFF-RESULT
          [%NULL VASE.U.DIFF-RESULT]
        [U.FORM-MARK (SLOT 3 VASE.U.DIFF-RESULT)]
      ::
      (RETURN-RESULT BUILD-RESULT)
    ::
    ++  MAKE-LIST
      ~%  %MAKE-LIST  ..^^$  ~
      |=  SCHEMATICS=(LIST SCHEMATIC)
      ^-  BUILD-RECEIPT
      ::
      =/  KEY-AND-SCHEMATICS
        (TURN SCHEMATICS |=(=SCHEMATIC [~ SCHEMATIC]))
      ::  DEPEND ON BUILDS OF EACH SCHEMATIC
      ::
      =^  MAYBE-SCHEMATIC-RESULTS  OUT
        (PERFORM-SCHEMATICS "" KEY-AND-SCHEMATICS %IGNORE-ERRORS *~)
      ?~  MAYBE-SCHEMATIC-RESULTS
        OUT
      ::  RETURN ALL BUILDS
      ::
      =/  =BUILD-RESULT
        :+  %SUCCESS  %LIST
        ::  THE ROLL ABOVE IMPLICITLY FLOPPED THE RESULTS
        ::
        (FLOP (TURN U.MAYBE-SCHEMATIC-RESULTS TAIL))
      (RETURN-RESULT BUILD-RESULT)
    ::
    ++  MAKE-MASH
      ~%  %MAKE-MASH  ..^^$  ~
      |=  $:  DISC=DISC
              MARK=TERM
              FIRST=[DISC=DISC MARK=TERM =SCHEMATIC]
              SECOND=[DISC=DISC MARK=TERM =SCHEMATIC]
          ==
      ^-  BUILD-RECEIPT
      ::
      =/  INITIAL-BUILD=^BUILD
        [DATE.BUILD [SCHEMATIC.FIRST SCHEMATIC.SECOND] [%PATH DISC %MAR MARK]]
      ::
      =^  INITIAL-RESULT  OUT  (DEPEND-ON INITIAL-BUILD)
      ?~  INITIAL-RESULT
        (RETURN-BLOCKS [INITIAL-BUILD]~)
      ::  TODO: DUPLICATE LOGIC WITH +MAKE-JOIN
      ::
      ?.  ?=([~ %SUCCESS [%SUCCESS ^ ^] %SUCCESS %PATH *] INITIAL-RESULT)
        (WRAP-ERROR INITIAL-RESULT)
      ?.  ?=([%SUCCESS *] HEAD.HEAD.U.INITIAL-RESULT)
        (WRAP-ERROR `HEAD.HEAD.U.INITIAL-RESULT)
      ?.  ?=([%SUCCESS *] TAIL.HEAD.U.INITIAL-RESULT)
        (WRAP-ERROR `TAIL.HEAD.U.INITIAL-RESULT)
      ::
      =/  FIRST-CAGE=CAGE   (RESULT-TO-CAGE HEAD.HEAD.U.INITIAL-RESULT)
      =/  SECOND-CAGE=CAGE  (RESULT-TO-CAGE TAIL.HEAD.U.INITIAL-RESULT)
      =/  MARK-PATH=RAIL    RAIL.TAIL.U.INITIAL-RESULT
      ::  TODO: DUPLICATE LOGIC WITH +MAKE-PACT AND OTHERS
      ::
      =/  MARK-BUILD=^BUILD  [DATE.BUILD [%CORE MARK-PATH]]
      ::
      =^  MARK-RESULT  OUT  (DEPEND-ON MARK-BUILD)
      ?~  MARK-RESULT
        (RETURN-BLOCKS [MARK-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %CORE *] MARK-RESULT)
        (WRAP-ERROR MARK-RESULT)
      ::
      =/  MARK-VASE=VASE  VASE.U.MARK-RESULT
      ::
      ?.  (SLAB %GRAD P.MARK-VASE)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %MASH FAILED: %{<MARK>} MARK HAS NO +GRAD ARM"
      ::
      =/  GRAD-BUILD=^BUILD
        [DATE.BUILD [%RIDE [%LIMB %GRAD] [%$ %NOUN MARK-VASE]]]
      ::
      =^  GRAD-RESULT  OUT  (DEPEND-ON GRAD-BUILD)
      ?~  GRAD-RESULT
        (RETURN-BLOCKS [GRAD-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %RIDE *] GRAD-RESULT)
        (WRAP-ERROR GRAD-RESULT)
      ::
      =/  GRAD-VASE=VASE  VASE.U.GRAD-RESULT
      ::  IF +GRAD PRODUCED A MARK, DELEGATE %MASH BEHAVIOR TO THAT MARK
      ::
      ?@  Q.GRAD-VASE
        ::  IF +GRAD PRODUCED A TERM, MAKE SURE IT'S A VALID MARK
        ::
        =/  GRAD-MARK=(UNIT TERM)  ((SAND %TAS) Q.GRAD-VASE)
        ?~  GRAD-MARK
          %-  RETURN-ERROR  :_  ~  :-  %LEAF
          "FORD: %MASH FAILED: %{<MARK>} MARK INVALID +GRAD"
        ::
        =/  MASH-BUILD=^BUILD
          :-  DATE.BUILD
          :-  %MASH
          :^  DISC  U.GRAD-MARK
            [DISC.FIRST MARK.FIRST [%$ FIRST-CAGE]]
          [DISC.SECOND MARK.SECOND [%$ SECOND-CAGE]]
        ::
        =^  MASH-RESULT  OUT  (DEPEND-ON MASH-BUILD)
        ?~  MASH-RESULT
          (RETURN-BLOCKS [MASH-BUILD]~)
        ::
        ?.  ?=([~ %SUCCESS %MASH *] MASH-RESULT)
          (WRAP-ERROR MASH-RESULT)
        ::
        =/  =BUILD-RESULT
          [%SUCCESS %MASH CAGE.U.MASH-RESULT]
        ::
        (RETURN-RESULT BUILD-RESULT)
      ::
      ?.  (SLAB %FORM P.GRAD-VASE)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %MASH FAILED: %{<MARK>} MARK HAS NO +FORM:GRAD"
      ::
      ?.  (SLAB %MASH P.GRAD-VASE)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %MASH FAILED: %{<MARK>} MARK HAS NO +MASH:GRAD"
      ::
      =/  FORM-BUILD=^BUILD
        [DATE.BUILD [%RIDE [%LIMB %FORM] [%$ %NOUN GRAD-VASE]]]
      ::
      =^  FORM-RESULT  OUT  (DEPEND-ON FORM-BUILD)
      ?~  FORM-RESULT
        (RETURN-BLOCKS [FORM-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %RIDE *] FORM-RESULT)
        (WRAP-ERROR FORM-RESULT)
      ::
      =/  FORM-MARK=(UNIT TERM)  ((SOFT @TAS) Q.VASE.U.FORM-RESULT)
      ?~  FORM-MARK
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %MASH FAILED: %{<MARK>} MARK INVALID +FORM:GRAD"
      ::
      ?.  &(=(U.FORM-MARK P.FIRST-CAGE) =(U.FORM-MARK P.SECOND-CAGE))
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %MASH FAILED: MARK MISMATCH"
      ::
      ?:  =(Q.Q.FIRST-CAGE Q.Q.SECOND-CAGE)
        =/  =BUILD-RESULT
          [%SUCCESS %MASH [%NULL [%ATOM %N ~] ~]]
        ::
        (RETURN-RESULT BUILD-RESULT)
      ::  CALL THE +MASH:GRAD GATE ON TWO [SHIP DESK DIFF] TRIPLES
      ::
      =/  MASH-BUILD=^BUILD
        :-  DATE.BUILD
        :+  %CALL
          :+  %RIDE
            [%LIMB %MASH]
          [%$ %NOUN GRAD-VASE]
        :+  %$  %NOUN
        %+  SLOP
          ;:  SLOP
            [[%ATOM %P ~] SHIP.DISC.FIRST]
            [[%ATOM %TAS ~] DESK.DISC.FIRST]
            Q.FIRST-CAGE
          ==
        ;:  SLOP
          [[%ATOM %P ~] SHIP.DISC.SECOND]
          [[%ATOM %TAS ~] DESK.DISC.SECOND]
          Q.SECOND-CAGE
        ==
      ::
      =^  MASH-RESULT  OUT  (DEPEND-ON MASH-BUILD)
      ?~  MASH-RESULT
        (RETURN-BLOCKS [MASH-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %CALL *] MASH-RESULT)
        (WRAP-ERROR MASH-RESULT)
      ::
      =/  =BUILD-RESULT
        [%SUCCESS %MASH [U.FORM-MARK VASE.U.MASH-RESULT]]
      ::
      (RETURN-RESULT BUILD-RESULT)
    ::
    ++  MAKE-MUTE
      ~%  %MAKE-MUTE  ..^^$  ~
      |=  [SUBJECT=SCHEMATIC MUTATIONS=(LIST [=WING =SCHEMATIC])]
      ^-  BUILD-RECEIPT
      ::  RUN THE SUBJECT BUILD TO PRODUCE THE NOUN TO BE MUTATED
      ::
      =/  SUBJECT-BUILD=^BUILD  [DATE.BUILD SUBJECT]
      =^  SUBJECT-RESULT  OUT  (DEPEND-ON SUBJECT-BUILD)
      ?~  SUBJECT-RESULT
        (RETURN-BLOCKS [SUBJECT-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS *] SUBJECT-RESULT)
        (WRAP-ERROR SUBJECT-RESULT)
      ::
      =/  SUBJECT-CAGE=CAGE  (RESULT-TO-CAGE U.SUBJECT-RESULT)
      ::
      =/  SUBJECT-VASE=VASE  Q.SUBJECT-CAGE
      ::
      =^  MAYBE-SCHEMATIC-RESULTS  OUT
        %-  PERFORM-SCHEMATICS  :*
          "FORD: %MUTE CONTAINED FAILURES:"
          MUTATIONS
          %FAIL-ON-ERRORS
          *WING
        ==
      ?~  MAYBE-SCHEMATIC-RESULTS
        OUT
      ::  ALL BUILDS SUCCEEDED; RETRIEVE VASES FROM RESULTS
      ::
      =/  SUCCESSES=(LIST [=WING =VASE])
        %+  TURN  U.MAYBE-SCHEMATIC-RESULTS
        |=  [=WING RESULT=BUILD-RESULT]
        ^-  [^WING VASE]
        ::
        ?>  ?=([%SUCCESS *] RESULT)
        ::
        [WING Q:(RESULT-TO-CAGE RESULT)]
      ::  CREATE AND RUN A +BUILD TO APPLY ALL MUTATIONS IN ORDER
      ::
      =/  RIDE-BUILD=^BUILD
        :-  DATE.BUILD
        :+  %RIDE
          ::  FORMULA: A `%_` +HOON THAT APPLIES A LIST OF MUTATIONS
          ::
          ::    THE HOON ENDS UP LOOKING LIKE:
          ::    ```
          ::    %_  +2
          ::      WING-1  +6
          ::      WING-2  +14
          ::      ...
          ::    ==
          ::    ```
          ::
          ^=  FORMULA
          ^-  HOON
          :+  %CNCB  [%& 2]~
          =/  AXIS  3
          ::
          |-  ^-  (LIST [WING HOON])
          ?~  SUCCESSES  ~
          ::
          :-  [WING.I.SUCCESSES [%$ (PEG AXIS 2)]]
          $(SUCCESSES T.SUCCESSES, AXIS (PEG AXIS 3))
        ::  SUBJECT: LIST OF :SUBJECT-VASE AND MUTATIONS, AS LITERAL SCHEMATIC
        ::
        ::    THE SUBJECT ENDS UP AS A VASE OF SOMETHING LIKE THIS:
        ::    ```
        ::    :~  ORIGINAL-SUBJECT
        ::        MUTANT-1
        ::        MUTANT-2
        ::        ...
        ::    ==
        ::    ```
        ::
        ^=  SUBJECT  ^-  SCHEMATIC
        :+  %$  %NOUN
        ^-  VASE
        %+  SLOP  SUBJECT-VASE
        |-  ^-  VASE
        ?~  SUCCESSES  [[%ATOM %N ~] ~]
        ::
        (SLOP VASE.I.SUCCESSES $(SUCCESSES T.SUCCESSES))
      ::
      =^  RIDE-RESULT  OUT  (DEPEND-ON RIDE-BUILD)
      ?~  RIDE-RESULT
        (RETURN-BLOCKS [RIDE-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %RIDE *] RIDE-RESULT)
        (WRAP-ERROR RIDE-RESULT)
      ::
      =/  =BUILD-RESULT
        [%SUCCESS %MUTE P.SUBJECT-CAGE VASE.U.RIDE-RESULT]
      ::
      (RETURN-RESULT BUILD-RESULT)
    ::
    ++  MAKE-PACT
      ~%  %MAKE-PACT  ..^^$  ~
      |=  [DISC=DISC START=SCHEMATIC DIFF=SCHEMATIC]
      ^-  BUILD-RECEIPT
      ::  FIRST, BUILD THE INPUTS
      ::
      =/  INITIAL-BUILD=^BUILD  [DATE.BUILD START DIFF]
      ::
      =^  INITIAL-RESULT  OUT  (DEPEND-ON INITIAL-BUILD)
      ?~  INITIAL-RESULT
        (RETURN-BLOCKS [INITIAL-BUILD]~)
      ::
      ?>  ?=([~ %SUCCESS ^ ^] INITIAL-RESULT)
      =/  START-RESULT=BUILD-RESULT  HEAD.U.INITIAL-RESULT
      =/  DIFF-RESULT=BUILD-RESULT    TAIL.U.INITIAL-RESULT
      ::
      ?.  ?=(%SUCCESS -.START-RESULT)
        (WRAP-ERROR `START-RESULT)
      ?.  ?=(%SUCCESS -.DIFF-RESULT)
        (WRAP-ERROR `DIFF-RESULT)
      ::
      =/  START-CAGE=CAGE  (RESULT-TO-CAGE START-RESULT)
      =/  DIFF-CAGE=CAGE    (RESULT-TO-CAGE DIFF-RESULT)
      ::
      =/  START-MARK=TERM  P.START-CAGE
      =/  DIFF-MARK=TERM    P.DIFF-CAGE
      ::  LOAD THE STARTING MARK FROM THE FILESYSTEM
      ::
      =/  MARK-PATH-BUILD=^BUILD  [DATE.BUILD [%PATH DISC %MAR START-MARK]]
      ::
      =^  MARK-PATH-RESULT  OUT
        (DEPEND-ON MARK-PATH-BUILD)
      ::
      ?~  MARK-PATH-RESULT
        (RETURN-BLOCKS [MARK-PATH-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %PATH *] MARK-PATH-RESULT)
        (WRAP-ERROR MARK-PATH-RESULT)
      ::
      =/  MARK-BUILD=^BUILD  [DATE.BUILD [%CORE RAIL.U.MARK-PATH-RESULT]]
      ::
      =^  MARK-RESULT  OUT  (DEPEND-ON MARK-BUILD)
      ?~  MARK-RESULT
        (RETURN-BLOCKS [MARK-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %CORE *] MARK-RESULT)
        (WRAP-ERROR MARK-RESULT)
      ::
      =/  MARK-VASE=VASE  VASE.U.MARK-RESULT
      ::  FIRE THE +GRAD ARM OF THE MARK CORE
      ::
      ?.  (SLAB %GRAD P.MARK-VASE)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %PACT FAILED: %{<START-MARK>} MARK HAS NO +GRAD ARM"
      ::
      =/  GRAD-BUILD=^BUILD
        [DATE.BUILD [%RIDE [%LIMB %GRAD] [%$ %NOUN MARK-VASE]]]
      ::
      =^  GRAD-RESULT  OUT  (DEPEND-ON GRAD-BUILD)
      ?~  GRAD-RESULT
        (RETURN-BLOCKS [GRAD-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %RIDE *] GRAD-RESULT)
        (WRAP-ERROR GRAD-RESULT)
      ::
      =/  GRAD-VASE=VASE  VASE.U.GRAD-RESULT
      ::  +GRAD CAN PRODUCE A TERM OR A CORE
      ::
      ::    IF A MARK'S +GRAD ARM PRODUCES A MARK (AS A +TERM),
      ::    IT MEANS WE SHOULD USE THAT MARK'S MACHINERY TO RUN %PACT.
      ::    IN THIS WAY, A MARK CAN DELEGATE ITS PATCHING MACHINERY TO
      ::    ANOTHER MARK.
      ::
      ::    FIRST WE CAST :START-CAGE TO THE +GRAD MARK, THEN WE RUN
      ::    A NEW %PACT BUILD ON THE RESULT OF THAT, WHICH WILL USE THE
      ::    +GRAD MARK'S +GRAD ARM. FINALLY WE CAST THE %PACT RESULT BACK TO
      ::    :START-MARK, SINCE WE'RE TRYING TO PRODUCE A PATCHED VERSION OF
      ::    THE INITIAL MARKED VALUE (:START-CAGE).
      ::
      ?@  Q.GRAD-VASE
        ::  IF +GRAD PRODUCED A TERM, MAKE SURE IT'S A VALID MARK
        ::
        =/  GRAD-MARK=(UNIT TERM)  ((SAND %TAS) Q.GRAD-VASE)
        ?~  GRAD-MARK
          %-  RETURN-ERROR  :_  ~  :-  %LEAF
          "FORD: %PACT FAILED: %{<START-MARK>} MARK INVALID +GRAD"
        ::  CAST :START-CAGE TO :GRAD-MARK, %PACT THAT, THEN CAST BACK TO START
        ::
        =/  CAST-BUILD=^BUILD
          :-  DATE.BUILD
          :^  %CAST  DISC  START-MARK
          :^  %PACT  DISC
            :^  %CAST  DISC  U.GRAD-MARK
            [%$ START-CAGE]
          [%$ DIFF-CAGE]
        ::
        =^  CAST-RESULT  OUT  (DEPEND-ON CAST-BUILD)
        ?~  CAST-RESULT
          (RETURN-BLOCKS [CAST-BUILD]~)
        ::
        ?.  ?=([~ %SUCCESS %CAST *] CAST-RESULT)
          (WRAP-ERROR CAST-RESULT)
        ::
        =/  =BUILD-RESULT
          [%SUCCESS %PACT CAGE.U.CAST-RESULT]
        ::
        (RETURN-RESULT BUILD-RESULT)
      ::  +GRAD PRODUCED A CORE; MAKE SURE IT HAS A +FORM ARM
      ::
      ::    +GRAD CAN PRODUCE A CORE CONTAINING +PACT AND +FORM
      ::    ARMS. +FORM:GRAD, WHICH PRODUCES A MARK (AS A TERM), IS USED
      ::    TO VERIFY THAT THE DIFF IS OF THE CORRECT MARK.
      ::
      ::    +PACT:GRAD PRODUCES A GATE THAT GETS SLAMMED WITH THE DIFF
      ::    AS ITS SAMPLE AND PRODUCES A MUTANT VERSION OF :START-CAGE
      ::    BY APPLYING THE DIFF.
      ::
      ?.  (SLAB %FORM P.GRAD-VASE)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %PACT FAILED: NO +FORM:GRAD IN %{<START-MARK>} MARK"
      ::  WE ALSO NEED A +PACT ARM IN THE +GRAD CORE
      ::
      ?.  (SLAB %PACT P.GRAD-VASE)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %PACT FAILED: NO +PACT:GRAD IN %{<START-MARK>} MARK"
      ::  FIRE THE +FORM ARM IN THE CORE PRODUCED BY +GRAD
      ::
      =/  FORM-BUILD=^BUILD
        [DATE.BUILD [%RIDE [%LIMB %FORM] [%$ %NOUN GRAD-VASE]]]
      ::
      =^  FORM-RESULT  OUT  (DEPEND-ON FORM-BUILD)
      ?~  FORM-RESULT
        (RETURN-BLOCKS [FORM-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %RIDE *] FORM-RESULT)
        (WRAP-ERROR FORM-RESULT)
      ::  +FORM:GRAD SHOULD PRODUCE A MARK
      ::
      =/  FORM-MARK=(UNIT @TAS)  ((SOFT @TAS) Q.VASE.U.FORM-RESULT)
      ?~  FORM-MARK
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %PACT FAILED: %{<START-MARK>} MARK INVALID +FORM:GRAD"
      ::  MARK PRODUCED BY +FORM:GRAD NEEDS TO MATCH THE MARK OF THE DIFF
      ::
      ?.  =(U.FORM-MARK DIFF-MARK)
        %-  RETURN-ERROR  :_  ~  :-  %LEAF
        "FORD: %PACT FAILED: %{<START-MARK>} MARK INVALID +FORM:GRAD"
      ::  CALL +PACT:GRAD ON THE DIFF
      ::
      =/  PACT-BUILD=^BUILD
        :-  DATE.BUILD
        :+  %CALL
          ^-  SCHEMATIC
          :+  %RIDE
            [%TSLD [%LIMB %PACT] [%LIMB %GRAD]]
          ^-  SCHEMATIC
          :+  %MUTE
            ^-  SCHEMATIC
            [%$ %NOUN MARK-VASE]
          ^-  (LIST [WING SCHEMATIC])
          [[%& 6]~ [%$ START-CAGE]]~
        ^-  SCHEMATIC
        [%$ DIFF-CAGE]
      ::
      =^  PACT-RESULT  OUT  (DEPEND-ON PACT-BUILD)
      ?~  PACT-RESULT
        (RETURN-BLOCKS [PACT-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %CALL *] PACT-RESULT)
        (WRAP-ERROR PACT-RESULT)
      ::
      =/  =BUILD-RESULT
        [%SUCCESS %PACT START-MARK VASE.U.PACT-RESULT]
      ::
      (RETURN-RESULT BUILD-RESULT)
    ::
    ++  MAKE-PATH
      ~%  %MAKE-PATH  ..^^$  ~
      |=  [DISC=DISC PREFIX=@TAS RAW-PATH=@TAS]
      ^-  BUILD-RECEIPT
      ::  POSSIBLE-SPURS: FLOPPED PATHS TO WHICH :RAW-PATH COULD RESOLVE
      ::
      =/  POSSIBLE-SPURS=(LIST SPUR)  (TURN (SEGMENTS RAW-PATH) FLOP)
      ::  RAILS-AND-SCHEMATICS: SCRYS TO CHECK EACH PATH IN :POSSIBLE-PATHS
      ::
      =/  RAILS-AND-SCHEMATICS=(LIST [=RAIL =SCHEMATIC])
        %+  TURN  POSSIBLE-SPURS
        |=  POSSIBLE-SPUR=SPUR
        ^-  [RAIL SCHEMATIC]
        ::  FULL-SPUR: WRAP :POSSIBLE-SPUR WITH :PREFIX AND /HOON SUFFIX
        ::
        =/  FULL-SPUR=SPUR  :(WELP /HOON POSSIBLE-SPUR /[PREFIX])
        ::
        :-  [DISC FULL-SPUR]
        [%SCRY %C %X `RAIL`[DISC FULL-SPUR]]
      ::  DEPEND ON BUILDS OF EACH SCHEMATIC
      ::
      =^  MAYBE-SCHEMATIC-RESULTS  OUT
        %-  PERFORM-SCHEMATICS  :*
          ;:  WELD
            "FORD: %PATH RESOLUTION OF "  (TRIP RAW-PATH)  "AT PREFIX "
            (TRIP PREFIX)  " CONTAINED FAILURES:"
          ==
          RAILS-AND-SCHEMATICS
          %FILTER-ERRORS
          *RAIL
        ==
      ?~  MAYBE-SCHEMATIC-RESULTS
        OUT
      ::  MATCHES: BUILDS THAT COMPLETED WITH A SUCCESSFUL RESULT
      ::
      =/  MATCHES  U.MAYBE-SCHEMATIC-RESULTS
      ::  IF NO MATCHES, ERROR OUT
      ::
      ?~  MATCHES
        =/  =BEAM
          [[SHIP.DISC DESK.DISC [%DA DATE.BUILD]] /HOON/[RAW-PATH]/[PREFIX]]
        ::
        %-  RETURN-ERROR
        :_  ~
        :-  %LEAF
        (WELD "%PATH: NO MATCHES FOR " (SPUD (EN-BEAM BEAM)))
      ::  IF EXACTLY ONE PATH MATCHES, SUCCEED WITH THE MATCHING PATH
      ::
      ?:  ?=([* ~] MATCHES)
        (RETURN-RESULT %SUCCESS %PATH KEY.I.MATCHES)
      ::  MULTIPLE PATHS MATCHED; ERROR OUT
      ::
      %-  RETURN-ERROR
      ::
      :-  [%LEAF "MULTIPLE MATCHES FOR %PATH: "]
      ::  TMI; CAST :MATCHES BACK TO +LIST
      ::
      %+  ROLL  `_U.MAYBE-SCHEMATIC-RESULTS`MATCHES
      |=  [[KEY=RAIL RESULT=BUILD-RESULT] MESSAGE=TANG]
      ^-  TANG
      ::  BEAM: RECONSTRUCT REQUEST FROM :KID'S SCHEMATIC AND DATE
      ::
      =/  =BEAM  [[SHIP.DISC DESK.DISC [%DA DATE.BUILD]] SPUR.KEY]
      ::
      [[%LEAF (SPUD (EN-BEAM BEAM))] MESSAGE]
    ::
    ++  MAKE-PLAN
      ~%  %MAKE-PLAN  ..^^$  ~
      |=  [PATH-TO-RENDER=RAIL QUERY-STRING=COIN =SCAFFOLD]
      ^-  BUILD-RECEIPT
      ::  BLOCKS: ACCUMULATOR FOR BLOCKED SUB-BUILDS
      ::
      =|  BLOCKS=(LIST ^BUILD)
      ::  ERROR-MESSAGE: ACCUMULATOR FOR FAILED SUB-BUILDS
      ::
      =|  ERROR-MESSAGE=TANG
      ::
      |^  ::  IMPORTS: STRUCTURE AND LIBRARY +CABLES, WITH %SUR/%LIB PREFIXES
          ::
          =/  IMPORTS=(LIST [PREFIX=?(%SUR %LIB) =CABLE])
            %+  WELP
              (TURN STRUCTURES.SCAFFOLD |=(CABLE [%SUR +<]))
            (TURN LIBRARIES.SCAFFOLD |=(CABLE [%LIB +<]))
          ::  PATH-BUILDS: %PATH SUB-BUILDS TO RESOLVE IMPORT PATHS
          ::
          =/  PATH-BUILDS  (GATHER-PATH-BUILDS IMPORTS)
          ::
          =^  PATH-RESULTS  ..$  (RESOLVE-BUILDS PATH-BUILDS)
          ?^  BLOCKS
            (RETURN-BLOCKS BLOCKS)
          ::
          ?^  ERROR-MESSAGE
            (RETURN-ERROR ERROR-MESSAGE)
          ::  TMI; REMOVE TYPE SPECIALIZATIONS
          ::
          =>  .(BLOCKS *(LIST ^BUILD), ERROR-MESSAGE *TANG)
          ::  CORE-BUILDS: %CORE SUB-BUILDS TO PRODUCE LIBRARY VASES
          ::
          =/  CORE-BUILDS  (GATHER-CORE-BUILDS PATH-RESULTS)
          ::
          =^  CORE-RESULTS  ..$  (RESOLVE-BUILDS CORE-BUILDS)
          ?^  BLOCKS
            (RETURN-BLOCKS BLOCKS)
          ::
          ?^  ERROR-MESSAGE
            (RETURN-ERROR ERROR-MESSAGE)
          ::  REEF-BUILD: %REEF BUILD TO PRODUCE STANDARD LIBRARY
          ::
          =/  REEF-BUILD=^BUILD  [DATE.BUILD [%REEF DISC.PATH-TO-RENDER]]
          ::
          =^  REEF-RESULT  OUT  (DEPEND-ON REEF-BUILD)
          ?~  REEF-RESULT
            (RETURN-BLOCKS [REEF-BUILD]~)
          ::
          ?.  ?=([~ %SUCCESS %REEF *] REEF-RESULT)
            (WRAP-ERROR REEF-RESULT)
          ::  SUBJECT: TUPLE OF IMPORTS AND STANDARD LIBRARY
          ::
          =/  SUBJECT=VASE
            (LINK-IMPORTS IMPORTS VASE.U.REEF-RESULT CORE-RESULTS)
          ::  TMI; REMOVE TYPE SPECIALIZATIONS
          ::
          =>  .(BLOCKS *(LIST ^BUILD), ERROR-MESSAGE *TANG)
          ::  ITERATE OVER EACH CRANE
          ::
          =^  CRANE-RESULT  ..$
            (COMPOSE-CRANES [%NOUN SUBJECT] CRANES.SCAFFOLD)
          ?:  ?=(%ERROR -.CRANE-RESULT)
            (RETURN-ERROR MESSAGE.CRANE-RESULT)
          ?:  ?=(%BLOCK -.CRANE-RESULT)
            (RETURN-BLOCKS BUILDS.CRANE-RESULT)
          ::  COMBINED-HOON: SOURCE HOONS CONDENSED INTO A SINGLE +HOON
          ::
          =/  COMBINED-HOON=HOON  [%TSSG SOURCES.SCAFFOLD]
          ::  COMPILE :COMBINED-HOON AGAINST :SUBJECT
          ::
          =/  COMPILE=^BUILD
            [DATE.BUILD [%RIDE COMBINED-HOON [%$ SUBJECT.CRANE-RESULT]]]
          ::
          =^  COMPILED  OUT  (DEPEND-ON COMPILE)
          ::  COMPILATION BLOCKED; PRODUCE BLOCK ON SUB-BUILD
          ::
          ?~  COMPILED
            (RETURN-BLOCKS ~[COMPILE])
          ::  COMPILATION FAILED; ERROR OUT
          ::
          ?.  ?=([~ %SUCCESS %RIDE *] COMPILED)
            (WRAP-ERROR COMPILED)
          ::  COMPILATION SUCCEEDED: PRODUCE RESULTING +VASE
          ::
          (RETURN-RESULT %SUCCESS %PLAN VASE.U.COMPILED)
      ::  +COMPOSE-RESULT: THE RESULT OF A SINGLE COMPOSITION
      ::
      +=  COMPOSE-RESULT
        $%  [%SUBJECT SUBJECT=CAGE]
            [%BLOCK BUILDS=(LIST ^BUILD)]
            [%ERROR MESSAGE=TANG]
        ==
      ::  +COMPOSE-CRANES: RUNS EACH CRANE AND COMPOSES THE RESULTS
      ::
      ::    FOR EACH CRANE IN :CRANES, RUNS IT AND COMPOSES ITS RESULT INTO A
      ::    NEW SUBJECT, WHICH IS RETURNED IF THERE ARE NO ERRORS OR BLOCKS.
      ::
      ++  COMPOSE-CRANES
        |=  [SUBJECT=CAGE CRANES=(LIST CRANE)]
        ^-  $:  COMPOSE-RESULT
                _..COMPOSE-CRANES
            ==
        ::
        ?~  CRANES
          [[%SUBJECT SUBJECT] ..COMPOSE-CRANES]
        ::
        =^  RESULT  ..COMPOSE-CRANES  (RUN-CRANE SUBJECT I.CRANES)
        ?+    -.RESULT  [RESULT ..COMPOSE-CRANES]
        ::
            %SUBJECT
          $(CRANES T.CRANES, SUBJECT [%NOUN (SLOP Q.SUBJECT.RESULT Q.SUBJECT)])
        ==
      ::  +RUN-CRANE: RUNS AN INDIVIDUAL :CRANE AGAINST :SUBJECT
      ::
      ++  RUN-CRANE
        |=  [SUBJECT=CAGE =CRANE]
        ^-  COMPOSE-CRANES
        ::
        |^  ?-  -.CRANE
              %FSSG  (RUN-FSSG +.CRANE)
              %FSBC  (RUN-FSBC +.CRANE)
              %FSBR  (RUN-FSBR +.CRANE)
              %FSTS  (RUN-FSTS +.CRANE)
              %FSCM  (RUN-FSCM +.CRANE)
              %FSPM  (RUN-FSPM +.CRANE)
              %FSCB  (RUN-FSCB +.CRANE)
              %FSDT  (RUN-FSDT +.CRANE)
              %FSSM  (RUN-FSSM +.CRANE)
              %FSCL  (RUN-FSCL +.CRANE)
              %FSKT  (RUN-FSKT +.CRANE)
              %FSTR  (RUN-FSTR +.CRANE)
              %FSZP  (RUN-FSZP +.CRANE)
              %FSZY  (RUN-FSZY +.CRANE)
            ==
        ::  +RUN-FSSG: RUNS THE `/~` RUNE
        ::
        ++  RUN-FSSG
          |=  =HOON
          ^-  COMPOSE-CRANES
          ::
          =/  RIDE-BUILD=^BUILD
            [DATE.BUILD [%RIDE HOON [%$ SUBJECT]]]
          =^  RIDE-RESULT  OUT  (DEPEND-ON RIDE-BUILD)
          ?~  RIDE-RESULT
            [[%BLOCK [RIDE-BUILD]~] ..RUN-CRANE]
          ?:  ?=([~ %ERROR *] RIDE-RESULT)
            [[%ERROR [LEAF+"/~ FAILED: " MESSAGE.U.RIDE-RESULT]] ..RUN-CRANE]
          ?>  ?=([~ %SUCCESS %RIDE *] RIDE-RESULT)
          [[%SUBJECT %NOUN VASE.U.RIDE-RESULT] ..RUN-CRANE]
        ::  +RUN-FSBC: RUNS THE `/$` RUNE
        ::
        ++  RUN-FSBC
          |=  =HOON
          ^-  COMPOSE-CRANES
          ::
          =/  QUERY-COMPILE-BUILD=^BUILD
            [DATE.BUILD [%RIDE ((JOCK |) QUERY-STRING) [%$ %NOUN !>(~)]]]
          =^  QUERY-COMPILE-RESULT  OUT  (DEPEND-ON QUERY-COMPILE-BUILD)
          ?~  QUERY-COMPILE-RESULT
            [[%BLOCK [QUERY-COMPILE-BUILD]~] ..RUN-CRANE]
          ?:  ?=([~ %ERROR *] QUERY-COMPILE-RESULT)
            :-  [%ERROR [LEAF+"/; FAILED: " MESSAGE.U.QUERY-COMPILE-RESULT]]
            ..RUN-CRANE
          ?>  ?=([~ %SUCCESS %RIDE *] QUERY-COMPILE-RESULT)
          ::
          =/  =BEAM
            =,  PATH-TO-RENDER
            [[SHIP.DISC DESK.DISC [%DA DATE.BUILD]] SPUR]
          =+  ARGUMENTS=(SLOP !>(BEAM) VASE.U.QUERY-COMPILE-RESULT)
          ::
          =/  CALL-BUILD=^BUILD
            [DATE.BUILD [%CALL [%RIDE HOON [%$ SUBJECT]] [%$ %NOUN ARGUMENTS]]]
          =^  CALL-RESULT  OUT  (DEPEND-ON CALL-BUILD)
          ?~  CALL-RESULT
            [[%BLOCK [CALL-BUILD]~] ..RUN-CRANE]
          ?:  ?=([~ %ERROR *] CALL-RESULT)
            [[%ERROR [LEAF+"/; FAILED: " MESSAGE.U.CALL-RESULT]] ..RUN-CRANE]
          ?>  ?=([~ %SUCCESS %CALL *] CALL-RESULT)
          ::
          [[%SUBJECT %NOUN VASE.U.CALL-RESULT] ..RUN-CRANE]
        ::  +RUN-FSBR: RUNS THE `/|` RUNE
        ::
        ++  RUN-FSBR
          |=  CHOICES=(LIST ^CRANE)
          ^-  COMPOSE-CRANES
          ::
          ?~  CHOICES
            [[%ERROR [LEAF+"/| FAILED: OUT OF OPTIONS"]~] ..RUN-CRANE]
          ::
          =^  CHILD  ..RUN-CRANE  (RUN-CRANE SUBJECT I.CHOICES)
          ?.  ?=([%ERROR *] CHILD)
            [CHILD ..RUN-CRANE]
          $(CHOICES T.CHOICES)
        ::  +RUN-FSTS: RUNS THE `/=` RUNE
        ::
        ++  RUN-FSTS
          |=  [FACE=TERM SUB-CRANE=^CRANE]
          ^-  COMPOSE-CRANES
          ::
          =^  CHILD  ..RUN-CRANE  (RUN-CRANE SUBJECT SUB-CRANE)
          ?.  ?=([%SUBJECT *] CHILD)
            [CHILD ..RUN-CRANE]
          :_  ..RUN-CRANE
          :*  %SUBJECT
              P.SUBJECT.CHILD
              [[%FACE FACE P.Q.SUBJECT.CHILD] Q.Q.SUBJECT.CHILD]
          ==
        ::  +RUN-FSCM: RUNS THE `/,` RUNE
        ::
        ++  RUN-FSCM
          |=  CASES=(LIST [=SPUR CRANE=^CRANE])
          ^-  COMPOSE-CRANES
          ::
          ?~  CASES
            [[%ERROR [LEAF+"/, FAILED: NO MATCH"]~] ..RUN-CRANE]
          ::
          ?.  .=  SPUR.I.CASES
              (SCAG (LENT SPUR.I.CASES) (FLOP SPUR.PATH-TO-RENDER))
            $(CASES T.CASES)
          ::
          (RUN-CRANE SUBJECT CRANE.I.CASES)
        ::  +RUN-FSPM: RUNS THE `/&` RUNE
        ::
        ++  RUN-FSPM
          |=  [MARKS=(LIST MARK) SUB-CRANE=^CRANE]
          ^-  COMPOSE-CRANES
          ::
          =^  CHILD  ..RUN-CRANE  (RUN-CRANE SUBJECT SUB-CRANE)
          ?.  ?=([%SUBJECT *] CHILD)
            [CHILD ..RUN-CRANE]
          ::
          =/  CAST-BUILD=^BUILD
            :-  DATE.BUILD
            |-
            ^-  SCHEMATIC
            ?~  MARKS
              ::  TODO: IF WE WERE KEEPING TRACK OF THE MARK ACROSS RUNES, THIS
              ::  WOULDN'T HAVE %NOUN HERE. THIS IS A CASE WHERE IT MIGHT MATTER.
              ::
              [%$ SUBJECT.CHILD]
            [%CAST DISC.SOURCE-RAIL.SCAFFOLD I.MARKS $(MARKS T.MARKS)]
          =^  CAST-RESULT  OUT  (DEPEND-ON CAST-BUILD)
          ?~  CAST-RESULT
            [[%BLOCK [CAST-BUILD]~] ..RUN-CRANE]
          ::
          ?:  ?=([~ %ERROR *] CAST-RESULT)
            [[%ERROR [LEAF+"/& FAILED: " MESSAGE.U.CAST-RESULT]] ..RUN-CRANE]
          ?>  ?=([~ %SUCCESS %CAST *] CAST-RESULT)
          ::
          [[%SUBJECT CAGE.U.CAST-RESULT] ..RUN-CRANE]
        ::  +RUN-FSCB: RUNS THE `/_` RUNE
        ::
        ++  RUN-FSCB
          |=  SUB-CRANE=^CRANE
          ^-  COMPOSE-CRANES
          ::  PERFORM A SCRY TO GET THE CONTENTS OF +PATH-TO-RENDER
          ::
          =/  TOPLEVEL-BUILD=^BUILD
            [DATE.BUILD [%SCRY [%C %Y PATH-TO-RENDER]]]
          ::
          =^  TOPLEVEL-RESULT  OUT  (DEPEND-ON TOPLEVEL-BUILD)
          ?~  TOPLEVEL-RESULT
            [[%BLOCK ~[TOPLEVEL-BUILD]] ..RUN-CRANE]
          ::
          ?:  ?=([~ %ERROR *] TOPLEVEL-RESULT)
            :-  [%ERROR [LEAF+"/_ FAILED: " MESSAGE.U.TOPLEVEL-RESULT]]
            ..RUN-CRANE
          ?>  ?=([~ %SUCCESS %SCRY *] TOPLEVEL-RESULT)
          ::
          =/  TOPLEVEL-ARCH=ARCH  ;;(ARCH Q.Q.CAGE.U.TOPLEVEL-RESULT)
          ::  SUB-PATH: EACH POSSIBLE SUB-DIRECTORY TO CHECK
          ::
          =/  SUB-PATHS=(LIST @TA)
            (TURN ~(TAP BY DIR.TOPLEVEL-ARCH) HEAD)
          ::  FOR EACH DIRECTORY IN :TOPLEVEL-ARCH, ISSUE A SUB-BUILD
          ::
          =/  SUB-BUILDS=(LIST ^BUILD)
            %+  TURN  SUB-PATHS
            |=  SUB=@TA
            ^-  ^BUILD
            :-  DATE.BUILD
            [%SCRY [%C %Y PATH-TO-RENDER(SPUR [SUB SPUR.PATH-TO-RENDER])]]
          ::  RESULTS: ACCUMULATOR FOR RESULTS OF SUB-BUILDS
          ::
          =|  $=  RESULTS
              (LIST [KID=^BUILD SUB-PATH=@TA RESULTS=(UNIT BUILD-RESULT)])
          ::  RESOLVE ALL THE :SUB-BUILDS
          ::
          =/  SUBS-RESULTS
            |-  ^+  [RESULTS OUT]
            ?~  SUB-BUILDS  [RESULTS OUT]
            ?>  ?=(^ SUB-PATHS)
            ::
            =/  KID=^BUILD  I.SUB-BUILDS
            =/  SUB-PATH=@TA  I.SUB-PATHS
            ::
            =^  RESULT  OUT  (DEPEND-ON KID)
            =.  RESULTS  [[KID SUB-PATH RESULT] RESULTS]
            ::
            $(SUB-BUILDS T.SUB-BUILDS, SUB-PATHS T.SUB-PATHS)
          ::  APPLY MUTATIONS FROM DEPENDING ON SUB-BUILDS
          ::
          =:  RESULTS  -.SUBS-RESULTS
              OUT      +.SUBS-RESULTS
          ==
          ::  SPLIT :RESULTS INTO COMPLETED :MADES AND INCOMPLETE :BLOCKS
          ::
          =+  ^=  SPLIT-RESULTS
              (SKID RESULTS |=([* * R=(UNIT BUILD-RESULT)] ?=(^ R)))
          ::
          =/  MADES=_RESULTS   -.SPLIT-RESULTS
          =/  BLOCKS=_RESULTS  +.SPLIT-RESULTS
          ::  IF ANY BUILDS BLOCKED, PRODUCE THEM ALL IN %BLOCKS
          ::
          ?^  BLOCKS
            [[%BLOCK (TURN `_RESULTS`BLOCKS HEAD)] ..RUN-CRANE]
          ::  FIND THE FIRST ERROR AND RETURN IT IF EXISTS
          ::
          =/  ERRORS=_RESULTS
            %+  SKIM  RESULTS
            |=  [* * R=(UNIT BUILD-RESULT)]
            ?=([~ %ERROR *] R)
          ?^  ERRORS
            ?>  ?=([~ %ERROR *] RESULTS.I.ERRORS)
            [[%ERROR MESSAGE.U.RESULTS.I.ERRORS] ..RUN-CRANE]
          ::  GET A LIST OF VALID SUB-PATHS
          ::
          ::    :RESULTS IS NOW A LIST OF THE :BUILD-RESULT OF %CY ON EACH PATH
          ::    IN :TOPLEVEL-ARCH. WHAT WE WANT IS TO NOW FILTER THIS LIST SO
          ::    THAT WE FILTER FILES OUT.
          ::
          =/  SUB-PATHS=(LIST [=RAIL SUB-PATH=@TA])
            %+  MURN  RESULTS
            |=  [BUILD=^BUILD SUB-PATH=@TA RESULT=(UNIT BUILD-RESULT)]
            ^-  (UNIT [RAIL @TA])
            ::
            ?>  ?=([@DA %SCRY %C %Y *] BUILD)
            ?>  ?=([~ %SUCCESS %SCRY *] RESULT)
            =/  =ARCH  ;;(ARCH Q.Q.CAGE.U.RESULT)
            ::
            ?~  DIR.ARCH
              ~
            `[RAIL.RESOURCE.SCHEMATIC.BUILD SUB-PATH]
          ::  KEEP TRACK OF THE ORIGINAL VALUE SO WE CAN RESET IT
          ::
          =/  OLD-PATH-TO-RENDER  PATH-TO-RENDER
          ::  APPLY EACH OF THE FILTERED :SUB-PATHS TO THE :SUB-CRANE.
          ::
          =^  CRANE-RESULTS  ..RUN-CRANE
            %+  ROLL  SUB-PATHS
            |=  $:  [=RAIL SUB-PATH=@TA]
                    $=  ACCUMULATOR
                    [(LIST [SUB-PATH=@TA =COMPOSE-RESULT]) _..RUN-CRANE]
                ==
            =.  ..RUN-CRANE  +.ACCUMULATOR
            =.  PATH-TO-RENDER  RAIL
            =^  RESULT  ..RUN-CRANE  (RUN-CRANE SUBJECT SUB-CRANE)
            [[[SUB-PATH RESULT] -.ACCUMULATOR] ..RUN-CRANE]
          ::  SET :PATH-TO-RENDER BACK
          ::
          =.  PATH-TO-RENDER  OLD-PATH-TO-RENDER
          ::  IF ANY SUB-CRANES ERROR, RETURN THE FIRST ERROR
          ::
          =/  ERROR-LIST=(LIST [@TA =COMPOSE-RESULT])
            %+  SKIM  CRANE-RESULTS
            |=  [@TA =COMPOSE-RESULT]
            =(%ERROR -.COMPOSE-RESULT)
          ::
          ?^  ERROR-LIST
            [COMPOSE-RESULT.I.ERROR-LIST ..RUN-CRANE]
          ::  IF ANY SUB-CRANES BLOCK, RETURN ALL BLOCKS
          ::
          =/  BLOCK-LIST=(LIST ^BUILD)
            =|  BLOCK-LIST=(LIST ^BUILD)
            |-
            ^+  BLOCK-LIST
            ?~  CRANE-RESULTS
              BLOCK-LIST
            ?.  ?=(%BLOCK -.COMPOSE-RESULT.I.CRANE-RESULTS)
              $(CRANE-RESULTS T.CRANE-RESULTS)
            =.  BLOCK-LIST
              (WELD BUILDS.COMPOSE-RESULT.I.CRANE-RESULTS BLOCK-LIST)
            $(CRANE-RESULTS T.CRANE-RESULTS)
          ::
          ?^  BLOCK-LIST
            [[%BLOCK BLOCK-LIST] ..RUN-CRANE]
          ::  PUT THE DATA IN MAP ORDER
          ::
          =/  RESULT-MAP=(MAP @TA VASE)
            %-  MY
            %+  TURN  CRANE-RESULTS
            |=  [PATH=@TA =COMPOSE-RESULT]
            ^-  (PAIR @TA VASE)
            ::
            ?>  ?=([%SUBJECT *] COMPOSE-RESULT)
            [PATH Q.SUBJECT.COMPOSE-RESULT]
          ::  CONVERT THE MAP INTO A FLAT FORMAT FOR RETURN
          ::
          ::    THIS STEP FLATTENS THE VALUES OUT OF THE MAP FOR RETURN. LET'S
          ::    SAY WE'RE DOING A /_ OVER A DIRECTORY OF FILES THAT JUST HAVE A
          ::    SINGLE @UD IN THEM. WE WANT THE RETURN VALUE OF /_ TO HAVE THE
          ::    NEST IN (MAP @TA @UD) INSTEAD OF RETURNING A (MAP @TA VASE).
          ::
          =/  AS-VASE=VASE
            |-
            ^-  VASE
            ::
            ?~  RESULT-MAP
              [[%ATOM %N `0] 0]
            ::
            %+  SLOP
              (SLOP [[%ATOM %TA ~] P.N.RESULT-MAP] Q.N.RESULT-MAP)
            (SLOP $(RESULT-MAP L.RESULT-MAP) $(RESULT-MAP R.RESULT-MAP))
          ::
          [[%SUBJECT %NOUN AS-VASE] ..RUN-CRANE]
        ::  +RUN-FSDT: RUNS THE `/.` RUNE
        ::
        ++  RUN-FSDT
          |=  SUB-CRANES=(LIST ^CRANE)
          ^-  COMPOSE-CRANES
          ::
          =^  LIST-RESULTS  ..RUN-CRANE
            %+  ROLL  SUB-CRANES
            |=  $:  SUB-CRANE=^CRANE
                    ACCUMULATOR=[(LIST COMPOSE-RESULT) _..RUN-CRANE]
                ==
            =.  ..RUN-CRANE  +.ACCUMULATOR
            =^  RESULT  ..RUN-CRANE  (RUN-CRANE SUBJECT SUB-CRANE)
            [[RESULT -.ACCUMULATOR] ..RUN-CRANE]
          ::  IF ANY SUB-CRANES ERROR, RETURN THE FIRST ERROR
          ::
          =/  ERROR-LIST=(LIST COMPOSE-RESULT)
            %+  SKIM  LIST-RESULTS
            |=  =COMPOSE-RESULT
            =(%ERROR -.COMPOSE-RESULT)
          ::
          ?^  ERROR-LIST
            [I.ERROR-LIST ..RUN-CRANE]
          ::  IF ANY SUB-CRANES BLOCK, RETURN ALL BLOCKS
          ::
          =/  BLOCK-LIST=(LIST ^BUILD)
            =|  BLOCK-LIST=(LIST ^BUILD)
            |-
            ^+  BLOCK-LIST
            ?~  LIST-RESULTS
              BLOCK-LIST
            ?.  ?=(%BLOCK -.I.LIST-RESULTS)
              $(LIST-RESULTS T.LIST-RESULTS)
            =.  BLOCK-LIST  (WELD BUILDS.I.LIST-RESULTS BLOCK-LIST)
            $(LIST-RESULTS T.LIST-RESULTS)
          ::
          ?^  BLOCK-LIST
            [[%BLOCK BLOCK-LIST] ..RUN-CRANE]
          ::  CONCATENATE ALL THE RESULTS TOGETHER WITH NULL TERMINATION
          ::
          =.  LIST-RESULTS  (FLOP LIST-RESULTS)
          ::
          =/  FINAL-RESULT=VASE
            |-
            ^-  VASE
            ?~  LIST-RESULTS
              [[%ATOM %N `~] 0]
            ?>  ?=(%SUBJECT -.I.LIST-RESULTS)
            (SLOP Q.SUBJECT.I.LIST-RESULTS $(LIST-RESULTS T.LIST-RESULTS))
          ::
          [[%SUBJECT %NOUN FINAL-RESULT] ..RUN-CRANE]
        ::  +RUN-FSSM: RUNS THE `/;` RUNE
        ::
        ++  RUN-FSSM
          |=  [=HOON SUB-CRANE=^CRANE]
          ^-  COMPOSE-CRANES
          ::
          =^  CHILD  ..RUN-CRANE  (RUN-CRANE SUBJECT SUB-CRANE)
          ?.  ?=([%SUBJECT *] CHILD)
            [CHILD ..RUN-CRANE]
          ::
          =/  CALL-BUILD=^BUILD
            [DATE.BUILD [%CALL [%RIDE HOON [%$ SUBJECT]] [%$ SUBJECT.CHILD]]]
          =^  CALL-RESULT  OUT  (DEPEND-ON CALL-BUILD)
          ?~  CALL-RESULT
            [[%BLOCK [CALL-BUILD]~] ..RUN-CRANE]
          ?:  ?=([~ %ERROR *] CALL-RESULT)
            [[%ERROR [LEAF+"/; FAILED: " MESSAGE.U.CALL-RESULT]] ..RUN-CRANE]
          ?>  ?=([~ %SUCCESS %CALL *] CALL-RESULT)
          ::
          [[%SUBJECT %NOUN VASE.U.CALL-RESULT] ..RUN-CRANE]
        ::  +RUN-FSCL: RUNS THE `/:` RUNE
        ::
        ++  RUN-FSCL
          |=  [=TRUSS SUB-CRANE=^CRANE]
          ^-  COMPOSE-CRANES
          ::
          =/  BEAM-TO-RENDER=BEAM
            [[SHIP.DISC DESK.DISC %UD 0] SPUR]:PATH-TO-RENDER
          ::
          =/  HOON-PARSER  (VANG & (EN-BEAM BEAM-TO-RENDER))
          ::
          =+  TUZ=(POSH:HOON-PARSER TRUSS)
          ?~  TUZ
            [[%ERROR [LEAF+"/: FAILED: BAD TUSK: {<TRUSS>}"]~] ..RUN-CRANE]
          =+  PAX=(PLEX:HOON-PARSER %CLSG U.TUZ)
          ?~  PAX
            [[%ERROR [LEAF+"/: FAILED: BAD PATH: {<U.TUZ>}"]~] ..RUN-CRANE]
          =+  BEM=(DE-BEAM U.PAX)
          ?~  BEM
            [[%ERROR [LEAF+"/: FAILED: BAD BEAM: {<U.PAX>}"]~] ..RUN-CRANE]
          ::
          =.  PATH-TO-RENDER  [[P Q] S]:U.BEM
          (RUN-CRANE SUBJECT SUB-CRANE)
        ::  +RUN-FSKT: RUNS THE `/^` RUNE
        ::
        ++  RUN-FSKT
          |=  [=SPEC SUB-CRANE=^CRANE]
          ^-  COMPOSE-CRANES
          ::
          =^  CHILD  ..RUN-CRANE  (RUN-CRANE SUBJECT SUB-CRANE)
          ?.  ?=([%SUBJECT *] CHILD)
            [CHILD ..RUN-CRANE]
          ::
          =/  BUNT-BUILD=^BUILD
            [DATE.BUILD [%RIDE [%KTTR SPEC] [%$ SUBJECT]]]
          =^  BUNT-RESULT  OUT  (DEPEND-ON BUNT-BUILD)
          ?~  BUNT-RESULT
            [[%BLOCK [BUNT-BUILD]~] ..RUN-CRANE]
          ?:  ?=([~ %ERROR *] BUNT-RESULT)
            [[%ERROR [LEAF+"/^ FAILED: " MESSAGE.U.BUNT-RESULT]] ..RUN-CRANE]
          ?>  ?=([~ %SUCCESS %RIDE *] BUNT-RESULT)
          ::
          ?.  (~(NEST UT P.VASE.U.BUNT-RESULT) | P.Q.SUBJECT.CHILD)
            [[%ERROR [LEAF+"/^ FAILED: NEST-FAIL"]~] ..RUN-CRANE]
          :_  ..RUN-CRANE
          [%SUBJECT %NOUN [P.VASE.U.BUNT-RESULT Q.Q.SUBJECT.CHILD]]
        ::  +RUN-FSTR: RUNS THE `/*` RUNE
        ::
        ::    TODO: SOME DUPLICATE CODE WITH +RUN-FSCB
        ::
        ++  RUN-FSTR
          |=  SUB-CRANE=^CRANE
          ^-  COMPOSE-CRANES
          ::
          =/  TREE-BUILD=^BUILD
            [DATE.BUILD [%SCRY [%C %T PATH-TO-RENDER]]]
          ::
          =^  TREE-RESULT  OUT  (DEPEND-ON TREE-BUILD)
          ?~  TREE-RESULT
            [[%BLOCK ~[TREE-BUILD]] ..RUN-CRANE]
          ::
          ?:  ?=([~ %ERROR *] TREE-RESULT)
            :-  [%ERROR [%LEAF "/* FAILED: "] MESSAGE.U.TREE-RESULT]
            ..RUN-CRANE
          ?>  ?=([~ %SUCCESS %SCRY *] TREE-RESULT)
          ::
          =/  FILE-LIST=(LIST PATH)  ;;((LIST PATH) Q.Q.CAGE.U.TREE-RESULT)
          ::  TRIM FILE EXTENSIONS OFF THE FILE PATHS
          ::
          ::    THIS IS PRETTY UGLY, BUT FORD EXPECTS :PATH-TO-RENDER NOT TO
          ::    HAVE A FILE EXTENSION, SO WE NEED TO TRIM IT OFF EACH PATH.
          ::
          =.  FILE-LIST
            ::  DEDUPLICATE SINCE MULTIPLE FILES COULD SHARE A TRIMMED PATH
            ::
            =-  ~(TAP IN (~(GAS IN *(SET PATH)) `(LIST PATH)`-))
            %+  TURN  FILE-LIST
            |=  =PATH
            ^+  PATH
            (SCAG (SUB (LENT PATH) 1) PATH)
          ::
          =/  OLD-PATH-TO-RENDER  PATH-TO-RENDER
          ::  APPLY EACH OF THE PATHS IN :FILE-LIST TO THE :SUB-CRANE
          ::
          =^  CRANE-RESULTS  ..RUN-CRANE
            %+  ROLL  FILE-LIST
            |=  $:  =PATH
                    $=  ACCUMULATOR
                    [(LIST [=PATH =COMPOSE-RESULT]) _..RUN-CRANE]
                ==
            =.  ..RUN-CRANE  +.ACCUMULATOR
            =.  SPUR.PATH-TO-RENDER  (FLOP PATH)
            ::
            =^  RESULT  ..RUN-CRANE  (RUN-CRANE SUBJECT SUB-CRANE)
            [[[PATH RESULT] -.ACCUMULATOR] ..RUN-CRANE]
          ::
          =.  PATH-TO-RENDER  OLD-PATH-TO-RENDER
          ::  IF ANY SUB-CRANES ERROR, RETURN THE FIRST ERROR
          ::
          =/  ERROR-LIST=(LIST [=PATH =COMPOSE-RESULT])
            %+  SKIM  CRANE-RESULTS
            |=  [=PATH =COMPOSE-RESULT]
            =(%ERROR -.COMPOSE-RESULT)
          ::
          ?^  ERROR-LIST
            [COMPOSE-RESULT.I.ERROR-LIST ..RUN-CRANE]
          ::  IF ANY SUB-CRANES BLOCK, RETURN ALL BLOCKS
          ::
          =/  BLOCK-LIST=(LIST ^BUILD)
            =|  BLOCK-LIST=(LIST ^BUILD)
            |-  ^+  BLOCK-LIST
            ?~  CRANE-RESULTS  BLOCK-LIST
            ::
            ?.  ?=(%BLOCK -.COMPOSE-RESULT.I.CRANE-RESULTS)
              $(CRANE-RESULTS T.CRANE-RESULTS)
            =.  BLOCK-LIST
              (WELD BUILDS.COMPOSE-RESULT.I.CRANE-RESULTS BLOCK-LIST)
            ::
            $(CRANE-RESULTS T.CRANE-RESULTS)
          ::
          ?^  BLOCK-LIST
            [[%BLOCK BLOCK-LIST] ..RUN-CRANE]
          ::
          =/  RESULT-MAP=(MAP PATH VASE)
            %-  MY
            %+  TURN  CRANE-RESULTS
            |=  [=PATH =COMPOSE-RESULT]
            ^-  (PAIR ^PATH VASE)
            ::
            ?>  ?=(%SUBJECT -.COMPOSE-RESULT)
            [PATH Q.SUBJECT.COMPOSE-RESULT]
          ::
          =/  AS-VASE
            =/  PATH-TYPE  -:!>(*PATH)
            |-  ^-  VASE
            ?~  RESULT-MAP  [[%ATOM %N `0] 0]
            ::
            %+  SLOP
              (SLOP [PATH-TYPE P.N.RESULT-MAP] Q.N.RESULT-MAP)
            (SLOP $(RESULT-MAP L.RESULT-MAP) $(RESULT-MAP R.RESULT-MAP))
          ::
          [[%SUBJECT %NOUN AS-VASE] ..RUN-CRANE]
        ::  +RUN-FSZP: RUNS THE `/!MARK/` "RUNE"
        ::
        ++  RUN-FSZP
          |=  =MARK
          ^-  COMPOSE-CRANES
          ::
          =/  HOON-PATH=RAIL
            =,  PATH-TO-RENDER
            [DISC [%HOON SPUR]]
          ::
          =/  HOOD-BUILD=^BUILD  [DATE.BUILD [%HOOD HOON-PATH]]
          =^  HOOD-RESULT  OUT  (DEPEND-ON HOOD-BUILD)
          ?~  HOOD-RESULT
            [[%BLOCK [HOOD-BUILD]~] ..RUN-CRANE]
          ?:  ?=([~ %ERROR *] HOOD-RESULT)
            [[%ERROR [LEAF+"/! FAILED: " MESSAGE.U.HOOD-RESULT]] ..RUN-CRANE]
          ?>  ?=([~ %SUCCESS %HOOD *] HOOD-RESULT)
          ::
          =/  PLAN-BUILD=^BUILD
            :-  DATE.BUILD
            [%PLAN PATH-TO-RENDER QUERY-STRING SCAFFOLD.U.HOOD-RESULT]
          =^  PLAN-RESULT  OUT  (DEPEND-ON PLAN-BUILD)
          ?~  PLAN-RESULT
            [[%BLOCK [PLAN-BUILD]~] ..RUN-CRANE]
          ?:  ?=([~ %ERROR *] PLAN-RESULT)
            [[%ERROR [LEAF+"/! FAILED: " MESSAGE.U.PLAN-RESULT]] ..RUN-CRANE]
          ?>  ?=([~ %SUCCESS %PLAN *] PLAN-RESULT)
          ::  IF :MARK IS %NOUN, DON'T PERFORM MARK TRANSLATION; JUST RETURN
          ::
          ::    IF WE WERE TO VERIFY THE PRODUCT TYPE WITH %NOUN, THIS WOULD
          ::    CAST TO *, WHICH WOULD OVERWRITE :VASE.U.PLAN-RESULT'S ACTUAL
          ::    PRODUCT TYPE
          ::
          ?:  =(%NOUN MARK)
            [[%SUBJECT %NOUN VASE.U.PLAN-RESULT] ..RUN-CRANE]
          ::
          =/  VALE-BUILD=^BUILD
            :-  DATE.BUILD
            [%VALE DISC.SOURCE-RAIL.SCAFFOLD MARK Q.VASE.U.PLAN-RESULT]
          =^  VALE-RESULT  OUT  (DEPEND-ON VALE-BUILD)
          ?~  VALE-RESULT
            [[%BLOCK [VALE-BUILD]~] ..RUN-CRANE]
          ?:  ?=([~ %ERROR *] VALE-RESULT)
            [[%ERROR [LEAF+"/! FAILED: " MESSAGE.U.VALE-RESULT]] ..RUN-CRANE]
          ?>  ?=([~ %SUCCESS %VALE *] VALE-RESULT)
          ::
          [[%SUBJECT CAGE.U.VALE-RESULT] ..RUN-CRANE]
        ::  +RUN-FSZY: RUNS THE `/MARK/` "RUNE"
        ::
        ++  RUN-FSZY
          |=  =MARK
          ^-  COMPOSE-CRANES
          ::
          =/  BAKE-BUILD=^BUILD
            :-  DATE.BUILD
            [%BAKE MARK QUERY-STRING PATH-TO-RENDER]
          =^  BAKE-RESULT  OUT  (DEPEND-ON BAKE-BUILD)
          ?~  BAKE-RESULT
            [[%BLOCK [BAKE-BUILD]~] ..RUN-CRANE]
          ?:  ?=([~ %ERROR *] BAKE-RESULT)
            :_  ..RUN-CRANE
            [%ERROR [LEAF+"/{(TRIP MARK)}/ FAILED: " MESSAGE.U.BAKE-RESULT]]
          ?>  ?=([~ %SUCCESS %BAKE *] BAKE-RESULT)
          ::
          [[%SUBJECT CAGE.U.BAKE-RESULT] ..RUN-CRANE]
        --
      ::  +GATHER-PATH-BUILDS: PRODUCE %PATH BUILDS TO RESOLVE IMPORT PATHS
      ::
      ++  GATHER-PATH-BUILDS
        |=  IMPORTS=(LIST [PREFIX=?(%SUR %LIB) =CABLE])
        ^-  (LIST ^BUILD)
        ::
        %+  TURN  IMPORTS
        |=  [PREFIX=?(%SUR %LIB) =CABLE]
        ^-  ^BUILD
        [DATE.BUILD [%PATH DISC.SOURCE-RAIL.SCAFFOLD PREFIX FILE-PATH.CABLE]]
      ::  +RESOLVE-BUILDS: RUN A LIST OF BUILDS AND COLLECT RESULTS
      ::
      ::    IF A BUILD BLOCKS, PUT ITS +TANG IN :ERROR-MESSAGE AND STOP.
      ::    ALL BUILDS THAT BLOCK GET PUT IN :BLOCKS. RESULTS OF
      ::    SUCCESSFUL BUILDS ARE PRODUCED IN :RESULTS.
      ::
      ++  RESOLVE-BUILDS
        =|  RESULTS=(LIST BUILD-RESULT)
        |=  BUILDS=(LIST ^BUILD)
        ^+  [RESULTS ..^$]
        ::
        ?~  BUILDS
          [RESULTS ..^$]
        ::
        =^  RESULT  OUT  (DEPEND-ON I.BUILDS)
        ?~  RESULT
          =.  BLOCKS  [I.BUILDS BLOCKS]
          $(BUILDS T.BUILDS)
        ::
        ?.  ?=(%SUCCESS -.U.RESULT)
          =.  ERROR-MESSAGE  [[%LEAF "%PLAN FAILED: "] MESSAGE.U.RESULT]
          [RESULTS ..^$]
        ::
        =.  RESULTS  [U.RESULT RESULTS]
        $(BUILDS T.BUILDS)
      ::  +GATHER-CORE-BUILDS: PRODUCE %CORE BUILDS FROM RESOLVED PATHS
      ::
      ++  GATHER-CORE-BUILDS
        |=  PATH-RESULTS=(LIST BUILD-RESULT)
        ^-  (LIST ^BUILD)
        %+  TURN  PATH-RESULTS
        |=  RESULT=BUILD-RESULT
        ^-  ^BUILD
        ::
        ?>  ?=([%SUCCESS %PATH *] RESULT)
        ::
        [DATE.BUILD [%CORE RAIL.RESULT]]
      ::  +LINK-IMPORTS: LINK LIBRARIES AND STRUCTURES WITH STANDARD LIBRARY
      ::
      ::    PREPENDS EACH LIBRARY VASE ONTO THE STANDARD LIBRARY VASE.
      ::    WRAPS A FACE AROUND EACH LIBRARY TO PREVENT NAMESPACE LEAKAGE
      ::    UNLESS IMPORTED AS *LIB-NAME.
      ::
      ++  LINK-IMPORTS
        |=  $:  IMPORTS=(LIST [?(%LIB %SUR) =CABLE])
                REEF=VASE
                CORE-RESULTS=(LIST BUILD-RESULT)
            ==
        ^-  VASE
        ::
        =/  SUBJECT=VASE  REEF
        ::
        =/  CORE-VASES=(LIST VASE)
          %+  TURN  CORE-RESULTS
          |=  RESULT=BUILD-RESULT
          ^-  VASE
          ?>  ?=([%SUCCESS %CORE *] RESULT)
          VASE.RESULT
        ::  LINK STRUCTURES AND LIBRARIES INTO A SUBJECT FOR COMPILATION
        ::
        |-  ^+  SUBJECT
        ?~  CORE-VASES  SUBJECT
        ?<  ?=(~ IMPORTS)
        ::  CONS THIS VASE ONTO THE HEAD OF THE SUBJECT
        ::
        =.  SUBJECT
          %-  SLOP  :_  SUBJECT
          ::  CHECK IF THE PROGRAMMER NAMED THE LIBRARY
          ::
          ?~  FACE.CABLE.I.IMPORTS
            ::  NO FACE ASSIGNED TO THIS LIBRARY, SO USE VASE AS-IS
            ::
            I.CORE-VASES
          ::  USE THE LIBRARY NAME AS A FACE TO PREVENT NAMESPACE LEAKAGE
          ::
          ^-  VASE
          [[%FACE U.FACE.CABLE.I.IMPORTS P.I.CORE-VASES] Q.I.CORE-VASES]
        ::
        $(CORE-VASES T.CORE-VASES, IMPORTS T.IMPORTS)
      --
    ::
    ++  MAKE-REEF
      ~%  %MAKE-REEF  ..^^$  ~
      |=  =DISC
      ^-  BUILD-RECEIPT
      ::
      =/  HOON-SCRY
        [DATE.BUILD [%SCRY %C %X [DISC /HOON/HOON/SYS]]]
      ::
      =^  HOON-SCRY-RESULT  OUT  (DEPEND-ON HOON-SCRY)
      ::
      =/  ARVO-SCRY
        [DATE.BUILD [%SCRY %C %X [DISC /HOON/ARVO/SYS]]]
      ::
      =^  ARVO-SCRY-RESULT  OUT  (DEPEND-ON ARVO-SCRY)
      ::
      =/  ZUSE-SCRY
        [DATE.BUILD [%SCRY %C %X [DISC /HOON/ZUSE/SYS]]]
      ::
      =^  ZUSE-SCRY-RESULT  OUT  (DEPEND-ON ZUSE-SCRY)
      ::
      =|  BLOCKS=(LIST ^BUILD)
      =?  BLOCKS  ?=(~ HOON-SCRY-RESULT)  [HOON-SCRY BLOCKS]
      =?  BLOCKS  ?=(~ ARVO-SCRY-RESULT)  [ARVO-SCRY BLOCKS]
      =?  BLOCKS  ?=(~ ZUSE-SCRY-RESULT)  [ZUSE-SCRY BLOCKS]
      ::
      ?^  BLOCKS
        (RETURN-BLOCKS BLOCKS)
      ::
      ?.  ?=([~ %SUCCESS %SCRY *] HOON-SCRY-RESULT)
        (WRAP-ERROR HOON-SCRY-RESULT)
      ::
      ?.  ?=([~ %SUCCESS %SCRY *] ARVO-SCRY-RESULT)
        (WRAP-ERROR ARVO-SCRY-RESULT)
      ::
      ?.  ?=([~ %SUCCESS %SCRY *] ZUSE-SCRY-RESULT)
        (WRAP-ERROR ZUSE-SCRY-RESULT)
      ::  SHORT-CIRCUIT TO :PIT IF ASKED FOR CURRENT %HOME DESK
      ::
      ::    THIS AVOIDS NEEDING TO RECOMPILE THE KERNEL IF WE'RE ASKED
      ::    FOR THE KERNEL WE'RE ALREADY RUNNING. NOTE THAT THIS FAILS
      ::    REFERENTIAL TRANSPARENCY IF |AUTOLOAD IS TURNED OFF.
      ::
      ?:  ?&  |(=(DISC [OUR %HOME]) =(DISC [OUR %BASE]))
              ::  IS :DATE.BUILD THE LATEST COMMIT ON THE %HOME DESK?
              ::
              ?|  =(NOW DATE.BUILD)
                  ::
                  =/  =BEAM  [[OUR %HOME [%DA DATE.BUILD]] /HOON/HOON/SYS]
                  ::
                  .=  (SCRY [%141 %NOUN] ~ %CW BEAM)
                  (SCRY [%141 %NOUN] ~ %CW BEAM(R [%DA NOW]))
          ==  ==
        ::
        (RETURN-RESULT %SUCCESS %REEF PIT)
      ::  OMIT CASE FROM PATH TO PREVENT CACHE MISSES
      ::
      =/  HOON-PATH=PATH
        /(SCOT %P SHIP.DISC)/(SCOT %TAS DESK.DISC)/HOON/HOON/SYS
      =/  HOON-HOON=(EACH HOON TANG)
        %-  MULE  |.
        (RAIN HOON-PATH ;;(@T Q.Q.CAGE.U.HOON-SCRY-RESULT))
      ?:  ?=(%| -.HOON-HOON)
        (RETURN-ERROR LEAF+"FORD: %REEF FAILED TO COMPILE HOON" P.HOON-HOON)
      ::
      =/  ARVO-PATH=PATH
        /(SCOT %P SHIP.DISC)/(SCOT %TAS DESK.DISC)/HOON/ARVO/SYS
      =/  ARVO-HOON=(EACH HOON TANG)
        %-  MULE  |.
        (RAIN ARVO-PATH ;;(@T Q.Q.CAGE.U.ARVO-SCRY-RESULT))
      ?:  ?=(%| -.ARVO-HOON)
        (RETURN-ERROR LEAF+"FORD: %REEF FAILED TO COMPILE ARVO" P.ARVO-HOON)
      ::
      =/  ZUSE-PATH=PATH
        /(SCOT %P SHIP.DISC)/(SCOT %TAS DESK.DISC)/HOON/ZUSE/SYS
      =/  ZUSE-HOON=(EACH HOON TANG)
        %-  MULE  |.
        (RAIN ZUSE-PATH ;;(@T Q.Q.CAGE.U.ZUSE-SCRY-RESULT))
      ?:  ?=(%| -.ZUSE-HOON)
        (RETURN-ERROR LEAF+"FORD: %REEF FAILED TO COMPILE ZUSE" P.ZUSE-HOON)
      ::
      =/  ZUSE-BUILD=^BUILD
        :*  DATE.BUILD
            %RIDE  P.ZUSE-HOON
            ::  HOON FOR `..IS` TO GRAB THE :PIT OUT OF THE ARVO CORE
            ::
            %RIDE  [%CNTS ~[[%& 1] %IS] ~]
            %RIDE  P.ARVO-HOON
            %RIDE  [%$ 7]
            %RIDE  P.HOON-HOON
            [%$ %NOUN !>(~)]
        ==
      ::
      =^  ZUSE-BUILD-RESULT  OUT  (DEPEND-ON ZUSE-BUILD)
      ?~  ZUSE-BUILD-RESULT
        (RETURN-BLOCKS [ZUSE-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %RIDE *] ZUSE-BUILD-RESULT)
        (WRAP-ERROR ZUSE-BUILD-RESULT)
      ::
      (RETURN-RESULT %SUCCESS %REEF VASE.U.ZUSE-BUILD-RESULT)
    ::
    ++  MAKE-RIDE
      ~%  %MAKE-RIDE  ..^^$  ~
      |=  [FORMULA=HOON =SCHEMATIC]
      ^-  BUILD-RECEIPT
      ::
      =^  RESULT  OUT  (DEPEND-ON [DATE.BUILD SCHEMATIC])
      ?~  RESULT
        (RETURN-BLOCKS [DATE.BUILD SCHEMATIC]~)
      ::
      =*  SUBJECT-VASE  Q:(RESULT-TO-CAGE U.RESULT)
      =/  SLIM-SCHEMATIC=^SCHEMATIC  [%SLIM P.SUBJECT-VASE FORMULA]
      =^  SLIM-RESULT  OUT  (DEPEND-ON [DATE.BUILD SLIM-SCHEMATIC])
      ?~  SLIM-RESULT
        (RETURN-BLOCKS [DATE.BUILD SLIM-SCHEMATIC]~)
      ::
      ?:  ?=([~ %ERROR *] SLIM-RESULT)
        %-  RETURN-ERROR
        :*  [%LEAF "FORD: %RIDE FAILED TO COMPUTE TYPE:"]
            MESSAGE.U.SLIM-RESULT
        ==
      ::
      ?>  ?=([~ %SUCCESS %SLIM *] SLIM-RESULT)
      ::
      =/  =COMPILER-CACHE-KEY  [%RIDE FORMULA SUBJECT-VASE]
      =^  CACHED-RESULT  OUT  (ACCESS-CACHE COMPILER-CACHE-KEY)
      ?^  CACHED-RESULT
        (RETURN-RESULT U.CACHED-RESULT)
      ::
      =/  VAL
        (MOCK [Q.SUBJECT-VASE NOCK.U.SLIM-RESULT] INTERCEPTED-SCRY)
      ::  VAL IS A TOON, WHICH MIGHT BE A LIST OF BLOCKS.
      ::
      ?-    -.VAL
      ::
          %0
        (RETURN-RESULT %SUCCESS %RIDE [TYPE.U.SLIM-RESULT P.VAL])
      ::
          %1
        =/  BLOCKED-PATHS=(LIST PATH)  ((HARD (LIST PATH)) P.VAL)
        (BLOCKED-PATHS-TO-RECEIPT %RIDE BLOCKED-PATHS)
      ::
          %2
        (RETURN-ERROR [[%LEAF "FORD: %RIDE FAILED TO EXECUTE:"] P.VAL])
      ==
    ::
    ++  MAKE-SAME
      ~%  %MAKE-SAME  ..^^$  ~
      |=  =SCHEMATIC
      ^-  BUILD-RECEIPT
      ::
      =^  RESULT  OUT  (DEPEND-ON [DATE.BUILD SCHEMATIC])
      ::
      ?~  RESULT
        (RETURN-BLOCKS [DATE.BUILD SCHEMATIC]~)
      (RETURN-RESULT U.RESULT)
    ::
    ++  MAKE-SCRY
      ~%  %MAKE-SCRY  ..^^$  ~
      |=  =RESOURCE
      ^-  BUILD-RECEIPT
      ::  CONSTRUCT A FULL +BEAM TO MAKE THE SCRY REQUEST
      ::
      =/  =BEAM          (EXTRACT-BEAM RESOURCE `DATE.BUILD)
      =/  =SCRY-REQUEST  [VANE.RESOURCE CARE.RESOURCE BEAM]
      ::  PERFORM SCRY OPERATION IF WE DON'T ALREADY KNOW THE RESULT
      ::
      ::    LOOK UP :SCRY-REQUEST IN :SCRY-RESULTS.PER-EVENT TO AVOID
      ::    RERUNNING A PREVIOUSLY BLOCKED +SCRY.
      ::
      =/  SCRY-RESPONSE
        ?:  (~(HAS BY SCRY-RESULTS) SCRY-REQUEST)
          (~(GET BY SCRY-RESULTS) SCRY-REQUEST)
        (SCRY [%141 %NOUN] ~ `@TAS`(CAT 3 [VANE CARE]:RESOURCE) BEAM)
      ::  SCRY BLOCKED
      ::
      ?~  SCRY-RESPONSE
        (RETURN-BLOCKS ~)
      ::  SCRY FAILED
      ::
      ?~  U.SCRY-RESPONSE
        %-  RETURN-ERROR
        :~  LEAF+"SCRY FAILED FOR"
            LEAF+:(WELD "%C" (TRIP CARE.RESOURCE) " " (SPUD (EN-BEAM BEAM)))
        ==
      ::  SCRY SUCCEEDED
      ::
      (RETURN-RESULT %SUCCESS %SCRY U.U.SCRY-RESPONSE)
    ::
    ++  MAKE-SLIM
      ~%  %MAKE-SLIM  ..^^$  ~
      |=  [SUBJECT-TYPE=TYPE FORMULA=HOON]
      ^-  BUILD-RECEIPT
      ::
      =/  =COMPILER-CACHE-KEY  [%SLIM SUBJECT-TYPE FORMULA]
      =^  CACHED-RESULT  OUT  (ACCESS-CACHE COMPILER-CACHE-KEY)
      ?^  CACHED-RESULT
        (RETURN-RESULT U.CACHED-RESULT)
      ::
      =/  COMPILED=(EACH (PAIR TYPE NOCK) TANG)
        (MULE |.((~(MINT UT SUBJECT-TYPE) [%NOUN FORMULA])))
      ::
      %_    OUT
          RESULT
        ?-  -.COMPILED
          %|  [%BUILD-RESULT %ERROR [LEAF+"FORD: %SLIM FAILED: " P.COMPILED]]
          %&  [%BUILD-RESULT %SUCCESS %SLIM P.COMPILED]
        ==
      ==
    ::  TODO: TAKE IN +TYPE INSTEAD OF +VASE?
    ::
    ++  MAKE-SLIT
      ~%  %MAKE-SLIT  ..^^$  ~
      |=  [GATE=VASE SAMPLE=VASE]
      ^-  BUILD-RECEIPT
      ::
      =/  =COMPILER-CACHE-KEY  [%SLIT P.GATE P.SAMPLE]
      =^  CACHED-RESULT  OUT  (ACCESS-CACHE COMPILER-CACHE-KEY)
      ?^  CACHED-RESULT
        (RETURN-RESULT U.CACHED-RESULT)
      ::
      =/  PRODUCT=(EACH TYPE TANG)
        (MULE |.((SLIT P.GATE P.SAMPLE)))
      ::
      %_    OUT
          RESULT
        ?-  -.PRODUCT
          %|  :*  %BUILD-RESULT   %ERROR
                  :*  (~(DUNK UT P.SAMPLE) %HAVE)
                      (~(DUNK UT (~(PEEK UT P.GATE) %FREE 6)) %WANT)
                      LEAF+"FORD: %SLIT FAILED:"
                      P.PRODUCT
                  ==
              ==
          %&  [%BUILD-RESULT %SUCCESS %SLIT P.PRODUCT]
        ==
      ==
    ::
    ++  MAKE-VOLT
      ~%  %MAKE-VOLT  ..^^$  ~
      |=  [=DISC MARK=TERM INPUT=*]
      ^-  BUILD-RECEIPT
      ::
      =/  BUNT-BUILD=^BUILD  [DATE.BUILD [%BUNT DISC MARK]]
      ::
      =^  BUNT-RESULT  OUT  (DEPEND-ON BUNT-BUILD)
      ?~  BUNT-RESULT
        (RETURN-BLOCKS [BUNT-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] BUNT-RESULT)
        %-  RETURN-ERROR
        :-  [%LEAF "FORD: %VOLT {<MARK>} ON {<DISC>} FAILED:"]
        MESSAGE.U.BUNT-RESULT
      ::
      ?>  ?=([~ %SUCCESS %BUNT *] BUNT-RESULT)
      ::
      =/  =BUILD-RESULT
        [%SUCCESS %VOLT [MARK P.Q.CAGE.U.BUNT-RESULT INPUT]]
      ::
      (RETURN-RESULT BUILD-RESULT)
    ::
    ++  MAKE-VALE
      ~%  %MAKE-VALE  ..^^$  ~
      ::  TODO: BETTER DOCS
      ::
      |=  [=DISC MARK=TERM INPUT=*]
      ^-  BUILD-RECEIPT
      ::  DON'T VALIDATE FOR THE %NOUN MARK
      ::
      ?:  =(%NOUN MARK)
        =/  =BUILD-RESULT  [%SUCCESS %VALE [%NOUN %NOUN INPUT]]
        ::
        (RETURN-RESULT BUILD-RESULT)
      ::
      =/  PATH-BUILD  [DATE.BUILD [%PATH DISC %MAR MARK]]
      ::
      =^  PATH-RESULT  OUT  (DEPEND-ON PATH-BUILD)
      ?~  PATH-RESULT
        (RETURN-BLOCKS [PATH-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] PATH-RESULT)
        %-  RETURN-ERROR
        :-  LEAF+"FORD: %VALE FAILED WHILE SEARCHING FOR {<MARK>}:"
        MESSAGE.U.PATH-RESULT
      ::
      ?>  ?=([~ %SUCCESS %PATH *] PATH-RESULT)
      ::
      =/  BUNT-BUILD=^BUILD  [DATE.BUILD [%BUNT DISC MARK]]
      ::
      =^  BUNT-RESULT  OUT  (DEPEND-ON BUNT-BUILD)
      ?~  BUNT-RESULT
        (RETURN-BLOCKS [BUNT-BUILD]~)
      ::
      ?.  ?=([~ %SUCCESS %BUNT *] BUNT-RESULT)
        (WRAP-ERROR BUNT-RESULT)
      ::
      =/  MARK-SAMPLE=VASE  Q.CAGE.U.BUNT-RESULT
      ::
      =/  CALL-BUILD=^BUILD
        :^    DATE.BUILD
            %CALL
          ^=  GATE
          :*  %RIDE
              ::  (REAM 'NOUN:GRAB')
              FORMULA=`HOON`[%TSLD [%WING ~[%NOUN]] [%WING ~[%GRAB]]]
              SUBJECT=`SCHEMATIC`[%CORE RAIL.U.PATH-RESULT]
          ==
        SAMPLE=[%$ %NOUN %NOUN INPUT]
      ::
      =^  CALL-RESULT  OUT  (DEPEND-ON CALL-BUILD)
      ?~  CALL-RESULT
        (RETURN-BLOCKS [CALL-BUILD]~)
      ::
      ?:  ?=([~ %ERROR *] CALL-RESULT)
        ::
        %-  RETURN-ERROR
        =/  =BEAM
          [[SHIP.DISC DESK.DISC %DA DATE.BUILD] SPUR.RAIL.U.PATH-RESULT]
        :*  :-  %LEAF
            "FORD: %VALE FAILED: INVALID INPUT FOR MARK: {<(EN-BEAM BEAM)>}"
            MESSAGE.U.CALL-RESULT
        ==
      ::
      ?>  ?=([~ %SUCCESS %CALL *] CALL-RESULT)
      =/  PRODUCT=VASE  VASE.U.CALL-RESULT
      ::  +GRAB MIGHT PRODUCE THE WRONG TYPE
      ::
      ?.  (~(NEST UT P.MARK-SAMPLE) | P.PRODUCT)
        %-  RETURN-ERROR
        :~  LEAF+"FORD: %VALE FAILED"
            LEAF+"+GRAB HAS WRONG TYPE IN MARK {<MARK>} ON DISC {<DISC>}"
        ==
      ::
      =/  =BUILD-RESULT
        [%SUCCESS %VALE [MARK P.MARK-SAMPLE Q.PRODUCT]]
      ::
      (RETURN-RESULT BUILD-RESULT)
    ::
    ++  MAKE-WALK
      ~%  %MAKE-WALK  ..^^$  ~
      |=  [=DISC SOURCE=TERM TARGET=TERM]
      ^-  BUILD-RECEIPT
      ::  DEFINE SOME TYPES USED IN THIS GATE
      ::
      =>  |%
          ::  +LOAD-NODE: A QUEUED ARM TO RUN FROM A MARK CORE
          ::
          +=  LOAD-NODE  [TYPE=?(%GRAB %GROW) MARK=TERM]
          ::  EDGE-JUG: DIRECTED GRAPH FROM :SOURCE MARK TO :TARGET MARKS
          ::
          ::    :SOURCE CAN BE CONVERTED TO :TARGET EITHER BY RUNNING
          ::    ITS OWN +GROW ARM, OR BY RUNNING THE TARGET'S +GRAB ARM.
          ::
          +=  EDGE-JUG  (JUG SOURCE=TERM [TARGET=TERM ARM=?(%GROW %GRAB)])
          ::  MARK-PATH: A PATH THROUGH THE MARK GRAPH
          ::
          ::    +MARK-PATH REPRESENTS A SERIES OF MARK TRANSLATION
          ::    OPERATIONS TO BE PERFORMED TO 'WALK' FROM ONE MARK TO ANOTHER.
          ::
          ::    +MARK-ACTION IS DEFINED IN ZUSE. IT REPRESENTS A CONVERSION
          ::    FROM A SOURCE MARK TO A TARGET MARK, AND IT SPECIFIES
          ::    WHETHER IT WILL USE +GROW OR +GRAB.
          ::
          +=  MARK-PATH  (LIST MARK-ACTION)
          --
      ::
      |^  ^-  BUILD-RECEIPT
          ?:  =(SOURCE TARGET)
            (RETURN-RESULT %SUCCESS %WALK ~)
          ::  LOAD ALL MARKS.
          ::
          =^  MARKS-RESULT  OUT
            (LOAD-MARKS-REACHABLE-FROM [[%GROW SOURCE] [%GRAB TARGET] ~])
          ?~  -.MARKS-RESULT
            OUT
          ::  FIND A PATH THROUGH THE GRAPH
          ::
          ::    MAKE A LIST OF INDIVIDUAL MARK TRANSLATION ACTIONS WHICH WILL
          ::    TAKE US FROM :SOURCE TO :TERM.
          ::
          =/  PATH  (FIND-PATH-THROUGH U.-.MARKS-RESULT)
          ::  IF THERE IS NO PATH BETWEEN THESE MARKS, GIVE AN ERROR MESSAGE
          ::
          ?~  PATH
            ::  WE FAILED; SURFACE ERRORS FROM +LOAD-MARKS-REACHABLE-FROM
            ::
            =/  BRACES  [[' ' ' ' ~] ['{' ~] ['}' ~]]
            =/  ERRORS=(LIST TANK)
              %-  ZING
              %+  TURN  ~(TAP IN +.MARKS-RESULT)
              |=  [MARK=TERM ERR=TANG]
              ^-  TANG
              :~  [%LEAF :(WELD "WHILE COMPILING " (TRIP MARK) ":")]
                  [%ROSE BRACES ERR]
              ==
            ::
            %_    OUT
                RESULT
              :*  %BUILD-RESULT  %ERROR
                  :*  :-  %LEAF
                      ;:  WELD
                        "FORD: NO MARK PATH FROM "  (TRIP SOURCE)  " TO "
                        (TRIP TARGET)
                      ==
                      ERRORS
              ==  ==
            ==
          ::
          (RETURN-RESULT %SUCCESS %WALK PATH)
      ::  +LOAD-MARKS-REACHABLE-FROM: PARTIAL MARK GRAPH LOADING
      ::
      ::    WHILE WE CAN JUST LOAD ALL MARKS IN THE %/MAR DIRECTORY, THIS IS
      ::    RATHER SLOW. WHAT WE DO INSTEAD IS TRAVERSE FORWARDS AND BACKWARDS
      ::    FROM THE SOURCE AND TARGET MARKS: WE START AT THE SOURCE MARK,
      ::    CHECK ALL THE GROW ARMS, AND THEN CHECK THEIR GROW ARMS. AT THE
      ::    SAME TIME, WE START FROM THE TARGET MARK, CHECK ALL THE GRAB ARMS,
      ::    AND THEN CHECK THEIR GRAB ARMS. THIS GIVES US A MUCH SMALLER
      ::    DEPENDENCY SET THAN LOADING THE ENTIRE %/MAR DIRECTORY.
      ::
      ++  LOAD-MARKS-REACHABLE-FROM
        |=  QUEUED-NODES=(LIST LOAD-NODE)
        ::  LIST OF NODES IN THE GRAPH THAT WE'VE ALREADY CHECKED
        ::
        =|  VISITED=(SET LOAD-NODE)
        ::  GRAPH OF THE AVAILABLE EDGES
        ::
        =|  =EDGE-JUG
        ::  COMPILE-FAILURES: MARK FILES WHICH DIDN'T COMPILE
        ::
        =|  COMPILE-FAILURES=(MAP TERM TANG)
        ::
        |-
        ^-  [[(UNIT ^EDGE-JUG) _COMPILE-FAILURES] _OUT]
        ::  NO ?~ TO PREVENT TMI
        ::
        ?:  =(~ QUEUED-NODES)
          [[`EDGE-JUG COMPILE-FAILURES] OUT]
        ::
        =/  NODES-AND-SCHEMATICS
          %+  TURN  QUEUED-NODES
          |=  =LOAD-NODE
          ^-  [^LOAD-NODE SCHEMATIC]
          :-  LOAD-NODE
          [%PATH DISC %MAR MARK.LOAD-NODE]
        ::  GET THE PATH FOR EACH MARK NAME
        ::
        ::    FOR %PATH BUILDS, ANY AMBIGUOUS PATH IS JUST FILTERED OUT.
        ::
        =^  MAYBE-PATH-RESULTS  OUT
          %-  PERFORM-SCHEMATICS  :*
            ;:  WELD
              "FORD: %WALK FROM "  (TRIP SOURCE)  " TO "  (TRIP TARGET)
              " CONTAINED FAILURES:"
            ==
            NODES-AND-SCHEMATICS
            %FILTER-ERRORS
            *LOAD-NODE
          ==
        ?~  MAYBE-PATH-RESULTS
          [[~ ~] OUT]
        ::
        =/  NODES-AND-CORES
          %+  TURN  U.MAYBE-PATH-RESULTS
          |=  [=LOAD-NODE =BUILD-RESULT]
          ^-  [^LOAD-NODE SCHEMATIC]
          ::
          ?>  ?=([%SUCCESS %PATH *] BUILD-RESULT)
          ::
          :-  LOAD-NODE
          [%CORE RAIL.BUILD-RESULT]
        ::
        =^  MAYBE-CORE-RESULTS  OUT
          %-  PERFORM-SCHEMATICS  :*
            ;:  WELD
              "FORD: %WALK FROM "  (TRIP SOURCE)  " TO "  (TRIP TARGET)
              " CONTAINED FAILURES:"
            ==
            NODES-AND-CORES
            %IGNORE-ERRORS
            *LOAD-NODE
          ==
        ?~  MAYBE-CORE-RESULTS
          [[~ ~] OUT]
        ::  CLEAR THE QUEUE BEFORE WE PROCESS THE NEW RESULTS
        ::
        =.  QUEUED-NODES  ~
        ::
        =/  CORES  U.MAYBE-CORE-RESULTS
        ::
        |-
        ?~  CORES
          ^$
        ::  MARK THIS NODE AS VISITED
        ::
        =.  VISITED  (~(PUT IN VISITED) KEY.I.CORES)
        ::  ADD CORE ERRORS TO COMPILE FAILURES
        ::
        =?  COMPILE-FAILURES  ?=([%ERROR *] RESULT.I.CORES)
          %+  ~(PUT BY COMPILE-FAILURES)  MARK.KEY.I.CORES
          MESSAGE.RESULT.I.CORES
        ::
        =/  TARGET-ARMS=(LIST LOAD-NODE)
          ?.  ?=([%SUCCESS %CORE *] RESULT.I.CORES)
            ~
          ?:  =(%GROW TYPE.KEY.I.CORES)
            (GET-ARMS-OF-TYPE %GROW VASE.RESULT.I.CORES)
          (GET-ARMS-OF-TYPE %GRAB VASE.RESULT.I.CORES)
        ::  FILTER PLACES WE KNOW WE'VE ALREADY BEEN.
        ::
        =.  TARGET-ARMS
          %+  SKIP  TARGET-ARMS  ~(HAS IN VISITED)
        =.  QUEUED-NODES  (WELD TARGET-ARMS QUEUED-NODES)
        ::
        =.  EDGE-JUG
          |-
          ?~  TARGET-ARMS
            EDGE-JUG
          ::
          =.  EDGE-JUG
            ?-    TYPE.I.TARGET-ARMS
            ::
                %GRAB
              (~(PUT JU EDGE-JUG) MARK.I.TARGET-ARMS [MARK.KEY.I.CORES %GRAB])
            ::
                %GROW
              (~(PUT JU EDGE-JUG) MARK.KEY.I.CORES [MARK.I.TARGET-ARMS %GROW])
            ==
          $(TARGET-ARMS T.TARGET-ARMS)
        ::
        $(CORES T.CORES)
      ::
      ++  GET-ARMS-OF-TYPE
        |=  [TYPE=?(%GRAB %GROW) =VASE]
        ^-  (LIST LOAD-NODE)
        ::  IT IS VALID FOR THIS NODE TO NOT HAVE A +GROW ARM.
        ::
        ?.  (SLOB TYPE P.VASE)
          ~
        ::
        %+  TURN
          (SLOE P:(SLAP VASE [%LIMB TYPE]))
        |=  ARM=TERM
        [TYPE ARM]
      ::  +FIND-PATH-THROUGH: BREADTH FIRST SEARCH OVER THE MARK GRAPH
      ::
      ++  FIND-PATH-THROUGH
        |=  EDGES=EDGE-JUG
        ^-  MARK-PATH
        ::  THE SOURCE NODE STARTS OUT VISITED
        =/  VISITED-NODES=(SET MARK)  [SOURCE ~ ~]
        ::  THESE PATHS ARE FLOPPED SO WE'RE ALWAYS INSERTING TO THE FRONT.
        =|  PATH-QUEUE=(QEU MARK-PATH)
        ::  START THE QUEUE WITH ALL THE EDGES WHICH START AT THE SOURCE MARK
        ::
        =.  PATH-QUEUE
          =/  START-LINKS  (FIND-LINKS-IN-EDGES EDGES SOURCE)
          ::
          |-
          ^+  PATH-QUEUE
          ?~  START-LINKS
            PATH-QUEUE
          ::
          =.  PATH-QUEUE  (~(PUT TO PATH-QUEUE) [I.START-LINKS]~)
          ::
          $(START-LINKS T.START-LINKS)
        ::
        |-
        ^-  MARK-PATH
        ::
        ?:  =(~ PATH-QUEUE)
          ::  NO PATH FOUND
          ~
        =^  CURRENT  PATH-QUEUE  [P Q]:~(GET TO PATH-QUEUE)
        ?>  ?=(^ CURRENT)
        ::
        ?:  =(TARGET TARGET.I.CURRENT)
          ::  WE HAVE A COMPLETED PATH. PATHS IN THE QUEUE ARE BACKWARDS
          (FLOP CURRENT)
        ::
        =+  NEXT-STEPS=(FIND-LINKS-IN-EDGES EDGES TARGET.I.CURRENT)
        ::  FILTER OUT ALREADY VISITED NODES
        ::
        =.  NEXT-STEPS
          %+  SKIP  NEXT-STEPS
          |=  LINK=MARK-ACTION
          (~(HAS IN VISITED-NODES) SOURCE.LINK)
        ::  THEN ADD THE NEW ONES TO THE SET OF ALREADY VISITED NODES
        ::
        =.  VISITED-NODES
          (~(GAS IN VISITED-NODES) (TURN NEXT-STEPS |=(MARK-ACTION SOURCE)))
        ::  NOW ALL NEXT STEPS GO IN THE QUEUE
        ::
        =.  PATH-QUEUE
          %-  ~(GAS TO PATH-QUEUE)
          %+  TURN  NEXT-STEPS
          |=  NEW-LINK=MARK-ACTION
          [NEW-LINK CURRENT]
        ::
        $
      ::  +FIND-LINKS-IN-EDGES: GETS EDGES USABLE BY +FIND-PATH-THROUGH
      ::
      ::    THIS DEALS WITH DISAMBIGUATING BETWEEN %GRAB AND %GROW SO WE ALWAYS
      ::    PICK %GRAB OVER %GROW.
      ::
      ++  FIND-LINKS-IN-EDGES
        |=  [EDGES=EDGE-JUG SOURCE=TERM]
        ^-  (LIST MARK-ACTION)
        ::
        =+  LINKS=~(TAP IN (~(GET JU EDGES) SOURCE))
        ::
        =|  RESULTS=(SET MARK-ACTION)
        |-
        ^-  (LIST MARK-ACTION)
        ?~  LINKS
          ~(TAP IN RESULTS)
        ::
        ?-    ARM.I.LINKS
            %GRAB
          ::  IF :RESULTS HAS A %GROW ENTRY, REMOVE IT BEFORE ADDING OUR %GRAB
          =/  GROW-ENTRY=MARK-ACTION  [%GROW SOURCE TARGET.I.LINKS]
          =?  RESULTS  (~(HAS IN RESULTS) GROW-ENTRY)
            (~(DEL IN RESULTS) GROW-ENTRY)
          ::
          =.  RESULTS  (~(PUT IN RESULTS) [%GRAB SOURCE TARGET.I.LINKS])
          $(LINKS T.LINKS)
        ::
            %GROW
          ::  IF :RESULTS HAS A %GRAB ENTRY, DON'T ADD A %GROW ENTRY
          ?:  (~(HAS IN RESULTS) [%GRAB SOURCE TARGET.I.LINKS])
            $(LINKS T.LINKS)
          ::
          =.  RESULTS  (~(PUT IN RESULTS) [%GROW SOURCE TARGET.I.LINKS])
          $(LINKS T.LINKS)
        ==
      --
    ::  |UTILITIES:MAKE: HELPER ARMS
    ::
    ::+|  UTILITIES
    ::
    ::  +PERFORM-SCHEMATICS: HELPER FUNCTION THAT PERFORMS A LIST OF BUILDS
    ::
    ::    WE OFTEN NEED TO RUN A LIST OF BUILDS. THIS HELPER METHOD WILL
    ::    DEPEND ON ALL :BUILDS, WILL RETURN A +BUILD-RECEIPT OF EITHER THE
    ::    BLOCKS OR THE FIRST ERROR, OR A LIST OF ALL COMPLETED RESULTS.
    ::
    ::    THIS IS A WET GATE SO INDIVIDUAL CALLERS CAN ASSOCIATE THEIR OWN
    ::    KEY TYPES WITH SCHEMATICS.
    ::
    ++  PERFORM-SCHEMATICS
      |*  $:  FAILURE=TAPE
              BUILDS=(LIST [KEY=* =SCHEMATIC])
              ON-ERROR=?(%FAIL-ON-ERRORS %FILTER-ERRORS %IGNORE-ERRORS)
              KEY-BUNT=*
          ==
      ^-  $:  (UNIT (LIST [KEY=_KEY-BUNT RESULT=BUILD-RESULT]))
              _OUT
          ==
      ::
      |^  =^  RESULTS  OUT
            =|  RESULTS=(LIST [_KEY-BUNT ^BUILD (UNIT BUILD-RESULT)])
            |-
            ^+  [RESULTS OUT]
            ::
            ?~  BUILDS
              [RESULTS OUT]
            ::
            =/  SUB-BUILD=^BUILD  [DATE.BUILD SCHEMATIC.I.BUILDS]
            =^  RESULT  OUT  (DEPEND-ON SUB-BUILD)
            =.  RESULTS  [[KEY.I.BUILDS SUB-BUILD RESULT] RESULTS]
            ::
            $(BUILDS T.BUILDS)
          ?:  =(%FAIL-ON-ERRORS ON-ERROR)
            (CHECK-ERRORS RESULTS)
          ?:  =(%FILTER-ERRORS ON-ERROR)
            (FILTER-ERRORS RESULTS)
          (HANDLE-REST RESULTS)
      ::
      ++  CHECK-ERRORS
        |=  RESULTS=(LIST [_KEY-BUNT ^BUILD (UNIT BUILD-RESULT)])
        ::
        =/  BRACES  [[' ' ' ' ~] ['{' ~] ['}' ~]]
        =/  ERRORS=(LIST TANK)
          %+  MURN  RESULTS
          |=  [* * RESULT=(UNIT BUILD-RESULT)]
          ^-  (UNIT TANK)
          ?.  ?=([~ %ERROR *] RESULT)
            ~
          `[%ROSE BRACES MESSAGE.U.RESULT]
        ::
        ?^  ERRORS
          :-  ~
          %-  RETURN-ERROR
          :-  [%LEAF FAILURE]
          ERRORS
        ::
        (HANDLE-REST RESULTS)
      ::
      ++  FILTER-ERRORS
        |=  RESULTS=(LIST [_KEY-BUNT ^BUILD (UNIT BUILD-RESULT)])
        =.  RESULTS
          %+  SKIP  RESULTS
          |=  [* * R=(UNIT BUILD-RESULT)]
          ?=([~ %ERROR *] R)
        (HANDLE-REST RESULTS)
      ::
      ++  HANDLE-REST
        |=  RESULTS=(LIST [_KEY-BUNT ^BUILD (UNIT BUILD-RESULT)])
        ::  IF ANY SUB-BUILDS BLOCKED, PRODUCE ALL BLOCKED SUB-BUILDS
        ::
        =/  BLOCKS=(LIST ^BUILD)
          %+  MURN  `(LIST [* ^BUILD (UNIT BUILD-RESULT)])`RESULTS
          |=  [* SUB=^BUILD RESULT=(UNIT BUILD-RESULT)]
          ^-  (UNIT ^BUILD)
          ?^  RESULT
            ~
          `SUB
        ::
        ?^  BLOCKS
          [~ (RETURN-BLOCKS BLOCKS)]
        ::
        :_  OUT
        :-  ~
        %+  TURN  RESULTS
        |*  [KEY=_KEY-BUNT ^BUILD RESULT=(UNIT BUILD-RESULT)]
        ^-  [_KEY-BUNT BUILD-RESULT]
        [KEY (NEED RESULT)]
      --
    ::  +WRAP-ERROR: WRAP AN ERROR MESSAGE AROUND A FAILED SUB-BUILD
    ::
    ++  WRAP-ERROR
      |=  RESULT=(UNIT BUILD-RESULT)
      ^-  BUILD-RECEIPT
      ::
      ?>  ?=([~ %ERROR *] RESULT)
      =/  MESSAGE=TANG
        [[%LEAF "FORD: {<-.SCHEMATIC.BUILD>} FAILED: "] MESSAGE.U.RESULT]
      ::
      (RETURN-ERROR MESSAGE)
    ::  +RETURN-BLOCKS: EXIT +MAKE AS A BLOCKED BUILD
    ::
    ++  RETURN-BLOCKS
      |=  BUILDS=(LIST ^BUILD)
      ^-  BUILD-RECEIPT
      OUT(RESULT [%BLOCKS BUILDS])
    ::  +RETURN-ERROR: EXIT +MAKE WITH A SPECIFIC FAILURE MESSAGE
    ::
    ++  RETURN-ERROR
      |=  =TANG
      ^-  BUILD-RECEIPT
      OUT(RESULT [%BUILD-RESULT %ERROR TANG])
    ::  +RETURN-RESULT: EXIT +MAKE WITH A COMPLETED BUILD
    ::
    ++  RETURN-RESULT
      |=  =BUILD-RESULT
      ^-  BUILD-RECEIPT
      OUT(RESULT [%BUILD-RESULT BUILD-RESULT])
    ::
    ++  ACCESS-CACHE
      |=  =COMPILER-CACHE-KEY
      ^-  [(UNIT BUILD-RESULT) _OUT]
      ::
      ?~  ENTRY=(~(GET BY LOOKUP.COMPILER-CACHE.STATE) COMPILER-CACHE-KEY)
        [~ OUT(CACHE-ACCESS `[COMPILER-CACHE-KEY NEW=%.Y])]
      ::
      [`VAL.U.ENTRY OUT(CACHE-ACCESS `[COMPILER-CACHE-KEY NEW=%.N])]
    ::
    ++  DEPEND-ON
      |=  KID=^BUILD
      ^-  [(UNIT BUILD-RESULT) _OUT]
      ::
      ?:  =(KID BUILD)
        ~|  [%DEPEND-ON-SELF (BUILD-TO-TAPE KID)]
        !!
      ::
      =.  SUB-BUILDS.OUT  [KID SUB-BUILDS.OUT]
      ::  +ACCESS-BUILD-RECORD WILL MUTATE :RESULTS.STATE
      ::
      ::    IT'S OKAY TO IGNORE THIS BECAUSE THE ACCESSED-BUILDS GET GATHERED
      ::    AND MERGED DURING THE +REDUCE STEP.
      ::
      =/  MAYBE-BUILD-RECORD  -:(ACCESS-BUILD-RECORD KID)
      ?~  MAYBE-BUILD-RECORD
        [~ OUT]
      ::
      =*  BUILD-RECORD  U.MAYBE-BUILD-RECORD
      ?:  ?=(%TOMBSTONE -.BUILD-RECORD)
        [~ OUT]
      ::
      [`BUILD-RESULT.BUILD-RECORD OUT]
    ::  +BLOCKED-PATHS-TO-RECEIPT: HANDLE THE %2 CASE FOR MOCK
    ::
    ::    MULTIPLE SCHEMATICS HANDLE +TOON INSTANCES. THIS HANDLES THE %2 CASE
    ::    FOR A +TOON AND TRANSFORMS IT INTO A +BUILD-RECEIPT SO WE DEPEND ON
    ::    THE BLOCKED PATHS CORRECTLY.
    ::
    ++  BLOCKED-PATHS-TO-RECEIPT
      |=  [NAME=TERM BLOCKED-PATHS=(LIST PATH)]
      ^-  BUILD-RECEIPT
      ::
      =/  BLOCKS-OR-FAILURES=(LIST (EACH ^BUILD TANK))
        %+  TURN  BLOCKED-PATHS
        |=  =PATH
        ::
        =/  SCRY-REQUEST=(UNIT SCRY-REQUEST)  (PATH-TO-SCRY-REQUEST PATH)
        ?~  SCRY-REQUEST
          [%| [%LEAF "FORD: {<NAME>}: INVALID SCRY PATH: {<PATH>}"]]
        ::
        =*  CASE  R.BEAM.U.SCRY-REQUEST
        ::
        ?.  ?=(%DA -.CASE)
          [%| [%LEAF "FORD: {<NAME>}: INVALID CASE IN SCRY PATH: {<PATH>}"]]
        ::
        =/  DATE=@DA  P.CASE
        ::
        =/  RESOURCE=(UNIT RESOURCE)  (PATH-TO-RESOURCE PATH)
        ?~  RESOURCE
          :-  %|
          [%LEAF "FORD: {<NAME>}: INVALID RESOURCE IN SCRY PATH: {<PATH>}"]
        ::
        =/  SUB-SCHEMATIC=SCHEMATIC  [%PIN DATE %SCRY U.RESOURCE]
        ::
        [%& `^BUILD`[DATE SUB-SCHEMATIC]]
      ::
      =/  FAILED=TANG
        %+  MURN  BLOCKS-OR-FAILURES
        |=  BLOCK=(EACH ^BUILD TANK)
        ^-  (UNIT TANK)
        ?-  -.BLOCK
          %&  ~
          %|  `P.BLOCK
        ==
      ::
      ?^  FAILED
        ::  SOME FAILED
        ::
        OUT(RESULT [%BUILD-RESULT %ERROR FAILED])
      ::  NO FAILURES
      ::
      =/  BLOCKS=(LIST ^BUILD)
        %+  TURN  BLOCKS-OR-FAILURES
        |=  BLOCK=(EACH ^BUILD TANK)
        ?>  ?=(%& -.BLOCK)
        ::
        P.BLOCK
      ::
      =.  OUT
        %+  ROLL  BLOCKS
        |=  [BLOCK=^BUILD ACCUMULATOR=_OUT]
        =.  OUT  ACCUMULATOR
        +:(DEPEND-ON [DATE.BLOCK SCHEMATIC.BLOCK])
      ::
      (RETURN-BLOCKS BLOCKS)
    --
  ::  |UTILITIES:PER-EVENT: HELPER ARMS
  ::
  ::+|  UTILITIES
  ::
  ::  +ADD-BUILD: STORE A FRESH, UNSTARTED BUILD IN THE STATE
  ::
  ++  ADD-BUILD
    ~/  %ADD-BUILD
    |=  =BUILD
    ^+  STATE
    ::  DON'T OVERWRITE AN EXISTING ENTRY
    ::
    ?:  (~(HAS BY BUILDS.STATE) BUILD)
      STATE
    ::
    %_    STATE
        BUILDS-BY-SCHEMATIC
      (~(PUT BY-SCHEMATIC BUILDS-BY-SCHEMATIC.STATE) BUILD)
    ::
        BUILDS
      %+  ~(PUT BY BUILDS.STATE)  BUILD
      =|  =BUILD-STATUS
      BUILD-STATUS(STATE [%UNTRIED ~])
    ==
  ::  +REMOVE-BUILDS: REMOVE BUILDS AND THEIR SUB-BUILDS
  ::
  ++  REMOVE-BUILDS
    ~/  %REMOVE-BUILDS
    |=  BUILDS=(LIST BUILD)
    ::
    |^  ^+  STATE
        ::
        ?~  BUILDS
          STATE
        ::
        ?~  MAYBE-BUILD-STATUS=(~(GET BY BUILDS.STATE) I.BUILDS)
          $(BUILDS T.BUILDS)
        =/  SUBS  ~(TAP IN ~(KEY BY SUBS.U.MAYBE-BUILD-STATUS))
        ::
        =^  REMOVED  STATE  (REMOVE-SINGLE-BUILD I.BUILDS U.MAYBE-BUILD-STATUS)
        ?.  REMOVED
          $(BUILDS T.BUILDS)
        ::
        $(BUILDS (WELP T.BUILDS SUBS))
    ::  +REMOVE-BUILD: STOP STORING :BUILD IN THE STATE
    ::
    ::    REMOVES ALL LINKAGES TO AND FROM SUB-BUILDS
    ::
    ++  REMOVE-SINGLE-BUILD
      |=  [=BUILD =BUILD-STATUS]
      ^+  [REMOVED=| STATE]
      ::  NEVER DELETE A BUILD THAT SOMETHING DEPENDS ON
      ::
      ?^  CLIENTS.BUILD-STATUS
        [REMOVED=| STATE]
      ?^  REQUESTERS.BUILD-STATUS
        [REMOVED=| STATE]
      ::  NOTHING DEPENDS ON :BUILD, SO WE'LL REMOVE IT
      ::
      :-  REMOVED=&
      ::
      %_    STATE
          BUILDS-BY-SCHEMATIC
        (~(DEL BY-SCHEMATIC BUILDS-BY-SCHEMATIC.STATE) BUILD)
      ::
          BUILDS
        (~(DEL BY BUILDS.STATE) BUILD)
      ==
    --
  ::  +UPDATE-BUILD-STATUS: REPLACE :BUILD'S +BUILD-STATUS BY RUNNING A FUNCTION
  ::
  ++  UPDATE-BUILD-STATUS
    ~/  %UPDATE-BUILD-STATUS
    |=  [=BUILD UPDATE-FUNC=$-(BUILD-STATUS BUILD-STATUS)]
    ^-  [BUILD-STATUS BUILDS=_BUILDS.STATE]
    ::
    =/  ORIGINAL=BUILD-STATUS
      ~|  [%UPDATE-BUILD (BUILD-TO-TAPE BUILD)]
      (~(GOT BY BUILDS.STATE) BUILD)
    =/  MUTANT=BUILD-STATUS  (UPDATE-FUNC ORIGINAL)
    ::
    [MUTANT (~(PUT BY BUILDS.STATE) BUILD MUTANT)]
  ::  +INTERCEPTED-SCRY: AUGMENT REAL SCRY WITH LOCAL %SCRY BUILD RESULTS
  ::
  ::    TRY TO DEDUPLICATE REQUESTS FOR POSSIBLY REMOTE RESOURCES BY LOOKING UP
  ::    THE RESULT IN LOCAL STATE IF THE REAL SCRY HAS NO SYNCHRONOUS
  ::    ANSWER (IT PRODUCED `~`).
  ::
  ++  INTERCEPTED-SCRY
    %-  SLOY  ^-  SLYD
    ~/  %INTERCEPTED-SCRY
    |=  [REF=* (UNIT (SET MONK)) =TERM =BEAM]
    ^-  (UNIT (UNIT (CASK)))
    ::  IF THE ACTUAL SCRY PRODUCES A VALUE, USE THAT VALUE; OTHERWISE USE LOCAL
    ::
    =/  SCRY-RESPONSE  (SCRY +<.$)
    ::
    ?^  SCRY-RESPONSE
      SCRY-RESPONSE
    ::
    =/  VANE=(UNIT %C)  ((SOFT ,%C) (END 3 1 TERM))
    ?~  VANE
      ~
    =/  CARE=(UNIT CARE:CLAY)  ((SOFT CARE:CLAY) (RSH 3 1 TERM))
    ?~  CARE
      ~
    ?.  ?=(%DA -.R.BEAM)
      ~
    =/  =RESOURCE  [U.VANE U.CARE RAIL=[[P.BEAM Q.BEAM] S.BEAM]]
    =/  =BUILD     [DATE=P.R.BEAM %SCRY RESOURCE]
    ::  LOOK UP THE SCRY RESULT FROM OUR PERMANENT STATE
    ::
    ::    NOTE: WE CAN'T FRESHEN :BUILD'S :LAST-ACCESSED DATE BECAUSE
    ::    WE CAN'T MUTATE :STATE FROM THIS GATE. %SCRY RESULTS MIGHT GET
    ::    DELETED DURING %WIPE MORE QUICKLY THAN THEY SHOULD BECAUSE OF THIS.
    ::
    =/  LOCAL-RESULT  -:(ACCESS-BUILD-RECORD BUILD)
    ?~  LOCAL-RESULT
      ~
    ?:  ?=(%TOMBSTONE -.U.LOCAL-RESULT)
      ~
    ::
    =/  LOCAL-CAGE=CAGE  (RESULT-TO-CAGE BUILD-RESULT.U.LOCAL-RESULT)
    ::  IF :LOCAL-RESULT DOES NOT NEST IN :TYPE, PRODUCE AN ERROR
    ::
    ?.  -:(NETS:WA +.REF `TYPE`P.Q.LOCAL-CAGE)
      [~ ~]
    ::
    [~ ~ `(CASK)`LOCAL-CAGE]
  ::  +UNBLOCK-CLIENTS-ON-DUCT: UNBLOCK AND PRODUCE CLIENTS BLOCKED ON :BUILD
  ::
  ++  UNBLOCK-CLIENTS-ON-DUCT
    =|  UNBLOCKED=(LIST BUILD)
    ~%  %UNBLOCK-CLIENTS-ON-DUCT  +>+  ~
    |=  =BUILD
    ^+  [UNBLOCKED BUILDS.STATE]
    ::
    =/  =BUILD-STATUS
      ~|  [%UNBLOCKING (BUILD-TO-TAPE BUILD)]
      (~(GOT BY BUILDS.STATE) BUILD)
    ::
    =/  CLIENTS=(LIST ^BUILD)  ~(TAP IN (~(GET JU CLIENTS.BUILD-STATUS) [%DUCT DUCT]))
    ::
    |-
    ^+  [UNBLOCKED BUILDS.STATE]
    ?~  CLIENTS
      [UNBLOCKED BUILDS.STATE]
    ::
    =^  CLIENT-STATUS  BUILDS.STATE
      %+  UPDATE-BUILD-STATUS  I.CLIENTS
      |=  CLIENT-STATUS=^BUILD-STATUS
      ::
      =.  SUBS.CLIENT-STATUS
        %+  ~(JAB BY SUBS.CLIENT-STATUS)  BUILD
        |=  ORIGINAL=BUILD-RELATION
        ORIGINAL(BLOCKED |)
      ::
      =?    STATE.CLIENT-STATUS
          ?&  ?=(%BLOCKED -.STATE.CLIENT-STATUS)
          ::
              ?!
              %-  ~(ANY BY SUBS.CLIENT-STATUS)
              |=(BUILD-RELATION &(BLOCKED VERIFIED))
          ==
        ::
        [%UNBLOCKED ~]
      CLIENT-STATUS
    ::
    =?  UNBLOCKED  !?=(%BLOCKED -.STATE.CLIENT-STATUS)
      [I.CLIENTS UNBLOCKED]
    ::
    $(CLIENTS T.CLIENTS)
  ::  +ON-BUILD-COMPLETE: HANDLES COMPLETION OF ANY BUILD
  ::
  ++  ON-BUILD-COMPLETE
    ~/  %ON-BUILD-COMPLETE
    |=  =BUILD
    ^+  ..EXECUTE
    ::
    =.  ..EXECUTE  (CLEANUP-ORPHANED-PROVISIONAL-BUILDS BUILD)
    ::
    =/  DUCT-STATUS  (~(GOT BY DUCTS.STATE) DUCT)
    ::
    =/  =BUILD-STATUS  (~(GOT BY BUILDS.STATE) BUILD)
    ?:  (~(HAS IN REQUESTERS.BUILD-STATUS) [%DUCT DUCT])
      (ON-ROOT-BUILD-COMPLETE BUILD)
    ::
    =^  UNBLOCKED-CLIENTS  BUILDS.STATE  (UNBLOCK-CLIENTS-ON-DUCT BUILD)
    =.  CANDIDATE-BUILDS  (~(GAS IN CANDIDATE-BUILDS) UNBLOCKED-CLIENTS)
    ::
    ..EXECUTE
  ::  +ON-ROOT-BUILD-COMPLETE: HANDLE COMPLETION OR PROMOTION OF A ROOT BUILD
  ::
  ::    WHEN A BUILD COMPLETES FOR A DUCT, WE MIGHT HAVE TO SEND A %MADE MOVE
  ::    ON THE REQUESTING DUCT AND ALSO DO DUCT AND BUILD BOOK-KEEPING.
  ::
  ++  ON-ROOT-BUILD-COMPLETE
    ~/  %ON-ROOT-BUILD-COMPLETE
    |=  =BUILD
    ^+  ..EXECUTE
    ::
    =;  RES=_..EXECUTE
        =/  DUCT-STATUS=(UNIT DUCT-STATUS)
          (~(GET BY DUCTS.STATE.RES) DUCT)
        ?~  DUCT-STATUS  RES
        ::  DEBUGGING ASSERTIONS TO TRY TO TRACK DOWN FAILURE IN
        ::  +COPY-BUILD-TREE-AS-PROVISIONAL
        ::
        ~|  [%FAILED-TO-PRESERVE-LIVE-BUILD (BUILD-TO-TAPE BUILD)]
        ?>  ?=(%LIVE -.LIVE.U.DUCT-STATUS)
        ~|  %FAILED-2
        ?>  ?=(^ LAST-SENT.LIVE.U.DUCT-STATUS)
        ~|  %FAILED-3
        ?>  .=  BUILD
            [DATE.U.LAST-SENT.LIVE.U.DUCT-STATUS ROOT-SCHEMATIC.U.DUCT-STATUS]
        ~|  %FAILED-4
        ?>  (~(HAS BY BUILDS.STATE.RES) BUILD)
        ::
        RES
    ::
    =/  =BUILD-STATUS  (~(GOT BY BUILDS.STATE) BUILD)
    =/  =DUCT-STATUS  (~(GOT BY DUCTS.STATE) DUCT)
    ::  MAKE SURE WE HAVE SOMETHING TO SEND
    ::
    ?>  ?=([%COMPLETE %VALUE *] STATE.BUILD-STATUS)
    ::  SEND A %MADE MOVE UNLESS IT'S AN UNCHANGED LIVE BUILD
    ::
    =?    MOVES
        ?!
        ?&  ?=(%LIVE -.LIVE.DUCT-STATUS)
            ?=(^ LAST-SENT.LIVE.DUCT-STATUS)
            ::
            =/  LAST-BUILD-STATUS
              %-  ~(GOT BY BUILDS.STATE)
              [DATE.U.LAST-SENT.LIVE.DUCT-STATUS SCHEMATIC.BUILD]
            ::
            ?>  ?=(%COMPLETE -.STATE.LAST-BUILD-STATUS)
            ?&  ?=(%VALUE -.BUILD-RECORD.STATE.LAST-BUILD-STATUS)
            ::
                .=  BUILD-RESULT.BUILD-RECORD.STATE.LAST-BUILD-STATUS
                    BUILD-RESULT.BUILD-RECORD.STATE.BUILD-STATUS
        ==  ==
      :_  MOVES
      ^-  MOVE
      ::
      :*  DUCT  %GIVE  %MADE  DATE.BUILD  %COMPLETE
          BUILD-RESULT.BUILD-RECORD.STATE.BUILD-STATUS
      ==
    ::
    ?-    -.LIVE.DUCT-STATUS
        %ONCE
      =.  DUCTS.STATE  (~(DEL BY DUCTS.STATE) DUCT)
      =.  STATE  (MOVE-ROOT-TO-CACHE BUILD)
      ::
      ..EXECUTE
    ::
        %LIVE
      ::  CLEAN UP PREVIOUS BUILD
      ::
      =?  STATE  ?=(^ LAST-SENT.LIVE.DUCT-STATUS)
        =/  OLD-BUILD=^BUILD  BUILD(DATE DATE.U.LAST-SENT.LIVE.DUCT-STATUS)
        ::
        (REMOVE-ANCHOR-FROM-ROOT OLD-BUILD [%DUCT DUCT])
      ::
      =/  RESOURCE-LIST=(LIST [=DISC RESOURCES=(SET RESOURCE)])
        ~(TAP BY (COLLECT-LIVE-RESOURCES BUILD))
      ::  WE CAN ONLY HANDLE A SINGLE SUBSCRIPTION
      ::
      ::    IN THE LONG TERM, WE NEED CLAY'S INTERFACE TO CHANGE SO WE CAN
      ::    SUBSCRIBE TO MULTIPLE DESKS AT THE SAME TIME.
      ::
      ?:  (LTH 1 (LENT RESOURCE-LIST))
        =.  ..EXECUTE
          %+  SEND-INCOMPLETE  BUILD  :~
            [%LEAF "ROOT BUILD {(BUILD-TO-TAPE BUILD)}"]
            [%LEAF "ON DUCT:"]
            [%LEAF "{<DUCT>}"]
            [%LEAF "TRIED TO SUBSCRIBE TO MULTIPLE DISCS:"]
            [%LEAF "{<RESOURCE-LIST>}"]
          ==
        ::  DELETE THIS INSTEAD OF CACHING IT, SINCE IT WASN'T RIGHT
        ::
        =.  DUCTS.STATE  (~(DEL BY DUCTS.STATE) DUCT)
        =.  STATE  (REMOVE-ANCHOR-FROM-ROOT BUILD [%DUCT DUCT])
        ..EXECUTE
      ::
      =/  SUBSCRIPTION=(UNIT SUBSCRIPTION)
        ?~  RESOURCE-LIST
          ~
        `[DATE.BUILD DISC.I.RESOURCE-LIST RESOURCES.I.RESOURCE-LIST]
      ::
      =?  ..EXECUTE  ?=(^ SUBSCRIPTION)
        (START-CLAY-SUBSCRIPTION U.SUBSCRIPTION)
      ::
      =.  DUCTS.STATE
        %+  ~(PUT BY DUCTS.STATE)  DUCT
        %_    DUCT-STATUS
            LIVE
          [%LIVE IN-PROGRESS=~ LAST-SENT=`[DATE.BUILD SUBSCRIPTION]]
        ==
      ::
      ..EXECUTE
    ==
  ::  +SEND-INCOMPLETE: EMIT A MOVE INDICATING WE CAN'T COMPLETE :BUILD
  ::
  ++  SEND-INCOMPLETE
    |=  [=BUILD MESSAGE=TANG]
    ^+  ..EXECUTE
    ::
    =.  MOVES
      :_  MOVES
      `MOVE`[DUCT %GIVE %MADE DATE.BUILD %INCOMPLETE MESSAGE]
    ::
    ..EXECUTE
  ::  +CLEANUP-ORPHANED-PROVISIONAL-BUILDS: DELETE EXTRANEOUS SUB-BUILDS
  ::
  ::    REMOVE UNVERIFIED LINKAGES TO SUB BUILDS. IF A SUB-BUILD HAS NO OTHER
  ::    CLIENTS ON THIS DUCT, THEN IT IS ORPHANED AND WE REMOVE THE DUCT FROM
  ::    ITS SUBS AND CALL +CLEANUP ON IT.
  ::
  ++  CLEANUP-ORPHANED-PROVISIONAL-BUILDS
    ~/  %CLEANUP-ORPHANED-PROVISIONAL-BUILDS
    |=  =BUILD
    ^+  ..EXECUTE
    ::
    =/  =BUILD-STATUS  (~(GOT BY BUILDS.STATE) BUILD)
    ::
    =/  ORPHANS=(LIST ^BUILD)
      %+  MURN  ~(TAP BY SUBS.BUILD-STATUS)
      |=  [SUB=^BUILD =BUILD-RELATION]
      ^-  (UNIT ^BUILD)
      ::
      ?:  VERIFIED.BUILD-RELATION
        ~
      `SUB
    ::  REMOVE LINKS TO ORPHANS IN :BUILD'S +BUILD-STATUS
    ::
    =^  BUILD-STATUS  BUILDS.STATE
      %+  UPDATE-BUILD-STATUS  BUILD
      |=  BUILD-STATUS=^BUILD-STATUS
      %_    BUILD-STATUS
          SUBS
        ::
        |-  ^+  SUBS.BUILD-STATUS
        ?~  ORPHANS  SUBS.BUILD-STATUS
        ::
        =.  SUBS.BUILD-STATUS  (~(DEL BY SUBS.BUILD-STATUS) I.ORPHANS)
        ::
        $(ORPHANS T.ORPHANS)
      ==
    ::
    =/  =ANCHOR  [%DUCT DUCT]
    ::
    |-  ^+  ..EXECUTE
    ?~  ORPHANS  ..EXECUTE
    ::  REMOVE LINK TO :BUILD IN :I.ORPHAN'S +BUILD-STATUS
    ::
    =^  ORPHAN-STATUS  BUILDS.STATE
      %+  UPDATE-BUILD-STATUS  I.ORPHANS
      |=  ORPHAN-STATUS=_BUILD-STATUS
      %_  ORPHAN-STATUS
        CLIENTS  (~(DEL JU CLIENTS.ORPHAN-STATUS) ANCHOR BUILD)
      ==
    ::
    ?:  (~(HAS BY CLIENTS.ORPHAN-STATUS) ANCHOR)
      $(ORPHANS T.ORPHANS)
    ::  :BUILD WAS THE LAST CLIENT ON THIS DUCT SO REMOVE IT
    ::
    =.  BUILDS.STATE  (REMOVE-ANCHOR-FROM-SUBS I.ORPHANS ANCHOR)
    =.  STATE  (CLEANUP I.ORPHANS)
    $(ORPHANS T.ORPHANS)
  ::  +ACCESS-BUILD-RECORD: ACCESS A +BUILD-RECORD, UPDATING :LAST-ACCESSED
  ::
  ::    USAGE:
  ::    ```
  ::    =^  MAYBE-BUILD-RECORD  BUILDS.STATE  (ACCESS-BUILD-RECORD BUILD)
  ::    ```
  ::
  ++  ACCESS-BUILD-RECORD
    ~/  %ACCESS-BUILD-RECORD
    |=  =BUILD
    ^-  [(UNIT BUILD-RECORD) _BUILDS.STATE]
    ::
    ?~  MAYBE-BUILD-STATUS=(~(GET BY BUILDS.STATE) BUILD)
      [~ BUILDS.STATE]
    ::
    =/  =BUILD-STATUS  U.MAYBE-BUILD-STATUS
    ::
    ?.  ?=(%COMPLETE -.STATE.BUILD-STATUS)
      [~ BUILDS.STATE]
    ::
    ?:  ?=(%TOMBSTONE -.BUILD-RECORD.STATE.BUILD-STATUS)
      [`BUILD-RECORD.STATE.BUILD-STATUS BUILDS.STATE]
    ::
    =.  LAST-ACCESSED.BUILD-RECORD.STATE.BUILD-STATUS  NOW
    ::
    :-  `BUILD-RECORD.STATE.BUILD-STATUS
    (~(PUT BY BUILDS.STATE) BUILD BUILD-STATUS)
  ::  +CLEANUP: TRY TO CLEAN UP A BUILD AND ITS SUB-BUILDS
  ::
  ++  CLEANUP
    ~/  %CLEANUP
    |=  =BUILD
    ^+  STATE
    ::   DOES THIS BUILD EVEN EXIST?!
    ::
    ?~  MAYBE-BUILD-STATUS=(~(GET BY BUILDS.STATE) BUILD)
      STATE
    ::
    =/  =BUILD-STATUS  U.MAYBE-BUILD-STATUS
    ::  NEVER DELETE A BUILD THAT SOMETHING DEPENDS ON
    ::
    ?^  CLIENTS.BUILD-STATUS
      STATE
    ?^  REQUESTERS.BUILD-STATUS
      STATE
    ::
    (REMOVE-BUILDS ~[BUILD])
  ::  +COLLECT-LIVE-RESOURCES: PRODUCES ALL LIVE RESOURCES FROM SUB-SCRYS
  ::
  ++  COLLECT-LIVE-RESOURCES
    ~/  %COLLECT-LIVE-RESOURCES
    |=  =BUILD
    ^-  (JUG DISC RESOURCE)
    ::
    ?:  ?=(%SCRY -.SCHEMATIC.BUILD)
      =*  RESOURCE  RESOURCE.SCHEMATIC.BUILD
      (MY [(EXTRACT-DISC RESOURCE) (SY [RESOURCE]~)]~)
    ::
    ?:  ?=(%PIN -.SCHEMATIC.BUILD)
      ~
    ::
    =/  SUBS
      ~|  [%COLLECT-LIVE-RESOURCE (BUILD-TO-TAPE BUILD)]
      ~(TAP IN ~(KEY BY SUBS:(~(GOT BY BUILDS.STATE) BUILD)))
    =|  RESOURCES=(JUG DISC RESOURCE)
    |-
    ?~  SUBS
      RESOURCES
    ::
    =/  SUB-RESOURCES=(JUG DISC RESOURCE)  ^$(BUILD I.SUBS)
    =.  RESOURCES  (UNIFY-JUGS RESOURCES SUB-RESOURCES)
    $(SUBS T.SUBS)
  ::  +COLLECT-BLOCKED-RESOURCES: PRODUCES ALL BLOCKED RESOURCES FROM SUB-SCRYS
  ::
  ++  COLLECT-BLOCKED-SUB-SCRYS
    ~/  %COLLECT-BLOCKED-SUB-SCRYS
    |=  =BUILD
    ^-  (SET SCRY-REQUEST)
    ::
    ?:  ?=(%SCRY -.SCHEMATIC.BUILD)
      =,  RESOURCE.SCHEMATIC.BUILD
      =/  =SCRY-REQUEST
        :+  VANE  CARE
        ^-  BEAM
        [[SHIP.DISC.RAIL DESK.DISC.RAIL [%DA DATE.BUILD]] SPUR.RAIL]
      (SY [SCRY-REQUEST ~])
    ::  ONLY RECURSE ON BLOCKED SUB-BUILDS
    ::
    =/  SUBS=(LIST ^BUILD)
      %+  MURN  ~(TAP BY SUBS:(~(GOT BY BUILDS.STATE) BUILD))
      |=  [SUB=^BUILD =BUILD-RELATION]
      ^-  (UNIT ^BUILD)
      ::
      ?.  BLOCKED.BUILD-RELATION
        ~
      `SUB
    ::
    =|  SCRYS=(SET SCRY-REQUEST)
    |-
    ^+  SCRYS
    ?~  SUBS
      SCRYS
    ::
    =.  SCRYS  (~(UNI IN SCRYS) ^$(BUILD I.SUBS))
    $(SUBS T.SUBS)
  ::  +START-CLAY-SUBSCRIPTION: LISTEN FOR CHANGES IN THE FILESYSTEM
  ::
  ++  START-CLAY-SUBSCRIPTION
    ~/  %START-CLAY-SUBSCRIPTION
    |=  =SUBSCRIPTION
    ^+  ..EXECUTE
    ::
    =/  ALREADY-SUBSCRIBED=?
      (~(HAS BY PENDING-SUBSCRIPTIONS.STATE) SUBSCRIPTION)
    ::
    =.  PENDING-SUBSCRIPTIONS.STATE
      (PUT-REQUEST PENDING-SUBSCRIPTIONS.STATE SUBSCRIPTION DUCT)
    ::  DON'T SEND A DUPLICATE MOVE IF WE'RE ALREADY SUBSCRIBED
    ::
    ?:  ALREADY-SUBSCRIBED
      ..EXECUTE
    ::
    =/  =WIRE  (CLAY-SUBSCRIPTION-WIRE [DATE DISC]:SUBSCRIPTION)
    ::
    =/  =NOTE
      ::  REQUEST-CONTENTS: THE SET OF [CARE PATH]S TO SUBSCRIBE TO IN CLAY
      ::
      =/  REQUEST-CONTENTS=(SET [CARE:CLAY PATH])
        %-  SY  ^-  (LIST [CARE:CLAY PATH])
        %+  MURN  ~(TAP IN `(SET RESOURCE)`RESOURCES.SUBSCRIPTION)
        |=  =RESOURCE  ^-  (UNIT [CARE:CLAY PATH])
        ::
        `[CARE.RESOURCE (FLOP SPUR.RAIL.RESOURCE)]
      ::  IF :REQUEST-CONTENTS IS `~`, THIS CODE IS INCORRECT
      ::
      ?<  ?=(~ REQUEST-CONTENTS)
      ::  THEIR: REQUESTEE +SHIP
      ::
      =+  [THEIR DESK]=DISC.SUBSCRIPTION
      ::
      :^  %C  %WARP  SHIP=THEIR
      ^-  RIFF:CLAY
      [DESK `[%MULT `CASE`[%DA DATE.SUBSCRIPTION] REQUEST-CONTENTS]]
    ::
    =.  MOVES  [`MOVE`[DUCT [%PASS WIRE NOTE]] MOVES]
    ::
    ..EXECUTE
  ::  +CANCEL-CLAY-SUBSCRIPTION: REMOVE A SUBSCRIPTION ON :DUCT
  ::
  ++  CANCEL-CLAY-SUBSCRIPTION
    ~/  %CANCEL-CLAY-SUBSCRIPTION
    |=  =SUBSCRIPTION
    ^+  ..EXECUTE
    ::
    =^  ORIGINATOR  PENDING-SUBSCRIPTIONS.STATE
      (DEL-REQUEST PENDING-SUBSCRIPTIONS.STATE SUBSCRIPTION DUCT)
    ::  IF THERE ARE STILL OTHER DUCTS ON THIS SUBSCRIPTION, DON'T SEND A MOVE
    ::
    ?~  ORIGINATOR
      ..EXECUTE
    ::
    =/  =WIRE  (CLAY-SUBSCRIPTION-WIRE [DATE DISC]:SUBSCRIPTION)
    ::
    =/  =NOTE
      =+  [THEIR DESK]=DISC.SUBSCRIPTION
      [%C %WARP SHIP=THEIR `RIFF:CLAY`[DESK ~]]
    ::
    =.  MOVES  [`MOVE`[U.ORIGINATOR [%PASS WIRE NOTE]] MOVES]
    ::
    ..EXECUTE
  ::  +CLAY-SUB-WIRE: THE WIRE TO USE FOR A CLAY SUBSCRIPTION
  ::
  ::    WHILE IT IS POSSIBLE FOR TWO DIFFERENT ROOT BUILDS TO MAKE
  ::    SUBSCRIPTIONS WITH THE SAME WIRE, THOSE WIRES WILL ALWAYS BE ASSOCIATED
  ::    WITH DIFFERENT DUCTS, SO THERE'S NO RISK OF DUPLICATES.
  ::
  ++  CLAY-SUBSCRIPTION-WIRE
    |=  [DATE=@DA =DISC]
    ^-  WIRE
    ::
    =+  [THEIR DESK]=DISC
    ::
    /CLAY-SUB/(SCOT %P THEIR)/[DESK]/(SCOT %DA DATE)
  ::  +START-SCRY-REQUEST: KICK OFF AN ASYNCHRONOUS REQUEST FOR A RESOURCE
  ::
  ++  START-SCRY-REQUEST
    |=  =SCRY-REQUEST
    ^+  ..EXECUTE
    ::  IF WE ARE THE FIRST BLOCK DEPENDING ON THIS SCRY, SEND A MOVE
    ::
    =/  ALREADY-STARTED=?  (~(HAS BY PENDING-SCRYS.STATE) SCRY-REQUEST)
    ::
    =.  PENDING-SCRYS.STATE
      (PUT-REQUEST PENDING-SCRYS.STATE SCRY-REQUEST DUCT)
    ::  DON'T SEND A DUPLICATE MOVE IF WE'VE ALREADY SENT ONE
    ::
    ?:  ALREADY-STARTED
      ..EXECUTE
    ::
    =/  =WIRE  (SCRY-REQUEST-WIRE SCRY-REQUEST)
    ::
    =/  =NOTE
      =,  SCRY-REQUEST
      =/  =DISC  [P Q]:BEAM
      :*  %C  %WARP  THEIR=SHIP.DISC  DESK.DISC
          `[%SING CARE CASE=R.BEAM (FLOP S.BEAM)]
      ==
    ::
    =.  MOVES  [`MOVE`[DUCT [%PASS WIRE NOTE]] MOVES]
    ::
    ..EXECUTE
  ::  +CANCEL-SCRY-REQUEST: CANCEL A PENDING ASYNCHRONOUS SCRY REQUEST
  ::
  ++  CANCEL-SCRY-REQUEST
    |=  =SCRY-REQUEST
    ^+  ..EXECUTE
    ::
    =^  ORIGINATOR  PENDING-SCRYS.STATE
      (DEL-REQUEST PENDING-SCRYS.STATE SCRY-REQUEST DUCT)
    ::  IF THERE ARE STILL OTHER DUCTS ON THIS SUBSCRIPTION, DON'T SEND A MOVE
    ::
    ?~  ORIGINATOR
      ..EXECUTE
    ::
    =/  =WIRE  (SCRY-REQUEST-WIRE SCRY-REQUEST)
    ::
    =/  =NOTE
      =+  [THEIR DESK]=[P Q]:BEAM.SCRY-REQUEST
      [%C %WARP SHIP=THEIR `RIFF:CLAY`[DESK ~]]
    ::
    =.  MOVES  [`MOVE`[U.ORIGINATOR [%PASS WIRE NOTE]] MOVES]
    ::
    ..EXECUTE
  ::  +SCRY-REQUEST-WIRE
  ::
  ++  SCRY-REQUEST-WIRE
    |=  =SCRY-REQUEST
    ^-  WIRE
    (WELP /SCRY-REQUEST (SCRY-REQUEST-TO-PATH SCRY-REQUEST))
  --
--
::
::  END THE =~
::
.  ==
::
::::  VANE INTERFACE
  ::
::  BEGIN WITH A DEFAULT +AXLE AS A BLANK SLATE
::
=|  AX=AXLE
::  A VANE IS ACTIVATED WITH IDENTITY, THE CURRENT DATE, ENTROPY,
::  AND A NAMESPACE FUNCTION
::
|=  [OUR=SHIP NOW=@DA ENY=@UVJ SCRY-GATE=SLEY]
::  ALLOW JETS TO BE REGISTERED WITHIN THIS CORE
::
~%  %FORD  ..IS  ~
|%
::  +CALL: HANDLE A +TASK:ABLE FROM ARVO
::
::    FORD CAN BE TASKED WITH:
::
::      %BUILD: PERFORM A BUILD
::      %KEEP: RESIZE CACHES
::      %KILL: CANCEL A BUILD
::      %WIPE: CLEAR MEMORY
::
::    MOST REQUESTS GET CONVERTED INTO OPERATIONS TO BE PERFORMED INSIDE
::    THE +PER-EVENT CORE, WHICH IS FORD'S MAIN BUILD ENGINE.
::
++  CALL
  |=  [=DUCT TYPE=* WRAPPED-TASK=(HOBO TASK:ABLE)]
  ^-  [(LIST MOVE) _FORD-GATE]
  ::  UNWRAP :TASK FROM :WRAPPED-TASK
  ::
  =/  TASK=TASK:ABLE
    ?.  ?=(%SOFT -.WRAPPED-TASK)
      WRAPPED-TASK
    ((HARD TASK:ABLE) P.WRAPPED-TASK)
  ::  WE WRAP +PER-EVENT WITH A CALL THAT BINDS OUR EVENT ARGS
  ::
  =*  THIS-EVENT  (PER-EVENT [OUR DUCT NOW SCRY-GATE] STATE.AX)
  ::
  ?-    -.TASK
      ::  %BUILD: REQUEST TO PERFORM A BUILD
      ::
      %BUILD
    ::  PERFORM THE BUILD INDICATED BY :TASK
    ::
    ::    WE CALL :START-BUILD ON :THIS-EVENT, WHICH IS THE |PER-EVENT CORE
    ::    WITH THE OUR EVENT-ARGS ALREADY BOUND. :START-BUILD PERFORMS THE
    ::    BUILD AND PRODUCES A PAIR OF :MOVES AND A MUTANT :STATE.
    ::    WE UPDATE OUR :STATE AND PRODUCE IT ALONG WITH :MOVES.
    ::
    =/  =BUILD  [NOW SCHEMATIC.TASK]
    =^  MOVES  STATE.AX  (START-BUILD:THIS-EVENT BUILD LIVE.TASK)
    ::
    [MOVES FORD-GATE]
  ::
      ::  %KEEP: KEEP :COUNT CACHE ENTRIES
      ::
      %KEEP
    ::
    =.  STATE.AX  (KEEP:THIS-EVENT [COMPILER-CACHE BUILD-CACHE]:TASK)
    ::
    [~ FORD-GATE]
  ::
      ::  %KILL: CANCEL A %BUILD
      ::
      %KILL
    ::
    =^  MOVES  STATE.AX  CANCEL:THIS-EVENT
    ::
    [MOVES FORD-GATE]
  ::
      ::  %SUNK: FOREIGN SHIP HAS LOST CONTINUTITY
      ::
      %SUNK
    ::
    [~ FORD-GATE]
  ::
      ::  %VEGA: LEARN OF KERNEL UPGRADE
      ::
      ::    XX CLEAR CACHE, REBUILD LIVE BUILDS
      ::
      %VEGA
    ::
    [~ FORD-GATE]
  ::
      ::  %WIPE: WIPE STORED BUILDS, CLEARING :PERCENT-TO-REMOVE OF THE ENTRIES
      ::
      %WIPE
    ::
    =.  STATE.AX  (WIPE:THIS-EVENT PERCENT-TO-REMOVE.TASK)
    ::
    [~ FORD-GATE]
  ::
      %WEGH
    :_  FORD-GATE
    :_  ~
    :^  DUCT  %GIVE  %MASS
    ^-  MASS
    :+  %FORD  %|
    :~  BUILDS+&+BUILDS.STATE.AX
        COMPILER-CACHE+&+COMPILER-CACHE.STATE.AX
        DOT+&+AX
    ==
  ==
::  +TAKE: RECEIVE A RESPONSE FROM ANOTHER VANE
::
::    A +TAKE IS A RESPONSE TO A REQUEST THAT FORD MADE OF ANOTHER VANE.
::
::    FORD DECODES THE TYPE OF RESPONSE BASED ON THE +WIRE IN THE +TAKE.
::    THE POSSIBILITIES ARE:
::
::      %CLAY-SUB: CLAY NOTIFICATION OF AN UPDATE TO A SUBSCRIPTION
::
::        IF FORD RECEIVES THIS, IT WILL REBUILD ONE OR MORE LIVE BUILDS,
::        TAKING INTO ACCOUNT THE NEW DATE AND CHANGED RESOURCES.
::
::      %SCRY-REQUEST: CLAY RESPONSE TO A REQUEST FOR A RESOURCE
::
::        IF FORD RECEIVES THIS, IT WILL CONTINUE BUILDING ONE OR MORE BUILDS
::        THAT WERE BLOCKED ON THIS RESOURCE.
::
::    THE +SIGN GETS CONVERTED INTO OPERATIONS TO BE PERFORMED INSIDE
::    THE +PER-EVENT CORE, WHICH IS FORD'S MAIN BUILD ENGINE.
::
++  TAKE
  |=  [=WIRE =DUCT WRAPPED-SIGN=(HYPO SIGN)]
  ^-  [(LIST MOVE) _FORD-GATE]
  ::  UNWRAP :SIGN, IGNORING UNNEEDED +TYPE IN :P.WRAPPED-SIGN
  ::
  =/  =SIGN  Q.WRAPPED-SIGN
  ::  :WIRE MUST AT LEAST CONTAIN A TAG FOR DISPATCHING
  ::
  ?>  ?=([@ *] WIRE)
  ::
  |^  ^-  [(LIST MOVE) _FORD-GATE]
      ::
      =^  MOVES  STATE.AX
        ?+  I.WIRE     ~|([%BAD-TAKE-WIRE WIRE] !!)
          %CLAY-SUB      TAKE-REBUILDS
          %SCRY-REQUEST  TAKE-UNBLOCKS
        ==
      ::
      [MOVES FORD-GATE]
    ::  +TAKE-REBUILDS: REBUILD ALL LIVE BUILDS AFFECTED BY THE CLAY CHANGES
    ::
    ++  TAKE-REBUILDS
      ^-  [(LIST MOVE) FORD-STATE]
      ::
      ?>  ?=([%C %WRIS *] SIGN)
      =+  [SHIP DESK DATE]=(RAID:WIRED T.WIRE ~[%P %TAS %DA])
      =/  DISC  [SHIP DESK]
      ::
      =/  =SUBSCRIPTION
        ~|  [%FORD-TAKE-BAD-CLAY-SUB WIRE=WIRE DUCT=DUCT]
        =/  =DUCT-STATUS  (~(GOT BY DUCTS.STATE.AX) DUCT)
        ?>  ?=(%LIVE -.LIVE.DUCT-STATUS)
        ?>  ?=(^ LAST-SENT.LIVE.DUCT-STATUS)
        ?>  ?=(^ SUBSCRIPTION.U.LAST-SENT.LIVE.DUCT-STATUS)
        U.SUBSCRIPTION.U.LAST-SENT.LIVE.DUCT-STATUS
      ::
      =/  DUCTS=(LIST ^DUCT)
        ~|  [%FORD-TAKE-MISSING-SUBSCRIPTION SUBSCRIPTION]
        (GET-REQUEST-DUCTS PENDING-SUBSCRIPTIONS.STATE.AX SUBSCRIPTION)
      ::
      =|  MOVES=(LIST MOVE)
      |-  ^+  [MOVES STATE.AX]
      ?~  DUCTS  [MOVES STATE.AX]
      ::
      =*  EVENT-ARGS  [[OUR I.DUCTS NOW SCRY-GATE] STATE.AX]
      =*  REBUILD  REBUILD:(PER-EVENT EVENT-ARGS)
      =^  DUCT-MOVES  STATE.AX
        (REBUILD SUBSCRIPTION P.CASE.SIGN DISC CARE-PATHS.SIGN)
      ::
      $(DUCTS T.DUCTS, MOVES (WELD MOVES DUCT-MOVES))
    ::  +TAKE-UNBLOCKS: UNBLOCK ALL BUILDS WAITING ON THIS SCRY REQUEST
    ::
    ++  TAKE-UNBLOCKS
      ^-  [(LIST MOVE) FORD-STATE]
      ::
      ?>  ?=([%C %WRIT *] SIGN)
      ::  SCRY-REQUEST: THE +SCRY-REQUEST WE HAD PREVIOUSLY BLOCKED ON
      ::
      =/  =SCRY-REQUEST
        ~|  [%FORD-TAKE-BAD-SCRY-REQUEST WIRE=WIRE DUCT=DUCT]
        (NEED (PATH-TO-SCRY-REQUEST T.WIRE))
      ::  SCRY-RESULT: PARSE A (UNIT CAGE) FROM :SIGN
      ::
      ::    IF THE RESULT IS `~`, THE REQUESTED RESOURCE WAS NOT AVAILABLE.
      ::
      =/  SCRY-RESULT=(UNIT CAGE)
        ?~  RIOT.SIGN
          ~
        `R.U.RIOT.SIGN
      ::
      =/  DUCTS=(LIST ^DUCT)
        ~|  [%FORD-TAKE-MISSING-SCRY-REQUEST SCRY-REQUEST]
        (GET-REQUEST-DUCTS PENDING-SCRYS.STATE.AX SCRY-REQUEST)
      ::
      =|  MOVES=(LIST MOVE)
      |-  ^+  [MOVES STATE.AX]
      ?~  DUCTS  [MOVES STATE.AX]
      ::
      =*  EVENT-ARGS  [[OUR I.DUCTS NOW SCRY-GATE] STATE.AX]
      ::  UNBLOCK THE BUILDS THAT HAD BLOCKED ON :RESOURCE
      ::
      =*  UNBLOCK  UNBLOCK:(PER-EVENT EVENT-ARGS)
      =^  DUCT-MOVES  STATE.AX  (UNBLOCK SCRY-REQUEST SCRY-RESULT)
      ::
      $(DUCTS T.DUCTS, MOVES (WELD MOVES DUCT-MOVES))
  --
::  +LOAD: MIGRATE OLD STATE TO NEW STATE (CALLED ON VANE RELOAD)
::
++  LOAD
  |=  OLD=AXLE
  ^+  ..^$
  ::
  ~!  %LOADING
  ..^$(AX OLD)
::  +STAY: PRODUCE CURRENT STATE
::
++  STAY  `AXLE`AX
::  +SCRY: REQUEST A PATH IN THE URBIT NAMESPACE
::
++  SCRY
  |=  *
  [~ ~]
::  %UTILITIES
::
::+|
::
++  FORD-GATE  ..$
--
