::  BIP32 IMPLEMENTATION IN HOON
::
::  TO USE, CALL ONE OF THE CORE INITIALIZATION ARMS.
::  USING THE PRODUCED CORE, DERIVE AS NEEDED AND TAKE OUT THE DATA YOU WANT.
::
::NOTE  TESTED TO BE CORRECT AGAINST
::      HTTPS://EN.BITCOIN.IT/WIKI/BIP_0032_TESTVECTORS
::
=,  HMAC:CRYPTO
=,  SECP:CRYPTO
=+  ECC=SECP256K1
::
::  PRV:  PRIVATE KEY
::  PUB:  PUBLIC KEY
::  CAD:  CHAIN CODE
::  DEP:  DEPTH IN CHAIN
::  IND:  INDEX AT DEPTH
::  PIF:  PARENT FINGERPRINT (4 BYTES)
|_  [PRV=@ PUB=PONT CAD=@ DEP=@UD IND=@UD PIF=@]
::
+=  KEYC  [KEY=@ CAI=@]  ::  PRV/PUB KEY + CHAIN CODE
::
::  ELLIPTIC CURVE OPERATIONS AND VALUES
::
++  POINT  PRIV-TO-PUB.ECC
::
++  SER-P  COMPRESS-POINT.ECC
::
++  N      ^N:ECC
::
::  CORE INITIALIZATION
::
++  FROM-SEED
  |=  BYTS
  ^+  +>
  =+  DER=(HMAC-SHA512L [12 'DEES NIOCTIB'] [WID DAT])
  =+  PRI=(CUT 3 [32 32] DER)
  +>.$(PRV PRI, PUB (POINT PRI), CAD (CUT 3 [0 32] DER))
::
++  FROM-PRIVATE
  |=  KEYC
  +>(PRV KEY, PUB (POINT KEY), CAD CAI)
::
++  FROM-PUBLIC
  |=  KEYC
  +>(PUB (DECOMPRESS-POINT.ECC KEY), CAD CAI)
::
++  FROM-PUBLIC-POINT
  |=  [PON=PONT CAI=@]
  +>(PUB PON, CAD CAI)
::
++  FROM-EXTENDED
  |=  T=TAPE
  =+  X=(DE-BASE58CHECK 4 T)
  =>  |%
      ++  TAKE
        |=  B=@UD
        ^-  [V=@ X=@]
        :-  (END 3 B X)
        (RSH 3 B X)
      --
  =^  K  X  (TAKE 33)
  =^  C  X  (TAKE 32)
  =^  I  X  (TAKE 4)
  =^  P  X  (TAKE 4)
  =^  D  X  (TAKE 1)
  ?>  =(0 X)  ::  SANITY CHECK
  %.  [D I P]
  =<  SET-METADATA
  =+  V=(SCAG 4 T)
  ?:  =("XPRV" V)  (FROM-PRIVATE K C)
  ?:  =("XPUB" V)  (FROM-PUBLIC K C)
  !!
::
++  SET-METADATA
  |=  [D=@UD I=@UD P=@]
  +>(DEP D, IND I, PIF P)
::
::  DERIVATION
::
++  DERIVATION-PATH
  ;~  PFIX
    ;~(POSE (JEST 'M/') (EASY ~))
  %+  MOST  NET
  ;~  POSE
    %+  COOK
      |=(I=@ (ADD I (BEX 31)))
    ;~(SFIX DEM SAY)
  ::
    DEM
  ==  ==
::
++  DERIVE-PATH
  |=  T=TAPE
  %-  DERIVE-SEQUENCE
  (SCAN T DERIVATION-PATH)
::
++  DERIVE-SEQUENCE
  |=  J=(LIST @U)
  ?~  J  +>
  =.  +>  (DERIVE I.J)
  $(J T.J)
::
++  DERIVE
  ?:  =(0 PRV)
    DERIVE-PUBLIC
  DERIVE-PRIVATE
::
++  DERIVE-PRIVATE
  |=  I=@U
  ^+  +>
  ::  WE MUST HAVE A PRIVATE KEY TO DERIVE THE NEXT ONE
  ?:  =(0 PRV)
    ~|  %KNOW-NO-PRIVATE-KEY
    !!
  ::  DERIVE CHILD AT I
  =+  ^-  [LEFT=@ RIGHT=@]  ::TODO  =/ W/O FACE
    =-  [(CUT 3 [32 32] -) (CUT 3 [0 32] -)]
    %+  HMAC-SHA512L  [32 CAD]
    :-  37
    ?:  (GTE I (BEX 31))
      ::  HARDENED CHILD
      (CAN 3 ~[4^I 32^PRV 1^0])
    ::  NORMAL CHILD
    (CAN 3 ~[4^I 33^(SER-P (POINT PRV))])
  =+  KEY=(MOD (ADD LEFT PRV) N)
  ::  RARE EXCEPTION, INVALID KEY, GO TO THE NEXT ONE
  ?:  |(=(0 KEY) (GTE LEFT N))  $(I +(I))
  %_  +>.$
    PRV   KEY
    PUB   (POINT KEY)
    CAD   RIGHT
    DEP   +(DEP)
    IND   I
    PIF   FINGERPRINT
  ==
::
++  DERIVE-PUBLIC
  |=  I=@U
  ^+  +>
  ::  PUBLIC KEYS CAN'T BE HARDENED
  ?:  (GTE I (BEX 31))
    ~|  %CANT-DERIVE-HARDENED-PUBLIC-KEY
    !!
  ::  DERIVE CHILD AT I
  =+  ^-  [LEFT=@ RIGHT=@]  ::TODO  =/  W/O FACE
    =-  [(CUT 3 [32 32] -) (CUT 3 [0 32] -)]
    %+  HMAC-SHA512L  [32 CAD]
    37^(CAN 3 ~[4^I 33^(SER-P PUB)])
  ::  RARE EXCEPTION, INVALID KEY, GO TO THE NEXT ONE
  ?:  (GTE LEFT N)  $(I +(I))  ::TODO  OR CHILD KEY IS "POINT AT INFINITY"
  %_  +>.$
    PUB   (JC-ADD.ECC (POINT LEFT) PUB)
    CAD   RIGHT
    DEP   +(DEP)
    IND   I
    PIF   FINGERPRINT
  ==
::
::  RENDERING
::
++  PRIVATE-KEY     ?.(=(0 PRV) PRV ~|(%KNOW-NO-PRIVATE-KEY !!))
++  PUBLIC-KEY      (SER-P PUB)
++  CHAIN-CODE      CAD
++  PRIVATE-CHAIN   [PRIVATE-KEY CAD]
++  PUBLIC-CHAIN    [PUBLIC-KEY CAD]
::
++  IDENTITY        (HASH160 PUBLIC-KEY)
++  FINGERPRINT     (CUT 3 [16 4] IDENTITY)
::
++  PRV-EXTENDED
  %+  EN-B58C-BIP32  0X488.ADE4
  (BUILD-EXTENDED PRIVATE-KEY)
::
++  PUB-EXTENDED
  %+  EN-B58C-BIP32  0X488.B21E
  (BUILD-EXTENDED PUBLIC-KEY)
::
++  BUILD-EXTENDED
  |=  KEY=@
  %+  CAN  3
  :~  33^KEY
      32^CAD
      4^IND
      4^PIF
      1^DEP
  ==
::
++  EN-B58C-BIP32
  |=  [V=@ K=@]
  (EN-BASE58CHECK [4 V] [74 K])
::
::  BASE58CHECK
::
++  EN-BASE58CHECK
  ::  V: VERSION BYTES
  ::  D: DATA
  |=  [V=BYTS D=BYTS]
  %-  EN-BASE58:MIMES:HTML
  =+  P=[(ADD WID.V WID.D) (CAN 3 ~[D V])]
  =-  (CAN 3 ~[4^- P])
  %^  RSH  3  28
  (SHA-256L:SHA 32 (SHA-256L:SHA P))
::
++  DE-BASE58CHECK
  ::  VW: AMOUNT OF VERSION BYTES
  |=  [VW=@U T=TAPE]
  =+  X=(DE-BASE58:MIMES:HTML T)
  =+  HASH=(SHA-256L:SHA 32 (SHA-256:SHA (RSH 3 4 X)))
  ?>  =((END 3 4 X) (RSH 3 28 HASH))
  (CUT 3 [VW (SUB (MET 3 X) (ADD 4 VW))] X)
::
++  HASH160
  |=  D=@
  (RIPEMD-160:RIPEMD:CRYPTO 256 (SHA-256:SHA D))
--
