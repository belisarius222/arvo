::  |BASE64: FLEXIBLE BASE64 ENCODING FOR LITTLE-ENDIAN ATOMS
::
::  PAD: INCLUDE PADDING WHEN ENCODING, REQUIRE WHEN DECODING
::  URL: USE URL-SAFE CHARACTERS '-' FOR '+' AND '_' FOR '/'
::
=+  [PAD=& URL=|]
|%
::
+$  BYTE    @D
+$  WORD24  @
::
++  DIV-CEIL
  ::  DIVIDE, ROUNDING UP.
  |=  [X=@ Y=@]  ^-  @
  ?:  =(0 (MOD X Y))
    (DIV X Y)
  +((DIV X Y))
::
++  EXPLODE-BYTES
  ::  EXPLODE A BYTESTRING INTO LIST OF BYTES. RESULT IS IN LSB ORDER.
  |=  =OCTS  ^-  (LIST BYTE)
  =/  ATOM-BYTE-WIDTH  (MET 3 Q.OCTS)
  =/  LEADING-ZEROS    (SUB P.OCTS ATOM-BYTE-WIDTH)
  (WELD (REAP LEADING-ZEROS 0) (RIP 3 Q.OCTS))
::
++  EXPLODE-WORDS
  ::  EXPLODE A BYTESTRING TO WORDS OF BIT-WIDTH `WID`. RESULT IS IN LSW ORDER.
  |=  [WID=@ =OCTS]
  ^-  (LIST @)
  =/  ATOM-BIT-WIDTH   (MET 0 Q.OCTS)
  =/  OCTS-BIT-WIDTH   (MUL 8 P.OCTS)
  =/  ATOM-WORD-WIDTH  (DIV-CEIL ATOM-BIT-WIDTH WID)
  =/  RSLT-WORD-WIDTH  (DIV-CEIL OCTS-BIT-WIDTH WID)
  =/  PAD              (SUB RSLT-WORD-WIDTH ATOM-WORD-WIDTH)
  =/  X  (RIPN WID Q.OCTS)
  %+  WELD  X
  (REAP PAD 0)
::
::  +EN:BASE64: ENCODE +OCTS TO BASE64 CORD
::
::  ENCODE AN `OCTS` INTO A BASE64 STRING.
::
::  FIRST, WE BREAK UP THE INPUT INTO A LIST OF 24-BIT WORDS. THE INPUT
::  MIGHT NOT BE A MULTIPLE OF 24-BITS, SO WE ADD 0-2 PADDING BYTES AT
::  THE END (TO THE LEAST-SIGNIFICANT SIDE, WITH A LEFT-SHIFT).
::
::  THEN, WE ENCODE EACH BLOCK INTO FOUR BASE64 CHARACTERS.
::
::  FINALLY WE REMOVE THE PADDING THAT WE ADDED AT THE BEGINNING: FOR
::  EACH BYTE THAT WAS ADDED, WE REPLACE ONE CHARACTER WITH AN = (UNLESS
::  `PAD` IS FALSE, IN WHICH CASE WE JUST REMOVE THE EXTRA CHARACTERS).
::
++  EN
  ^-  $-(OCTS CORD)
  ::
  =/  CHA
    ?:  URL
      'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'
    'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/'
  ::
  |^  |=  BS=OCTS  ^-  CORD
      =+  ^-  [PADDING=@ BLOCKS=(LIST WORD24)]
          (OCTS-TO-BLOCKS BS)
      (CRIP (FLOP (UNPAD PADDING (ENCODE-BLOCKS BLOCKS))))
  ::
  ++  OCTS-TO-BLOCKS
    |=  BS=OCTS  ^-  [PADDING=@UD (LIST WORD24)]
    =/  PADDING=@UD  (~(DIF FO 3) 0 P.BS)
    =/  PADDED=OCTS  [(ADD PADDING P.BS) (LSH 3 PADDING (REV 3 BS))]
    [PADDING (EXPLODE-WORDS 24 PADDED)]
  ::
  ++  UNPAD
    |=  [EXTRA=@ T=TAPE]  ^-  TAPE
    =/  WITHOUT  (SLAG EXTRA T)
    ?.  PAD  WITHOUT
    (WELD (REAP EXTRA '=') WITHOUT)
  ::
  ++  ENCODE-BLOCKS
    |=  WS=(LIST WORD24)  ^-  TAPE
    (ZING (TURN WS ENCODE-BLOCK))
  ::
  ++  ENCODE-BLOCK
    |=  W=WORD24  ^-  TAPE
    =/  A  (CUT 3 [(CUT 0 [0 6] W) 1] CHA)
    =/  B  (CUT 3 [(CUT 0 [6 6] W) 1] CHA)
    =/  C  (CUT 3 [(CUT 0 [12 6] W) 1] CHA)
    =/  D  (CUT 3 [(CUT 0 [18 6] W) 1] CHA)
    ~[A B C D]
  --
::
::  +DE:BASE64: DECODE BASE64 CORD TO (UNIT @)
::
++  DE
  |=  A=CORD
  ^-  (UNIT OCTS)
  (RUSH A PARSE)
::  +PARSE:BASE64: PARSE BASE64 CORD TO +OCTS
::
++  PARSE
  =<  ^-  $-(NAIL (LIKE OCTS))
      %+  SEAR  REDUCE
      ;~  PLUG
        %-  PLUS  ;~  POSE
          (COOK |=(A=@ (SUB A 'A')) (SHIM 'A' 'Z'))
          (COOK |=(A=@ (SUB A 'G')) (SHIM 'A' 'Z'))
          (COOK |=(A=@ (ADD A 4)) (SHIM '0' '9'))
          (COLD 62 (JUST ?:(URL '-' '+')))
          (COLD 63 (JUST ?:(URL '_' '/')))
        ==
        (STUN 0^2 (COLD %0 TIS))
      ==
  |%
  ::  +REDUCE:PARSE:BASE64: REDUCE, MEASURE, AND SWAP BASE64 DIGITS
  ::
  ++  REDUCE
    |=  [DAT=(LIST @) DAP=(LIST @)]
    ^-  (UNIT OCTS)
    =/  LAT  (LENT DAT)
    =/  LAP  (LENT DAP)
    =/  DIF  (~(DIF FO 4) 0 LAT)
    ?:  &(PAD !=(DIF LAP))
      ::  PADDING REQUIRED AND INCORRECT
      ~&(%BASE-64-PADDING-ERR-ONE ~)
    ?:  &(!PAD !=(0 LAP))
      ::  PADDING NOT REQUIRED BUT PRESENT
      ~&(%BASE-64-PADDING-ERR-TWO ~)
    =/  LEN  (SUB (MUL 3 (DIV (ADD LAT DIF) 4)) DIF)
    :+  ~  LEN
    %+  SWP  3
    ::  %+  BASE  64
    %+  ROLL
      (WELD DAT (REAP DIF 0))
    |=([P=@ Q=@] (ADD P (MUL 64 Q)))
  --
--

